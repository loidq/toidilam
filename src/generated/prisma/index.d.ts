
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model OrganizationMember
 * 
 */
export type OrganizationMember = $Result.DefaultSelection<Prisma.$OrganizationMemberPayload>
/**
 * Model OrganizationStorage
 * 
 */
export type OrganizationStorage = $Result.DefaultSelection<Prisma.$OrganizationStoragePayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectView
 * 
 */
export type ProjectView = $Result.DefaultSelection<Prisma.$ProjectViewPayload>
/**
 * Model ProjectSettingNotification
 * 
 */
export type ProjectSettingNotification = $Result.DefaultSelection<Prisma.$ProjectSettingNotificationPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskStatus
 * 
 */
export type TaskStatus = $Result.DefaultSelection<Prisma.$TaskStatusPayload>
/**
 * Model TaskAssignee
 * 
 */
export type TaskAssignee = $Result.DefaultSelection<Prisma.$TaskAssigneePayload>
/**
 * Model TaskChecklist
 * 
 */
export type TaskChecklist = $Result.DefaultSelection<Prisma.$TaskChecklistPayload>
/**
 * Model TaskPoint
 * 
 */
export type TaskPoint = $Result.DefaultSelection<Prisma.$TaskPointPayload>
/**
 * Model TaskAutomation
 * 
 */
export type TaskAutomation = $Result.DefaultSelection<Prisma.$TaskAutomationPayload>
/**
 * Model Vision
 * 
 */
export type Vision = $Result.DefaultSelection<Prisma.$VisionPayload>
/**
 * Model Field
 * 
 */
export type Field = $Result.DefaultSelection<Prisma.$FieldPayload>
/**
 * Model Grid
 * 
 */
export type Grid = $Result.DefaultSelection<Prisma.$GridPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TaskTag
 * 
 */
export type TaskTag = $Result.DefaultSelection<Prisma.$TaskTagPayload>
/**
 * Model Scheduler
 * 
 */
export type Scheduler = $Result.DefaultSelection<Prisma.$SchedulerPayload>
/**
 * Model FileStorage
 * 
 */
export type FileStorage = $Result.DefaultSelection<Prisma.$FileStoragePayload>
/**
 * Model Stat
 * 
 */
export type Stat = $Result.DefaultSelection<Prisma.$StatPayload>
/**
 * Model Dashboard
 * 
 */
export type Dashboard = $Result.DefaultSelection<Prisma.$DashboardPayload>
/**
 * Model DashboardComponent
 * 
 */
export type DashboardComponent = $Result.DefaultSelection<Prisma.$DashboardComponentPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model Timer
 * 
 */
export type Timer = $Result.DefaultSelection<Prisma.$TimerPayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserStatus: {
  INACTIVE: 'INACTIVE',
  ACTIVE: 'ACTIVE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const MemberRole: {
  GUEST: 'GUEST',
  MEMBER: 'MEMBER',
  MANAGER: 'MANAGER',
  LEADER: 'LEADER'
};

export type MemberRole = (typeof MemberRole)[keyof typeof MemberRole]


export const OrganizationRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  MEMBER: 'MEMBER'
};

export type OrganizationRole = (typeof OrganizationRole)[keyof typeof OrganizationRole]


export const InvitationStatus: {
  REJECTED: 'REJECTED',
  ACCEPTED: 'ACCEPTED',
  INVITING: 'INVITING'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const ProjectViewType: {
  LIST: 'LIST',
  BOARD: 'BOARD',
  CALENDAR: 'CALENDAR',
  TIMELINE: 'TIMELINE',
  GOAL: 'GOAL',
  TEAM: 'TEAM',
  ACTIVITY: 'ACTIVITY',
  DASHBOARD: 'DASHBOARD',
  GRID: 'GRID'
};

export type ProjectViewType = (typeof ProjectViewType)[keyof typeof ProjectViewType]


export const TaskType: {
  TASK: 'TASK',
  BUG: 'BUG',
  NEW_FEATURE: 'NEW_FEATURE',
  IMPROVEMENT: 'IMPROVEMENT'
};

export type TaskType = (typeof TaskType)[keyof typeof TaskType]


export const TaskPriority: {
  URGENT: 'URGENT',
  HIGH: 'HIGH',
  NORMAL: 'NORMAL',
  LOW: 'LOW'
};

export type TaskPriority = (typeof TaskPriority)[keyof typeof TaskPriority]


export const FieldType: {
  NUMBER: 'NUMBER',
  TEXT: 'TEXT',
  DATE: 'DATE',
  SELECT: 'SELECT',
  MULTISELECT: 'MULTISELECT',
  CHECKBOX: 'CHECKBOX',
  URL: 'URL',
  EMAIL: 'EMAIL',
  FILES: 'FILES',
  PHONE: 'PHONE',
  PERSON: 'PERSON',
  CREATED_AT: 'CREATED_AT',
  CREATED_BY: 'CREATED_BY',
  UPDATED_AT: 'UPDATED_AT',
  UPDATED_BY: 'UPDATED_BY'
};

export type FieldType = (typeof FieldType)[keyof typeof FieldType]


export const StatusType: {
  DONE: 'DONE',
  INPROCESS: 'INPROCESS',
  TODO: 'TODO'
};

export type StatusType = (typeof StatusType)[keyof typeof StatusType]


export const OrgStorageType: {
  AWS_S3: 'AWS_S3',
  DIGITAL_OCEAN_S3: 'DIGITAL_OCEAN_S3'
};

export type OrgStorageType = (typeof OrgStorageType)[keyof typeof OrgStorageType]


export const FileType: {
  FILE: 'FILE',
  FOLDER: 'FOLDER'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const FileOwnerType: {
  USER: 'USER',
  TASK: 'TASK',
  DISCUSSION: 'DISCUSSION',
  DOCUMENT: 'DOCUMENT'
};

export type FileOwnerType = (typeof FileOwnerType)[keyof typeof FileOwnerType]


export const StatType: {
  PROJECT_TASK_BY_DAY: 'PROJECT_TASK_BY_DAY',
  MEMBER_TASK_BY_DAY: 'MEMBER_TASK_BY_DAY'
};

export type StatType = (typeof StatType)[keyof typeof StatType]


export const DashboardComponentType: {
  LINE: 'LINE',
  SUMMARY: 'SUMMARY',
  PIE: 'PIE',
  LISTTAB: 'LISTTAB',
  LIST: 'LIST',
  COLUMN: 'COLUMN',
  BURNDOWN: 'BURNDOWN',
  BURNUP: 'BURNUP'
};

export type DashboardComponentType = (typeof DashboardComponentType)[keyof typeof DashboardComponentType]


export const ActivityType: {
  TASK_CREATED: 'TASK_CREATED',
  TASK_TITLE_CHANGED: 'TASK_TITLE_CHANGED',
  TASK_DESC_CHANGED: 'TASK_DESC_CHANGED',
  TASK_DUEDATE_CHANGED: 'TASK_DUEDATE_CHANGED',
  TASK_ASSIGNEE_ADDED: 'TASK_ASSIGNEE_ADDED',
  TASK_ASSIGNEE_REMOVED: 'TASK_ASSIGNEE_REMOVED',
  TASK_STATUS_CREATED: 'TASK_STATUS_CREATED',
  TASK_STATUS_CHANGED: 'TASK_STATUS_CHANGED',
  TASK_PROGRESS_CHANGED: 'TASK_PROGRESS_CHANGED',
  TASK_PRIORITY_CHANGED: 'TASK_PRIORITY_CHANGED',
  TASK_POINT_CHANGED: 'TASK_POINT_CHANGED',
  TASK_VISION_CHANGED: 'TASK_VISION_CHANGED',
  TASK_COMMENT_CREATED: 'TASK_COMMENT_CREATED',
  TASK_COMMENT_CHANGED: 'TASK_COMMENT_CHANGED',
  TASK_COMMENT_REMOVED: 'TASK_COMMENT_REMOVED',
  TASK_ATTACHMENT_ADDED: 'TASK_ATTACHMENT_ADDED',
  TASK_ATTACHMENT_REMOVED: 'TASK_ATTACHMENT_REMOVED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const ActivityTargetType: {
  TASK: 'TASK',
  PROJECT: 'PROJECT'
};

export type ActivityTargetType = (typeof ActivityTargetType)[keyof typeof ActivityTargetType]

}

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type MemberRole = $Enums.MemberRole

export const MemberRole: typeof $Enums.MemberRole

export type OrganizationRole = $Enums.OrganizationRole

export const OrganizationRole: typeof $Enums.OrganizationRole

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type ProjectViewType = $Enums.ProjectViewType

export const ProjectViewType: typeof $Enums.ProjectViewType

export type TaskType = $Enums.TaskType

export const TaskType: typeof $Enums.TaskType

export type TaskPriority = $Enums.TaskPriority

export const TaskPriority: typeof $Enums.TaskPriority

export type FieldType = $Enums.FieldType

export const FieldType: typeof $Enums.FieldType

export type StatusType = $Enums.StatusType

export const StatusType: typeof $Enums.StatusType

export type OrgStorageType = $Enums.OrgStorageType

export const OrgStorageType: typeof $Enums.OrgStorageType

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type FileOwnerType = $Enums.FileOwnerType

export const FileOwnerType: typeof $Enums.FileOwnerType

export type StatType = $Enums.StatType

export const StatType: typeof $Enums.StatType

export type DashboardComponentType = $Enums.DashboardComponentType

export const DashboardComponentType: typeof $Enums.DashboardComponentType

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type ActivityTargetType = $Enums.ActivityTargetType

export const ActivityTargetType: typeof $Enums.ActivityTargetType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationMember`: Exposes CRUD operations for the **OrganizationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationMembers
    * const organizationMembers = await prisma.organizationMember.findMany()
    * ```
    */
  get organizationMember(): Prisma.OrganizationMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationStorage`: Exposes CRUD operations for the **OrganizationStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationStorages
    * const organizationStorages = await prisma.organizationStorage.findMany()
    * ```
    */
  get organizationStorage(): Prisma.OrganizationStorageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectView`: Exposes CRUD operations for the **ProjectView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectViews
    * const projectViews = await prisma.projectView.findMany()
    * ```
    */
  get projectView(): Prisma.ProjectViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectSettingNotification`: Exposes CRUD operations for the **ProjectSettingNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectSettingNotifications
    * const projectSettingNotifications = await prisma.projectSettingNotification.findMany()
    * ```
    */
  get projectSettingNotification(): Prisma.ProjectSettingNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskStatus`: Exposes CRUD operations for the **TaskStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskStatuses
    * const taskStatuses = await prisma.taskStatus.findMany()
    * ```
    */
  get taskStatus(): Prisma.TaskStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAssignee`: Exposes CRUD operations for the **TaskAssignee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAssignees
    * const taskAssignees = await prisma.taskAssignee.findMany()
    * ```
    */
  get taskAssignee(): Prisma.TaskAssigneeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskChecklist`: Exposes CRUD operations for the **TaskChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskChecklists
    * const taskChecklists = await prisma.taskChecklist.findMany()
    * ```
    */
  get taskChecklist(): Prisma.TaskChecklistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskPoint`: Exposes CRUD operations for the **TaskPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskPoints
    * const taskPoints = await prisma.taskPoint.findMany()
    * ```
    */
  get taskPoint(): Prisma.TaskPointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAutomation`: Exposes CRUD operations for the **TaskAutomation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAutomations
    * const taskAutomations = await prisma.taskAutomation.findMany()
    * ```
    */
  get taskAutomation(): Prisma.TaskAutomationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vision`: Exposes CRUD operations for the **Vision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visions
    * const visions = await prisma.vision.findMany()
    * ```
    */
  get vision(): Prisma.VisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.field`: Exposes CRUD operations for the **Field** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fields
    * const fields = await prisma.field.findMany()
    * ```
    */
  get field(): Prisma.FieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grid`: Exposes CRUD operations for the **Grid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grids
    * const grids = await prisma.grid.findMany()
    * ```
    */
  get grid(): Prisma.GridDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskTag`: Exposes CRUD operations for the **TaskTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskTags
    * const taskTags = await prisma.taskTag.findMany()
    * ```
    */
  get taskTag(): Prisma.TaskTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduler`: Exposes CRUD operations for the **Scheduler** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedulers
    * const schedulers = await prisma.scheduler.findMany()
    * ```
    */
  get scheduler(): Prisma.SchedulerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileStorage`: Exposes CRUD operations for the **FileStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileStorages
    * const fileStorages = await prisma.fileStorage.findMany()
    * ```
    */
  get fileStorage(): Prisma.FileStorageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stat`: Exposes CRUD operations for the **Stat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stats
    * const stats = await prisma.stat.findMany()
    * ```
    */
  get stat(): Prisma.StatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboard`: Exposes CRUD operations for the **Dashboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dashboards
    * const dashboards = await prisma.dashboard.findMany()
    * ```
    */
  get dashboard(): Prisma.DashboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboardComponent`: Exposes CRUD operations for the **DashboardComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardComponents
    * const dashboardComponents = await prisma.dashboardComponent.findMany()
    * ```
    */
  get dashboardComponent(): Prisma.DashboardComponentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timer`: Exposes CRUD operations for the **Timer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timers
    * const timers = await prisma.timer.findMany()
    * ```
    */
  get timer(): Prisma.TimerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    OrganizationMember: 'OrganizationMember',
    OrganizationStorage: 'OrganizationStorage',
    Member: 'Member',
    Project: 'Project',
    ProjectView: 'ProjectView',
    ProjectSettingNotification: 'ProjectSettingNotification',
    Task: 'Task',
    TaskStatus: 'TaskStatus',
    TaskAssignee: 'TaskAssignee',
    TaskChecklist: 'TaskChecklist',
    TaskPoint: 'TaskPoint',
    TaskAutomation: 'TaskAutomation',
    Vision: 'Vision',
    Field: 'Field',
    Grid: 'Grid',
    Tag: 'Tag',
    TaskTag: 'TaskTag',
    Scheduler: 'Scheduler',
    FileStorage: 'FileStorage',
    Stat: 'Stat',
    Dashboard: 'Dashboard',
    DashboardComponent: 'DashboardComponent',
    Activity: 'Activity',
    Comment: 'Comment',
    Application: 'Application',
    Timer: 'Timer',
    Favorite: 'Favorite'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "organization" | "organizationMember" | "organizationStorage" | "member" | "project" | "projectView" | "projectSettingNotification" | "task" | "taskStatus" | "taskAssignee" | "taskChecklist" | "taskPoint" | "taskAutomation" | "vision" | "field" | "grid" | "tag" | "taskTag" | "scheduler" | "fileStorage" | "stat" | "dashboard" | "dashboardComponent" | "activity" | "comment" | "application" | "timer" | "favorite"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      OrganizationMember: {
        payload: Prisma.$OrganizationMemberPayload<ExtArgs>
        fields: Prisma.OrganizationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findFirst: {
            args: Prisma.OrganizationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findMany: {
            args: Prisma.OrganizationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          create: {
            args: Prisma.OrganizationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          createMany: {
            args: Prisma.OrganizationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          delete: {
            args: Prisma.OrganizationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          update: {
            args: Prisma.OrganizationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          aggregate: {
            args: Prisma.OrganizationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationMember>
          }
          groupBy: {
            args: Prisma.OrganizationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberCountAggregateOutputType> | number
          }
        }
      }
      OrganizationStorage: {
        payload: Prisma.$OrganizationStoragePayload<ExtArgs>
        fields: Prisma.OrganizationStorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationStorageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationStorageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload>
          }
          findFirst: {
            args: Prisma.OrganizationStorageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationStorageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload>
          }
          findMany: {
            args: Prisma.OrganizationStorageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload>[]
          }
          create: {
            args: Prisma.OrganizationStorageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload>
          }
          createMany: {
            args: Prisma.OrganizationStorageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationStorageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload>[]
          }
          delete: {
            args: Prisma.OrganizationStorageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload>
          }
          update: {
            args: Prisma.OrganizationStorageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload>
          }
          deleteMany: {
            args: Prisma.OrganizationStorageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationStorageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationStorageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload>[]
          }
          upsert: {
            args: Prisma.OrganizationStorageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationStoragePayload>
          }
          aggregate: {
            args: Prisma.OrganizationStorageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationStorage>
          }
          groupBy: {
            args: Prisma.OrganizationStorageGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationStorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationStorageCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationStorageCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectView: {
        payload: Prisma.$ProjectViewPayload<ExtArgs>
        fields: Prisma.ProjectViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload>
          }
          findFirst: {
            args: Prisma.ProjectViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload>
          }
          findMany: {
            args: Prisma.ProjectViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload>[]
          }
          create: {
            args: Prisma.ProjectViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload>
          }
          createMany: {
            args: Prisma.ProjectViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload>[]
          }
          delete: {
            args: Prisma.ProjectViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload>
          }
          update: {
            args: Prisma.ProjectViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload>
          }
          deleteMany: {
            args: Prisma.ProjectViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload>[]
          }
          upsert: {
            args: Prisma.ProjectViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectViewPayload>
          }
          aggregate: {
            args: Prisma.ProjectViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectView>
          }
          groupBy: {
            args: Prisma.ProjectViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectViewCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectViewCountAggregateOutputType> | number
          }
        }
      }
      ProjectSettingNotification: {
        payload: Prisma.$ProjectSettingNotificationPayload<ExtArgs>
        fields: Prisma.ProjectSettingNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectSettingNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectSettingNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload>
          }
          findFirst: {
            args: Prisma.ProjectSettingNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectSettingNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload>
          }
          findMany: {
            args: Prisma.ProjectSettingNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload>[]
          }
          create: {
            args: Prisma.ProjectSettingNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload>
          }
          createMany: {
            args: Prisma.ProjectSettingNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectSettingNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload>[]
          }
          delete: {
            args: Prisma.ProjectSettingNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload>
          }
          update: {
            args: Prisma.ProjectSettingNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload>
          }
          deleteMany: {
            args: Prisma.ProjectSettingNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectSettingNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectSettingNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload>[]
          }
          upsert: {
            args: Prisma.ProjectSettingNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingNotificationPayload>
          }
          aggregate: {
            args: Prisma.ProjectSettingNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectSettingNotification>
          }
          groupBy: {
            args: Prisma.ProjectSettingNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectSettingNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectSettingNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectSettingNotificationCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskStatus: {
        payload: Prisma.$TaskStatusPayload<ExtArgs>
        fields: Prisma.TaskStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          findFirst: {
            args: Prisma.TaskStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          findMany: {
            args: Prisma.TaskStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>[]
          }
          create: {
            args: Prisma.TaskStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          createMany: {
            args: Prisma.TaskStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>[]
          }
          delete: {
            args: Prisma.TaskStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          update: {
            args: Prisma.TaskStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          deleteMany: {
            args: Prisma.TaskStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>[]
          }
          upsert: {
            args: Prisma.TaskStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          aggregate: {
            args: Prisma.TaskStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskStatus>
          }
          groupBy: {
            args: Prisma.TaskStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskStatusCountArgs<ExtArgs>
            result: $Utils.Optional<TaskStatusCountAggregateOutputType> | number
          }
        }
      }
      TaskAssignee: {
        payload: Prisma.$TaskAssigneePayload<ExtArgs>
        fields: Prisma.TaskAssigneeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAssigneeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          findFirst: {
            args: Prisma.TaskAssigneeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAssigneeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          findMany: {
            args: Prisma.TaskAssigneeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          create: {
            args: Prisma.TaskAssigneeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          createMany: {
            args: Prisma.TaskAssigneeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAssigneeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          delete: {
            args: Prisma.TaskAssigneeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          update: {
            args: Prisma.TaskAssigneeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          deleteMany: {
            args: Prisma.TaskAssigneeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAssigneeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskAssigneeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          upsert: {
            args: Prisma.TaskAssigneeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          aggregate: {
            args: Prisma.TaskAssigneeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAssignee>
          }
          groupBy: {
            args: Prisma.TaskAssigneeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAssigneeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAssigneeCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAssigneeCountAggregateOutputType> | number
          }
        }
      }
      TaskChecklist: {
        payload: Prisma.$TaskChecklistPayload<ExtArgs>
        fields: Prisma.TaskChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload>
          }
          findFirst: {
            args: Prisma.TaskChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload>
          }
          findMany: {
            args: Prisma.TaskChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload>[]
          }
          create: {
            args: Prisma.TaskChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload>
          }
          createMany: {
            args: Prisma.TaskChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload>[]
          }
          delete: {
            args: Prisma.TaskChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload>
          }
          update: {
            args: Prisma.TaskChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload>
          }
          deleteMany: {
            args: Prisma.TaskChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskChecklistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload>[]
          }
          upsert: {
            args: Prisma.TaskChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskChecklistPayload>
          }
          aggregate: {
            args: Prisma.TaskChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskChecklist>
          }
          groupBy: {
            args: Prisma.TaskChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<TaskChecklistCountAggregateOutputType> | number
          }
        }
      }
      TaskPoint: {
        payload: Prisma.$TaskPointPayload<ExtArgs>
        fields: Prisma.TaskPointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskPointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskPointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload>
          }
          findFirst: {
            args: Prisma.TaskPointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskPointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload>
          }
          findMany: {
            args: Prisma.TaskPointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload>[]
          }
          create: {
            args: Prisma.TaskPointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload>
          }
          createMany: {
            args: Prisma.TaskPointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskPointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload>[]
          }
          delete: {
            args: Prisma.TaskPointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload>
          }
          update: {
            args: Prisma.TaskPointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload>
          }
          deleteMany: {
            args: Prisma.TaskPointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskPointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskPointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload>[]
          }
          upsert: {
            args: Prisma.TaskPointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPointPayload>
          }
          aggregate: {
            args: Prisma.TaskPointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskPoint>
          }
          groupBy: {
            args: Prisma.TaskPointGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskPointGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskPointCountArgs<ExtArgs>
            result: $Utils.Optional<TaskPointCountAggregateOutputType> | number
          }
        }
      }
      TaskAutomation: {
        payload: Prisma.$TaskAutomationPayload<ExtArgs>
        fields: Prisma.TaskAutomationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAutomationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAutomationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload>
          }
          findFirst: {
            args: Prisma.TaskAutomationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAutomationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload>
          }
          findMany: {
            args: Prisma.TaskAutomationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload>[]
          }
          create: {
            args: Prisma.TaskAutomationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload>
          }
          createMany: {
            args: Prisma.TaskAutomationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAutomationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload>[]
          }
          delete: {
            args: Prisma.TaskAutomationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload>
          }
          update: {
            args: Prisma.TaskAutomationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload>
          }
          deleteMany: {
            args: Prisma.TaskAutomationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAutomationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskAutomationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload>[]
          }
          upsert: {
            args: Prisma.TaskAutomationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAutomationPayload>
          }
          aggregate: {
            args: Prisma.TaskAutomationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAutomation>
          }
          groupBy: {
            args: Prisma.TaskAutomationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAutomationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAutomationCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAutomationCountAggregateOutputType> | number
          }
        }
      }
      Vision: {
        payload: Prisma.$VisionPayload<ExtArgs>
        fields: Prisma.VisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload>
          }
          findFirst: {
            args: Prisma.VisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload>
          }
          findMany: {
            args: Prisma.VisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload>[]
          }
          create: {
            args: Prisma.VisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload>
          }
          createMany: {
            args: Prisma.VisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload>[]
          }
          delete: {
            args: Prisma.VisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload>
          }
          update: {
            args: Prisma.VisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload>
          }
          deleteMany: {
            args: Prisma.VisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload>[]
          }
          upsert: {
            args: Prisma.VisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionPayload>
          }
          aggregate: {
            args: Prisma.VisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVision>
          }
          groupBy: {
            args: Prisma.VisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisionCountArgs<ExtArgs>
            result: $Utils.Optional<VisionCountAggregateOutputType> | number
          }
        }
      }
      Field: {
        payload: Prisma.$FieldPayload<ExtArgs>
        fields: Prisma.FieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          findFirst: {
            args: Prisma.FieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          findMany: {
            args: Prisma.FieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>[]
          }
          create: {
            args: Prisma.FieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          createMany: {
            args: Prisma.FieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>[]
          }
          delete: {
            args: Prisma.FieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          update: {
            args: Prisma.FieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          deleteMany: {
            args: Prisma.FieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>[]
          }
          upsert: {
            args: Prisma.FieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          aggregate: {
            args: Prisma.FieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateField>
          }
          groupBy: {
            args: Prisma.FieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.FieldCountArgs<ExtArgs>
            result: $Utils.Optional<FieldCountAggregateOutputType> | number
          }
        }
      }
      Grid: {
        payload: Prisma.$GridPayload<ExtArgs>
        fields: Prisma.GridFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GridFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GridFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload>
          }
          findFirst: {
            args: Prisma.GridFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GridFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload>
          }
          findMany: {
            args: Prisma.GridFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload>[]
          }
          create: {
            args: Prisma.GridCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload>
          }
          createMany: {
            args: Prisma.GridCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GridCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload>[]
          }
          delete: {
            args: Prisma.GridDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload>
          }
          update: {
            args: Prisma.GridUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload>
          }
          deleteMany: {
            args: Prisma.GridDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GridUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GridUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload>[]
          }
          upsert: {
            args: Prisma.GridUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GridPayload>
          }
          aggregate: {
            args: Prisma.GridAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrid>
          }
          groupBy: {
            args: Prisma.GridGroupByArgs<ExtArgs>
            result: $Utils.Optional<GridGroupByOutputType>[]
          }
          count: {
            args: Prisma.GridCountArgs<ExtArgs>
            result: $Utils.Optional<GridCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TaskTag: {
        payload: Prisma.$TaskTagPayload<ExtArgs>
        fields: Prisma.TaskTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          findFirst: {
            args: Prisma.TaskTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          findMany: {
            args: Prisma.TaskTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>[]
          }
          create: {
            args: Prisma.TaskTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          createMany: {
            args: Prisma.TaskTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>[]
          }
          delete: {
            args: Prisma.TaskTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          update: {
            args: Prisma.TaskTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          deleteMany: {
            args: Prisma.TaskTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>[]
          }
          upsert: {
            args: Prisma.TaskTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          aggregate: {
            args: Prisma.TaskTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskTag>
          }
          groupBy: {
            args: Prisma.TaskTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskTagCountArgs<ExtArgs>
            result: $Utils.Optional<TaskTagCountAggregateOutputType> | number
          }
        }
      }
      Scheduler: {
        payload: Prisma.$SchedulerPayload<ExtArgs>
        fields: Prisma.SchedulerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchedulerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchedulerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload>
          }
          findFirst: {
            args: Prisma.SchedulerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchedulerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload>
          }
          findMany: {
            args: Prisma.SchedulerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload>[]
          }
          create: {
            args: Prisma.SchedulerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload>
          }
          createMany: {
            args: Prisma.SchedulerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchedulerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload>[]
          }
          delete: {
            args: Prisma.SchedulerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload>
          }
          update: {
            args: Prisma.SchedulerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload>
          }
          deleteMany: {
            args: Prisma.SchedulerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchedulerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchedulerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload>[]
          }
          upsert: {
            args: Prisma.SchedulerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulerPayload>
          }
          aggregate: {
            args: Prisma.SchedulerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduler>
          }
          groupBy: {
            args: Prisma.SchedulerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchedulerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchedulerCountArgs<ExtArgs>
            result: $Utils.Optional<SchedulerCountAggregateOutputType> | number
          }
        }
      }
      FileStorage: {
        payload: Prisma.$FileStoragePayload<ExtArgs>
        fields: Prisma.FileStorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileStorageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileStorageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          findFirst: {
            args: Prisma.FileStorageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileStorageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          findMany: {
            args: Prisma.FileStorageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>[]
          }
          create: {
            args: Prisma.FileStorageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          createMany: {
            args: Prisma.FileStorageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileStorageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>[]
          }
          delete: {
            args: Prisma.FileStorageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          update: {
            args: Prisma.FileStorageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          deleteMany: {
            args: Prisma.FileStorageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileStorageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileStorageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>[]
          }
          upsert: {
            args: Prisma.FileStorageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileStoragePayload>
          }
          aggregate: {
            args: Prisma.FileStorageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileStorage>
          }
          groupBy: {
            args: Prisma.FileStorageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileStorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileStorageCountArgs<ExtArgs>
            result: $Utils.Optional<FileStorageCountAggregateOutputType> | number
          }
        }
      }
      Stat: {
        payload: Prisma.$StatPayload<ExtArgs>
        fields: Prisma.StatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          findFirst: {
            args: Prisma.StatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          findMany: {
            args: Prisma.StatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>[]
          }
          create: {
            args: Prisma.StatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          createMany: {
            args: Prisma.StatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>[]
          }
          delete: {
            args: Prisma.StatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          update: {
            args: Prisma.StatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          deleteMany: {
            args: Prisma.StatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>[]
          }
          upsert: {
            args: Prisma.StatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          aggregate: {
            args: Prisma.StatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStat>
          }
          groupBy: {
            args: Prisma.StatGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatCountArgs<ExtArgs>
            result: $Utils.Optional<StatCountAggregateOutputType> | number
          }
        }
      }
      Dashboard: {
        payload: Prisma.$DashboardPayload<ExtArgs>
        fields: Prisma.DashboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          findFirst: {
            args: Prisma.DashboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          findMany: {
            args: Prisma.DashboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          create: {
            args: Prisma.DashboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          createMany: {
            args: Prisma.DashboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          delete: {
            args: Prisma.DashboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          update: {
            args: Prisma.DashboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          deleteMany: {
            args: Prisma.DashboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          upsert: {
            args: Prisma.DashboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          aggregate: {
            args: Prisma.DashboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboard>
          }
          groupBy: {
            args: Prisma.DashboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardCountAggregateOutputType> | number
          }
        }
      }
      DashboardComponent: {
        payload: Prisma.$DashboardComponentPayload<ExtArgs>
        fields: Prisma.DashboardComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload>
          }
          findFirst: {
            args: Prisma.DashboardComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload>
          }
          findMany: {
            args: Prisma.DashboardComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload>[]
          }
          create: {
            args: Prisma.DashboardComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload>
          }
          createMany: {
            args: Prisma.DashboardComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload>[]
          }
          delete: {
            args: Prisma.DashboardComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload>
          }
          update: {
            args: Prisma.DashboardComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload>
          }
          deleteMany: {
            args: Prisma.DashboardComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardComponentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload>[]
          }
          upsert: {
            args: Prisma.DashboardComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardComponentPayload>
          }
          aggregate: {
            args: Prisma.DashboardComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardComponent>
          }
          groupBy: {
            args: Prisma.DashboardComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardComponentCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardComponentCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      Timer: {
        payload: Prisma.$TimerPayload<ExtArgs>
        fields: Prisma.TimerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload>
          }
          findFirst: {
            args: Prisma.TimerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload>
          }
          findMany: {
            args: Prisma.TimerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload>[]
          }
          create: {
            args: Prisma.TimerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload>
          }
          createMany: {
            args: Prisma.TimerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload>[]
          }
          delete: {
            args: Prisma.TimerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload>
          }
          update: {
            args: Prisma.TimerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload>
          }
          deleteMany: {
            args: Prisma.TimerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload>[]
          }
          upsert: {
            args: Prisma.TimerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimerPayload>
          }
          aggregate: {
            args: Prisma.TimerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimer>
          }
          groupBy: {
            args: Prisma.TimerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimerCountArgs<ExtArgs>
            result: $Utils.Optional<TimerCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    organization?: OrganizationOmit
    organizationMember?: OrganizationMemberOmit
    organizationStorage?: OrganizationStorageOmit
    member?: MemberOmit
    project?: ProjectOmit
    projectView?: ProjectViewOmit
    projectSettingNotification?: ProjectSettingNotificationOmit
    task?: TaskOmit
    taskStatus?: TaskStatusOmit
    taskAssignee?: TaskAssigneeOmit
    taskChecklist?: TaskChecklistOmit
    taskPoint?: TaskPointOmit
    taskAutomation?: TaskAutomationOmit
    vision?: VisionOmit
    field?: FieldOmit
    grid?: GridOmit
    tag?: TagOmit
    taskTag?: TaskTagOmit
    scheduler?: SchedulerOmit
    fileStorage?: FileStorageOmit
    stat?: StatOmit
    dashboard?: DashboardOmit
    dashboardComponent?: DashboardComponentOmit
    activity?: ActivityOmit
    comment?: CommentOmit
    application?: ApplicationOmit
    timer?: TimerOmit
    favorite?: FavoriteOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    members: number
    organizationMembers: number
    taskAssignees: number
    projectSettingNotifications: number
    stats: number
    timers: number
    favorites: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | UserCountOutputTypeCountMembersArgs
    organizationMembers?: boolean | UserCountOutputTypeCountOrganizationMembersArgs
    taskAssignees?: boolean | UserCountOutputTypeCountTaskAssigneesArgs
    projectSettingNotifications?: boolean | UserCountOutputTypeCountProjectSettingNotificationsArgs
    stats?: boolean | UserCountOutputTypeCountStatsArgs
    timers?: boolean | UserCountOutputTypeCountTimersArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizationMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectSettingNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    projects: number
    visions: number
    organizationMembers: number
    taskAutomations: number
    schedulers: number
    fileStorages: number
    stats: number
    applications: number
    favorites: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | OrganizationCountOutputTypeCountProjectsArgs
    visions?: boolean | OrganizationCountOutputTypeCountVisionsArgs
    organizationMembers?: boolean | OrganizationCountOutputTypeCountOrganizationMembersArgs
    taskAutomations?: boolean | OrganizationCountOutputTypeCountTaskAutomationsArgs
    schedulers?: boolean | OrganizationCountOutputTypeCountSchedulersArgs
    fileStorages?: boolean | OrganizationCountOutputTypeCountFileStoragesArgs
    stats?: boolean | OrganizationCountOutputTypeCountStatsArgs
    applications?: boolean | OrganizationCountOutputTypeCountApplicationsArgs
    favorites?: boolean | OrganizationCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountVisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisionWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOrganizationMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTaskAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAutomationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSchedulersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchedulerWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountFileStoragesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileStorageWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    field: number
    vision: number
    projectSettingNotifications: number
    members: number
    grid: number
    taskStatuses: number
    taskPoints: number
    tasks: number
    tags: number
    taskAutomations: number
    schedulers: number
    fileStorages: number
    stats: number
    comments: number
    dashboard: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | ProjectCountOutputTypeCountFieldArgs
    vision?: boolean | ProjectCountOutputTypeCountVisionArgs
    projectSettingNotifications?: boolean | ProjectCountOutputTypeCountProjectSettingNotificationsArgs
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    grid?: boolean | ProjectCountOutputTypeCountGridArgs
    taskStatuses?: boolean | ProjectCountOutputTypeCountTaskStatusesArgs
    taskPoints?: boolean | ProjectCountOutputTypeCountTaskPointsArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
    tags?: boolean | ProjectCountOutputTypeCountTagsArgs
    taskAutomations?: boolean | ProjectCountOutputTypeCountTaskAutomationsArgs
    schedulers?: boolean | ProjectCountOutputTypeCountSchedulersArgs
    fileStorages?: boolean | ProjectCountOutputTypeCountFileStoragesArgs
    stats?: boolean | ProjectCountOutputTypeCountStatsArgs
    comments?: boolean | ProjectCountOutputTypeCountCommentsArgs
    dashboard?: boolean | ProjectCountOutputTypeCountDashboardArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountVisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectSettingNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingNotificationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountGridArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GridWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTaskStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskStatusWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTaskPointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskPointWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTaskAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAutomationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSchedulersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchedulerWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountFileStoragesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileStorageWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDashboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    taskChecklists: number
    comments: number
    timers: number
    taskTags: number
    taskAssignees: number
    fileStorages: number
    subTasks: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskChecklists?: boolean | TaskCountOutputTypeCountTaskChecklistsArgs
    comments?: boolean | TaskCountOutputTypeCountCommentsArgs
    timers?: boolean | TaskCountOutputTypeCountTimersArgs
    taskTags?: boolean | TaskCountOutputTypeCountTaskTagsArgs
    taskAssignees?: boolean | TaskCountOutputTypeCountTaskAssigneesArgs
    fileStorages?: boolean | TaskCountOutputTypeCountFileStoragesArgs
    subTasks?: boolean | TaskCountOutputTypeCountSubTasksArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTaskChecklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskChecklistWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTimersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimerWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTaskTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTagWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTaskAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountFileStoragesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileStorageWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountSubTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskStatusCountOutputType
   */

  export type TaskStatusCountOutputType = {
    tasks: number
  }

  export type TaskStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TaskStatusCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * TaskStatusCountOutputType without action
   */
  export type TaskStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatusCountOutputType
     */
    select?: TaskStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskStatusCountOutputType without action
   */
  export type TaskStatusCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type VisionCountOutputType
   */

  export type VisionCountOutputType = {
    children: number
  }

  export type VisionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | VisionCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * VisionCountOutputType without action
   */
  export type VisionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionCountOutputType
     */
    select?: VisionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisionCountOutputType without action
   */
  export type VisionCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisionWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    taskTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskTags?: boolean | TagCountOutputTypeCountTaskTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTaskTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTagWhereInput
  }


  /**
   * Count Type DashboardCountOutputType
   */

  export type DashboardCountOutputType = {
    dashboardComponents: number
  }

  export type DashboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboardComponents?: boolean | DashboardCountOutputTypeCountDashboardComponentsArgs
  }

  // Custom InputTypes
  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardCountOutputType
     */
    select?: DashboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeCountDashboardComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardComponentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    status: $Enums.UserStatus | null
    country: string | null
    bio: string | null
    photo: string | null
    dob: Date | null
    resetToken: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    status: $Enums.UserStatus | null
    country: string | null
    bio: string | null
    photo: string | null
    dob: Date | null
    resetToken: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    status: number
    country: number
    bio: number
    photo: number
    dob: number
    resetToken: number
    settings: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    status?: true
    country?: true
    bio?: true
    photo?: true
    dob?: true
    resetToken?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    status?: true
    country?: true
    bio?: true
    photo?: true
    dob?: true
    resetToken?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    status?: true
    country?: true
    bio?: true
    photo?: true
    dob?: true
    resetToken?: true
    settings?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string | null
    status: $Enums.UserStatus | null
    country: string | null
    bio: string | null
    photo: string | null
    dob: Date | null
    resetToken: string | null
    settings: JsonValue | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    status?: boolean
    country?: boolean
    bio?: boolean
    photo?: boolean
    dob?: boolean
    resetToken?: boolean
    settings?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    members?: boolean | User$membersArgs<ExtArgs>
    organizationMembers?: boolean | User$organizationMembersArgs<ExtArgs>
    taskAssignees?: boolean | User$taskAssigneesArgs<ExtArgs>
    projectSettingNotifications?: boolean | User$projectSettingNotificationsArgs<ExtArgs>
    stats?: boolean | User$statsArgs<ExtArgs>
    timers?: boolean | User$timersArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    status?: boolean
    country?: boolean
    bio?: boolean
    photo?: boolean
    dob?: boolean
    resetToken?: boolean
    settings?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    status?: boolean
    country?: boolean
    bio?: boolean
    photo?: boolean
    dob?: boolean
    resetToken?: boolean
    settings?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    status?: boolean
    country?: boolean
    bio?: boolean
    photo?: boolean
    dob?: boolean
    resetToken?: boolean
    settings?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "status" | "country" | "bio" | "photo" | "dob" | "resetToken" | "settings" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | User$membersArgs<ExtArgs>
    organizationMembers?: boolean | User$organizationMembersArgs<ExtArgs>
    taskAssignees?: boolean | User$taskAssigneesArgs<ExtArgs>
    projectSettingNotifications?: boolean | User$projectSettingNotificationsArgs<ExtArgs>
    stats?: boolean | User$statsArgs<ExtArgs>
    timers?: boolean | User$timersArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
      organizationMembers: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      taskAssignees: Prisma.$TaskAssigneePayload<ExtArgs>[]
      projectSettingNotifications: Prisma.$ProjectSettingNotificationPayload<ExtArgs>[]
      stats: Prisma.$StatPayload<ExtArgs>[]
      timers: Prisma.$TimerPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string | null
      status: $Enums.UserStatus | null
      country: string | null
      bio: string | null
      photo: string | null
      dob: Date | null
      resetToken: string | null
      settings: Prisma.JsonValue | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends User$membersArgs<ExtArgs> = {}>(args?: Subset<T, User$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizationMembers<T extends User$organizationMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskAssignees<T extends User$taskAssigneesArgs<ExtArgs> = {}>(args?: Subset<T, User$taskAssigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectSettingNotifications<T extends User$projectSettingNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectSettingNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stats<T extends User$statsArgs<ExtArgs> = {}>(args?: Subset<T, User$statsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timers<T extends User$timersArgs<ExtArgs> = {}>(args?: Subset<T, User$timersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly country: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly photo: FieldRef<"User", 'String'>
    readonly dob: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly settings: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly createdBy: FieldRef<"User", 'String'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly updatedBy: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.members
   */
  export type User$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * User.organizationMembers
   */
  export type User$organizationMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * User.taskAssignees
   */
  export type User$taskAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    cursor?: TaskAssigneeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * User.projectSettingNotifications
   */
  export type User$projectSettingNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    where?: ProjectSettingNotificationWhereInput
    orderBy?: ProjectSettingNotificationOrderByWithRelationInput | ProjectSettingNotificationOrderByWithRelationInput[]
    cursor?: ProjectSettingNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSettingNotificationScalarFieldEnum | ProjectSettingNotificationScalarFieldEnum[]
  }

  /**
   * User.stats
   */
  export type User$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    where?: StatWhereInput
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    cursor?: StatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * User.timers
   */
  export type User$timersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    where?: TimerWhereInput
    orderBy?: TimerOrderByWithRelationInput | TimerOrderByWithRelationInput[]
    cursor?: TimerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimerScalarFieldEnum | TimerScalarFieldEnum[]
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    maxStorageSize: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    maxStorageSize: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    cover: string | null
    avatar: string | null
    maxStorageSize: number | null
    desc: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    cover: string | null
    avatar: string | null
    maxStorageSize: number | null
    desc: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    cover: number
    avatar: number
    maxStorageSize: number
    desc: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    maxStorageSize?: true
  }

  export type OrganizationSumAggregateInputType = {
    maxStorageSize?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    cover?: true
    avatar?: true
    maxStorageSize?: true
    desc?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    cover?: true
    avatar?: true
    maxStorageSize?: true
    desc?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    cover?: true
    avatar?: true
    maxStorageSize?: true
    desc?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    cover: string | null
    avatar: string | null
    maxStorageSize: number | null
    desc: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string | null
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    cover?: boolean
    avatar?: boolean
    maxStorageSize?: boolean
    desc?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    visions?: boolean | Organization$visionsArgs<ExtArgs>
    organizationMembers?: boolean | Organization$organizationMembersArgs<ExtArgs>
    taskAutomations?: boolean | Organization$taskAutomationsArgs<ExtArgs>
    schedulers?: boolean | Organization$schedulersArgs<ExtArgs>
    fileStorages?: boolean | Organization$fileStoragesArgs<ExtArgs>
    stats?: boolean | Organization$statsArgs<ExtArgs>
    applications?: boolean | Organization$applicationsArgs<ExtArgs>
    favorites?: boolean | Organization$favoritesArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    cover?: boolean
    avatar?: boolean
    maxStorageSize?: boolean
    desc?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    cover?: boolean
    avatar?: boolean
    maxStorageSize?: boolean
    desc?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    cover?: boolean
    avatar?: boolean
    maxStorageSize?: boolean
    desc?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "cover" | "avatar" | "maxStorageSize" | "desc" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    visions?: boolean | Organization$visionsArgs<ExtArgs>
    organizationMembers?: boolean | Organization$organizationMembersArgs<ExtArgs>
    taskAutomations?: boolean | Organization$taskAutomationsArgs<ExtArgs>
    schedulers?: boolean | Organization$schedulersArgs<ExtArgs>
    fileStorages?: boolean | Organization$fileStoragesArgs<ExtArgs>
    stats?: boolean | Organization$statsArgs<ExtArgs>
    applications?: boolean | Organization$applicationsArgs<ExtArgs>
    favorites?: boolean | Organization$favoritesArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      visions: Prisma.$VisionPayload<ExtArgs>[]
      organizationMembers: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      taskAutomations: Prisma.$TaskAutomationPayload<ExtArgs>[]
      schedulers: Prisma.$SchedulerPayload<ExtArgs>[]
      fileStorages: Prisma.$FileStoragePayload<ExtArgs>[]
      stats: Prisma.$StatPayload<ExtArgs>[]
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      cover: string | null
      avatar: string | null
      maxStorageSize: number | null
      desc: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends Organization$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visions<T extends Organization$visionsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$visionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizationMembers<T extends Organization$organizationMembersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$organizationMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskAutomations<T extends Organization$taskAutomationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$taskAutomationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedulers<T extends Organization$schedulersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$schedulersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fileStorages<T extends Organization$fileStoragesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$fileStoragesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stats<T extends Organization$statsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$statsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applications<T extends Organization$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Organization$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly cover: FieldRef<"Organization", 'String'>
    readonly avatar: FieldRef<"Organization", 'String'>
    readonly maxStorageSize: FieldRef<"Organization", 'Int'>
    readonly desc: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly createdBy: FieldRef<"Organization", 'String'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedBy: FieldRef<"Organization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.projects
   */
  export type Organization$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Organization.visions
   */
  export type Organization$visionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    where?: VisionWhereInput
    orderBy?: VisionOrderByWithRelationInput | VisionOrderByWithRelationInput[]
    cursor?: VisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisionScalarFieldEnum | VisionScalarFieldEnum[]
  }

  /**
   * Organization.organizationMembers
   */
  export type Organization$organizationMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * Organization.taskAutomations
   */
  export type Organization$taskAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    where?: TaskAutomationWhereInput
    orderBy?: TaskAutomationOrderByWithRelationInput | TaskAutomationOrderByWithRelationInput[]
    cursor?: TaskAutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAutomationScalarFieldEnum | TaskAutomationScalarFieldEnum[]
  }

  /**
   * Organization.schedulers
   */
  export type Organization$schedulersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    where?: SchedulerWhereInput
    orderBy?: SchedulerOrderByWithRelationInput | SchedulerOrderByWithRelationInput[]
    cursor?: SchedulerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchedulerScalarFieldEnum | SchedulerScalarFieldEnum[]
  }

  /**
   * Organization.fileStorages
   */
  export type Organization$fileStoragesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    where?: FileStorageWhereInput
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    cursor?: FileStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * Organization.stats
   */
  export type Organization$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    where?: StatWhereInput
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    cursor?: StatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Organization.applications
   */
  export type Organization$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Organization.favorites
   */
  export type Organization$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationMember
   */

  export type AggregateOrganizationMember = {
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  export type OrganizationMemberMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    status: $Enums.InvitationStatus | null
    role: $Enums.OrganizationRole | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrganizationMemberMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    status: $Enums.InvitationStatus | null
    role: $Enums.OrganizationRole | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrganizationMemberCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    status: number
    role: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type OrganizationMemberMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    status?: true
    role?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrganizationMemberMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    status?: true
    role?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrganizationMemberCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    status?: true
    role?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type OrganizationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMember to aggregate.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationMembers
    **/
    _count?: true | OrganizationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type GetOrganizationMemberAggregateType<T extends OrganizationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationMember[P]>
      : GetScalarType<T[P], AggregateOrganizationMember[P]>
  }




  export type OrganizationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithAggregationInput | OrganizationMemberOrderByWithAggregationInput[]
    by: OrganizationMemberScalarFieldEnum[] | OrganizationMemberScalarFieldEnum
    having?: OrganizationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationMemberCountAggregateInputType | true
    _min?: OrganizationMemberMinAggregateInputType
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type OrganizationMemberGroupByOutputType = {
    id: string
    organizationId: string
    userId: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  type GetOrganizationMemberGroupByPayload<T extends OrganizationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    status?: boolean
    role?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    status?: boolean
    role?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    status?: boolean
    role?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    status?: boolean
    role?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type OrganizationMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "status" | "role" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["organizationMember"]>
  export type OrganizationMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationMember"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      userId: string
      status: $Enums.InvitationStatus
      role: $Enums.OrganizationRole
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["organizationMember"]>
    composites: {}
  }

  type OrganizationMemberGetPayload<S extends boolean | null | undefined | OrganizationMemberDefaultArgs> = $Result.GetResult<Prisma.$OrganizationMemberPayload, S>

  type OrganizationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationMemberCountAggregateInputType | true
    }

  export interface OrganizationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationMember'], meta: { name: 'OrganizationMember' } }
    /**
     * Find zero or one OrganizationMember that matches the filter.
     * @param {OrganizationMemberFindUniqueArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationMemberFindUniqueArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationMemberFindUniqueOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationMemberFindFirstArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany()
     * 
     * // Get first 10 OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationMemberFindManyArgs>(args?: SelectSubset<T, OrganizationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationMember.
     * @param {OrganizationMemberCreateArgs} args - Arguments to create a OrganizationMember.
     * @example
     * // Create one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.create({
     *   data: {
     *     // ... data to create a OrganizationMember
     *   }
     * })
     * 
     */
    create<T extends OrganizationMemberCreateArgs>(args: SelectSubset<T, OrganizationMemberCreateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationMembers.
     * @param {OrganizationMemberCreateManyArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationMemberCreateManyArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationMembers and returns the data saved in the database.
     * @param {OrganizationMemberCreateManyAndReturnArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationMember.
     * @param {OrganizationMemberDeleteArgs} args - Arguments to delete one OrganizationMember.
     * @example
     * // Delete one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.delete({
     *   where: {
     *     // ... filter to delete one OrganizationMember
     *   }
     * })
     * 
     */
    delete<T extends OrganizationMemberDeleteArgs>(args: SelectSubset<T, OrganizationMemberDeleteArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationMember.
     * @param {OrganizationMemberUpdateArgs} args - Arguments to update one OrganizationMember.
     * @example
     * // Update one OrganizationMember
     * const organizationMember = await prisma.organizationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationMemberUpdateArgs>(args: SelectSubset<T, OrganizationMemberUpdateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationMembers.
     * @param {OrganizationMemberDeleteManyArgs} args - Arguments to filter OrganizationMembers to delete.
     * @example
     * // Delete a few OrganizationMembers
     * const { count } = await prisma.organizationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationMemberDeleteManyArgs>(args?: SelectSubset<T, OrganizationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationMemberUpdateManyArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers and returns the data updated in the database.
     * @param {OrganizationMemberUpdateManyAndReturnArgs} args - Arguments to update many OrganizationMembers.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationMember.
     * @param {OrganizationMemberUpsertArgs} args - Arguments to update or create a OrganizationMember.
     * @example
     * // Update or create a OrganizationMember
     * const organizationMember = await prisma.organizationMember.upsert({
     *   create: {
     *     // ... data to create a OrganizationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationMember we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationMemberUpsertArgs>(args: SelectSubset<T, OrganizationMemberUpsertArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberCountArgs} args - Arguments to filter OrganizationMembers to count.
     * @example
     * // Count the number of OrganizationMembers
     * const count = await prisma.organizationMember.count({
     *   where: {
     *     // ... the filter for the OrganizationMembers we want to count
     *   }
     * })
    **/
    count<T extends OrganizationMemberCountArgs>(
      args?: Subset<T, OrganizationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationMemberAggregateArgs>(args: Subset<T, OrganizationMemberAggregateArgs>): Prisma.PrismaPromise<GetOrganizationMemberAggregateType<T>>

    /**
     * Group by OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationMemberGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationMember model
   */
  readonly fields: OrganizationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationMember model
   */
  interface OrganizationMemberFieldRefs {
    readonly id: FieldRef<"OrganizationMember", 'String'>
    readonly organizationId: FieldRef<"OrganizationMember", 'String'>
    readonly userId: FieldRef<"OrganizationMember", 'String'>
    readonly status: FieldRef<"OrganizationMember", 'InvitationStatus'>
    readonly role: FieldRef<"OrganizationMember", 'OrganizationRole'>
    readonly createdAt: FieldRef<"OrganizationMember", 'DateTime'>
    readonly createdBy: FieldRef<"OrganizationMember", 'String'>
    readonly updatedAt: FieldRef<"OrganizationMember", 'DateTime'>
    readonly updatedBy: FieldRef<"OrganizationMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationMember findUnique
   */
  export type OrganizationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findUniqueOrThrow
   */
  export type OrganizationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findFirst
   */
  export type OrganizationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findFirstOrThrow
   */
  export type OrganizationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findMany
   */
  export type OrganizationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembers to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember create
   */
  export type OrganizationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationMember.
     */
    data: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
  }

  /**
   * OrganizationMember createMany
   */
  export type OrganizationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationMember createManyAndReturn
   */
  export type OrganizationMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember update
   */
  export type OrganizationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationMember.
     */
    data: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
    /**
     * Choose, which OrganizationMember to update.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember updateMany
   */
  export type OrganizationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
  }

  /**
   * OrganizationMember updateManyAndReturn
   */
  export type OrganizationMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember upsert
   */
  export type OrganizationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationMember to update in case it exists.
     */
    where: OrganizationMemberWhereUniqueInput
    /**
     * In case the OrganizationMember found by the `where` argument doesn't exist, create a new OrganizationMember with this data.
     */
    create: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
    /**
     * In case the OrganizationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
  }

  /**
   * OrganizationMember delete
   */
  export type OrganizationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter which OrganizationMember to delete.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember deleteMany
   */
  export type OrganizationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMembers to delete
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to delete.
     */
    limit?: number
  }

  /**
   * OrganizationMember without action
   */
  export type OrganizationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationStorage
   */

  export type AggregateOrganizationStorage = {
    _count: OrganizationStorageCountAggregateOutputType | null
    _min: OrganizationStorageMinAggregateOutputType | null
    _max: OrganizationStorageMaxAggregateOutputType | null
  }

  export type OrganizationStorageMinAggregateOutputType = {
    id: string | null
    type: $Enums.OrgStorageType | null
    organizationId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrganizationStorageMaxAggregateOutputType = {
    id: string | null
    type: $Enums.OrgStorageType | null
    organizationId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrganizationStorageCountAggregateOutputType = {
    id: number
    type: number
    config: number
    organizationId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type OrganizationStorageMinAggregateInputType = {
    id?: true
    type?: true
    organizationId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrganizationStorageMaxAggregateInputType = {
    id?: true
    type?: true
    organizationId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrganizationStorageCountAggregateInputType = {
    id?: true
    type?: true
    config?: true
    organizationId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type OrganizationStorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationStorage to aggregate.
     */
    where?: OrganizationStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationStorages to fetch.
     */
    orderBy?: OrganizationStorageOrderByWithRelationInput | OrganizationStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationStorages
    **/
    _count?: true | OrganizationStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationStorageMaxAggregateInputType
  }

  export type GetOrganizationStorageAggregateType<T extends OrganizationStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationStorage[P]>
      : GetScalarType<T[P], AggregateOrganizationStorage[P]>
  }




  export type OrganizationStorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationStorageWhereInput
    orderBy?: OrganizationStorageOrderByWithAggregationInput | OrganizationStorageOrderByWithAggregationInput[]
    by: OrganizationStorageScalarFieldEnum[] | OrganizationStorageScalarFieldEnum
    having?: OrganizationStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationStorageCountAggregateInputType | true
    _min?: OrganizationStorageMinAggregateInputType
    _max?: OrganizationStorageMaxAggregateInputType
  }

  export type OrganizationStorageGroupByOutputType = {
    id: string
    type: $Enums.OrgStorageType
    config: JsonValue
    organizationId: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: OrganizationStorageCountAggregateOutputType | null
    _min: OrganizationStorageMinAggregateOutputType | null
    _max: OrganizationStorageMaxAggregateOutputType | null
  }

  type GetOrganizationStorageGroupByPayload<T extends OrganizationStorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationStorageGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationStorageGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationStorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    config?: boolean
    organizationId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["organizationStorage"]>

  export type OrganizationStorageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    config?: boolean
    organizationId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["organizationStorage"]>

  export type OrganizationStorageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    config?: boolean
    organizationId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["organizationStorage"]>

  export type OrganizationStorageSelectScalar = {
    id?: boolean
    type?: boolean
    config?: boolean
    organizationId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type OrganizationStorageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "config" | "organizationId" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["organizationStorage"]>

  export type $OrganizationStoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationStorage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.OrgStorageType
      config: Prisma.JsonValue
      organizationId: string
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["organizationStorage"]>
    composites: {}
  }

  type OrganizationStorageGetPayload<S extends boolean | null | undefined | OrganizationStorageDefaultArgs> = $Result.GetResult<Prisma.$OrganizationStoragePayload, S>

  type OrganizationStorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationStorageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationStorageCountAggregateInputType | true
    }

  export interface OrganizationStorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationStorage'], meta: { name: 'OrganizationStorage' } }
    /**
     * Find zero or one OrganizationStorage that matches the filter.
     * @param {OrganizationStorageFindUniqueArgs} args - Arguments to find a OrganizationStorage
     * @example
     * // Get one OrganizationStorage
     * const organizationStorage = await prisma.organizationStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationStorageFindUniqueArgs>(args: SelectSubset<T, OrganizationStorageFindUniqueArgs<ExtArgs>>): Prisma__OrganizationStorageClient<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationStorage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationStorageFindUniqueOrThrowArgs} args - Arguments to find a OrganizationStorage
     * @example
     * // Get one OrganizationStorage
     * const organizationStorage = await prisma.organizationStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationStorageFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationStorageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationStorageClient<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationStorageFindFirstArgs} args - Arguments to find a OrganizationStorage
     * @example
     * // Get one OrganizationStorage
     * const organizationStorage = await prisma.organizationStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationStorageFindFirstArgs>(args?: SelectSubset<T, OrganizationStorageFindFirstArgs<ExtArgs>>): Prisma__OrganizationStorageClient<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationStorage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationStorageFindFirstOrThrowArgs} args - Arguments to find a OrganizationStorage
     * @example
     * // Get one OrganizationStorage
     * const organizationStorage = await prisma.organizationStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationStorageFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationStorageFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationStorageClient<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationStorageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationStorages
     * const organizationStorages = await prisma.organizationStorage.findMany()
     * 
     * // Get first 10 OrganizationStorages
     * const organizationStorages = await prisma.organizationStorage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationStorageWithIdOnly = await prisma.organizationStorage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationStorageFindManyArgs>(args?: SelectSubset<T, OrganizationStorageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationStorage.
     * @param {OrganizationStorageCreateArgs} args - Arguments to create a OrganizationStorage.
     * @example
     * // Create one OrganizationStorage
     * const OrganizationStorage = await prisma.organizationStorage.create({
     *   data: {
     *     // ... data to create a OrganizationStorage
     *   }
     * })
     * 
     */
    create<T extends OrganizationStorageCreateArgs>(args: SelectSubset<T, OrganizationStorageCreateArgs<ExtArgs>>): Prisma__OrganizationStorageClient<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationStorages.
     * @param {OrganizationStorageCreateManyArgs} args - Arguments to create many OrganizationStorages.
     * @example
     * // Create many OrganizationStorages
     * const organizationStorage = await prisma.organizationStorage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationStorageCreateManyArgs>(args?: SelectSubset<T, OrganizationStorageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationStorages and returns the data saved in the database.
     * @param {OrganizationStorageCreateManyAndReturnArgs} args - Arguments to create many OrganizationStorages.
     * @example
     * // Create many OrganizationStorages
     * const organizationStorage = await prisma.organizationStorage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationStorages and only return the `id`
     * const organizationStorageWithIdOnly = await prisma.organizationStorage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationStorageCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationStorageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationStorage.
     * @param {OrganizationStorageDeleteArgs} args - Arguments to delete one OrganizationStorage.
     * @example
     * // Delete one OrganizationStorage
     * const OrganizationStorage = await prisma.organizationStorage.delete({
     *   where: {
     *     // ... filter to delete one OrganizationStorage
     *   }
     * })
     * 
     */
    delete<T extends OrganizationStorageDeleteArgs>(args: SelectSubset<T, OrganizationStorageDeleteArgs<ExtArgs>>): Prisma__OrganizationStorageClient<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationStorage.
     * @param {OrganizationStorageUpdateArgs} args - Arguments to update one OrganizationStorage.
     * @example
     * // Update one OrganizationStorage
     * const organizationStorage = await prisma.organizationStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationStorageUpdateArgs>(args: SelectSubset<T, OrganizationStorageUpdateArgs<ExtArgs>>): Prisma__OrganizationStorageClient<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationStorages.
     * @param {OrganizationStorageDeleteManyArgs} args - Arguments to filter OrganizationStorages to delete.
     * @example
     * // Delete a few OrganizationStorages
     * const { count } = await prisma.organizationStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationStorageDeleteManyArgs>(args?: SelectSubset<T, OrganizationStorageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationStorages
     * const organizationStorage = await prisma.organizationStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationStorageUpdateManyArgs>(args: SelectSubset<T, OrganizationStorageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationStorages and returns the data updated in the database.
     * @param {OrganizationStorageUpdateManyAndReturnArgs} args - Arguments to update many OrganizationStorages.
     * @example
     * // Update many OrganizationStorages
     * const organizationStorage = await prisma.organizationStorage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationStorages and only return the `id`
     * const organizationStorageWithIdOnly = await prisma.organizationStorage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationStorageUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationStorageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationStorage.
     * @param {OrganizationStorageUpsertArgs} args - Arguments to update or create a OrganizationStorage.
     * @example
     * // Update or create a OrganizationStorage
     * const organizationStorage = await prisma.organizationStorage.upsert({
     *   create: {
     *     // ... data to create a OrganizationStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationStorage we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationStorageUpsertArgs>(args: SelectSubset<T, OrganizationStorageUpsertArgs<ExtArgs>>): Prisma__OrganizationStorageClient<$Result.GetResult<Prisma.$OrganizationStoragePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationStorageCountArgs} args - Arguments to filter OrganizationStorages to count.
     * @example
     * // Count the number of OrganizationStorages
     * const count = await prisma.organizationStorage.count({
     *   where: {
     *     // ... the filter for the OrganizationStorages we want to count
     *   }
     * })
    **/
    count<T extends OrganizationStorageCountArgs>(
      args?: Subset<T, OrganizationStorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationStorageAggregateArgs>(args: Subset<T, OrganizationStorageAggregateArgs>): Prisma.PrismaPromise<GetOrganizationStorageAggregateType<T>>

    /**
     * Group by OrganizationStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationStorageGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationStorage model
   */
  readonly fields: OrganizationStorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationStorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationStorage model
   */
  interface OrganizationStorageFieldRefs {
    readonly id: FieldRef<"OrganizationStorage", 'String'>
    readonly type: FieldRef<"OrganizationStorage", 'OrgStorageType'>
    readonly config: FieldRef<"OrganizationStorage", 'Json'>
    readonly organizationId: FieldRef<"OrganizationStorage", 'String'>
    readonly createdAt: FieldRef<"OrganizationStorage", 'DateTime'>
    readonly createdBy: FieldRef<"OrganizationStorage", 'String'>
    readonly updatedAt: FieldRef<"OrganizationStorage", 'DateTime'>
    readonly updatedBy: FieldRef<"OrganizationStorage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationStorage findUnique
   */
  export type OrganizationStorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationStorage to fetch.
     */
    where: OrganizationStorageWhereUniqueInput
  }

  /**
   * OrganizationStorage findUniqueOrThrow
   */
  export type OrganizationStorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationStorage to fetch.
     */
    where: OrganizationStorageWhereUniqueInput
  }

  /**
   * OrganizationStorage findFirst
   */
  export type OrganizationStorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationStorage to fetch.
     */
    where?: OrganizationStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationStorages to fetch.
     */
    orderBy?: OrganizationStorageOrderByWithRelationInput | OrganizationStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationStorages.
     */
    cursor?: OrganizationStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationStorages.
     */
    distinct?: OrganizationStorageScalarFieldEnum | OrganizationStorageScalarFieldEnum[]
  }

  /**
   * OrganizationStorage findFirstOrThrow
   */
  export type OrganizationStorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationStorage to fetch.
     */
    where?: OrganizationStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationStorages to fetch.
     */
    orderBy?: OrganizationStorageOrderByWithRelationInput | OrganizationStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationStorages.
     */
    cursor?: OrganizationStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationStorages.
     */
    distinct?: OrganizationStorageScalarFieldEnum | OrganizationStorageScalarFieldEnum[]
  }

  /**
   * OrganizationStorage findMany
   */
  export type OrganizationStorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * Filter, which OrganizationStorages to fetch.
     */
    where?: OrganizationStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationStorages to fetch.
     */
    orderBy?: OrganizationStorageOrderByWithRelationInput | OrganizationStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationStorages.
     */
    cursor?: OrganizationStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationStorages.
     */
    skip?: number
    distinct?: OrganizationStorageScalarFieldEnum | OrganizationStorageScalarFieldEnum[]
  }

  /**
   * OrganizationStorage create
   */
  export type OrganizationStorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * The data needed to create a OrganizationStorage.
     */
    data: XOR<OrganizationStorageCreateInput, OrganizationStorageUncheckedCreateInput>
  }

  /**
   * OrganizationStorage createMany
   */
  export type OrganizationStorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationStorages.
     */
    data: OrganizationStorageCreateManyInput | OrganizationStorageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationStorage createManyAndReturn
   */
  export type OrganizationStorageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationStorages.
     */
    data: OrganizationStorageCreateManyInput | OrganizationStorageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationStorage update
   */
  export type OrganizationStorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * The data needed to update a OrganizationStorage.
     */
    data: XOR<OrganizationStorageUpdateInput, OrganizationStorageUncheckedUpdateInput>
    /**
     * Choose, which OrganizationStorage to update.
     */
    where: OrganizationStorageWhereUniqueInput
  }

  /**
   * OrganizationStorage updateMany
   */
  export type OrganizationStorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationStorages.
     */
    data: XOR<OrganizationStorageUpdateManyMutationInput, OrganizationStorageUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationStorages to update
     */
    where?: OrganizationStorageWhereInput
    /**
     * Limit how many OrganizationStorages to update.
     */
    limit?: number
  }

  /**
   * OrganizationStorage updateManyAndReturn
   */
  export type OrganizationStorageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationStorages.
     */
    data: XOR<OrganizationStorageUpdateManyMutationInput, OrganizationStorageUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationStorages to update
     */
    where?: OrganizationStorageWhereInput
    /**
     * Limit how many OrganizationStorages to update.
     */
    limit?: number
  }

  /**
   * OrganizationStorage upsert
   */
  export type OrganizationStorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * The filter to search for the OrganizationStorage to update in case it exists.
     */
    where: OrganizationStorageWhereUniqueInput
    /**
     * In case the OrganizationStorage found by the `where` argument doesn't exist, create a new OrganizationStorage with this data.
     */
    create: XOR<OrganizationStorageCreateInput, OrganizationStorageUncheckedCreateInput>
    /**
     * In case the OrganizationStorage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationStorageUpdateInput, OrganizationStorageUncheckedUpdateInput>
  }

  /**
   * OrganizationStorage delete
   */
  export type OrganizationStorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
    /**
     * Filter which OrganizationStorage to delete.
     */
    where: OrganizationStorageWhereUniqueInput
  }

  /**
   * OrganizationStorage deleteMany
   */
  export type OrganizationStorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationStorages to delete
     */
    where?: OrganizationStorageWhereInput
    /**
     * Limit how many OrganizationStorages to delete.
     */
    limit?: number
  }

  /**
   * OrganizationStorage without action
   */
  export type OrganizationStorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationStorage
     */
    select?: OrganizationStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationStorage
     */
    omit?: OrganizationStorageOmit<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    role: $Enums.MemberRole | null
    userId: string | null
    projectId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    role: $Enums.MemberRole | null
    userId: string | null
    projectId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    role: number
    userId: number
    projectId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    role?: true
    userId?: true
    projectId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    role?: true
    userId?: true
    projectId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    role?: true
    userId?: true
    projectId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    role: $Enums.MemberRole
    userId: string
    projectId: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    userId?: boolean
    projectId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    userId?: boolean
    projectId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    userId?: boolean
    projectId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    role?: boolean
    userId?: boolean
    projectId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "userId" | "projectId" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.MemberRole
      userId: string
      projectId: string
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly role: FieldRef<"Member", 'MemberRole'>
    readonly userId: FieldRef<"Member", 'String'>
    readonly projectId: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly createdBy: FieldRef<"Member", 'String'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
    readonly updatedBy: FieldRef<"Member", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    organizationId: string | null
    desc: string | null
    cover: string | null
    icon: string | null
    isArchived: boolean | null
    countMemberTask: boolean | null
    countProjectTask: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    organizationId: string | null
    desc: string | null
    cover: string | null
    icon: string | null
    isArchived: boolean | null
    countMemberTask: boolean | null
    countProjectTask: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    organizationId: number
    desc: number
    cover: number
    icon: number
    isArchived: number
    countMemberTask: number
    countProjectTask: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    organizationId?: true
    desc?: true
    cover?: true
    icon?: true
    isArchived?: true
    countMemberTask?: true
    countProjectTask?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    organizationId?: true
    desc?: true
    cover?: true
    icon?: true
    isArchived?: true
    countMemberTask?: true
    countProjectTask?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    organizationId?: true
    desc?: true
    cover?: true
    icon?: true
    isArchived?: true
    countMemberTask?: true
    countProjectTask?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    organizationId: string
    desc: string | null
    cover: string | null
    icon: string | null
    isArchived: boolean
    countMemberTask: boolean
    countProjectTask: boolean
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organizationId?: boolean
    desc?: boolean
    cover?: boolean
    icon?: boolean
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    projectView?: boolean | Project$projectViewArgs<ExtArgs>
    field?: boolean | Project$fieldArgs<ExtArgs>
    vision?: boolean | Project$visionArgs<ExtArgs>
    projectSettingNotifications?: boolean | Project$projectSettingNotificationsArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    grid?: boolean | Project$gridArgs<ExtArgs>
    taskStatuses?: boolean | Project$taskStatusesArgs<ExtArgs>
    taskPoints?: boolean | Project$taskPointsArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    tags?: boolean | Project$tagsArgs<ExtArgs>
    taskAutomations?: boolean | Project$taskAutomationsArgs<ExtArgs>
    schedulers?: boolean | Project$schedulersArgs<ExtArgs>
    fileStorages?: boolean | Project$fileStoragesArgs<ExtArgs>
    stats?: boolean | Project$statsArgs<ExtArgs>
    comments?: boolean | Project$commentsArgs<ExtArgs>
    dashboard?: boolean | Project$dashboardArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organizationId?: boolean
    desc?: boolean
    cover?: boolean
    icon?: boolean
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organizationId?: boolean
    desc?: boolean
    cover?: boolean
    icon?: boolean
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    organizationId?: boolean
    desc?: boolean
    cover?: boolean
    icon?: boolean
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "organizationId" | "desc" | "cover" | "icon" | "isArchived" | "countMemberTask" | "countProjectTask" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectView?: boolean | Project$projectViewArgs<ExtArgs>
    field?: boolean | Project$fieldArgs<ExtArgs>
    vision?: boolean | Project$visionArgs<ExtArgs>
    projectSettingNotifications?: boolean | Project$projectSettingNotificationsArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    grid?: boolean | Project$gridArgs<ExtArgs>
    taskStatuses?: boolean | Project$taskStatusesArgs<ExtArgs>
    taskPoints?: boolean | Project$taskPointsArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    tags?: boolean | Project$tagsArgs<ExtArgs>
    taskAutomations?: boolean | Project$taskAutomationsArgs<ExtArgs>
    schedulers?: boolean | Project$schedulersArgs<ExtArgs>
    fileStorages?: boolean | Project$fileStoragesArgs<ExtArgs>
    stats?: boolean | Project$statsArgs<ExtArgs>
    comments?: boolean | Project$commentsArgs<ExtArgs>
    dashboard?: boolean | Project$dashboardArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      projectView: Prisma.$ProjectViewPayload<ExtArgs> | null
      field: Prisma.$FieldPayload<ExtArgs>[]
      vision: Prisma.$VisionPayload<ExtArgs>[]
      projectSettingNotifications: Prisma.$ProjectSettingNotificationPayload<ExtArgs>[]
      members: Prisma.$MemberPayload<ExtArgs>[]
      grid: Prisma.$GridPayload<ExtArgs>[]
      taskStatuses: Prisma.$TaskStatusPayload<ExtArgs>[]
      taskPoints: Prisma.$TaskPointPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      taskAutomations: Prisma.$TaskAutomationPayload<ExtArgs>[]
      schedulers: Prisma.$SchedulerPayload<ExtArgs>[]
      fileStorages: Prisma.$FileStoragePayload<ExtArgs>[]
      stats: Prisma.$StatPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      dashboard: Prisma.$DashboardPayload<ExtArgs>[]
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      organizationId: string
      desc: string | null
      cover: string | null
      icon: string | null
      isArchived: boolean
      countMemberTask: boolean
      countProjectTask: boolean
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectView<T extends Project$projectViewArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectViewArgs<ExtArgs>>): Prisma__ProjectViewClient<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    field<T extends Project$fieldArgs<ExtArgs> = {}>(args?: Subset<T, Project$fieldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vision<T extends Project$visionArgs<ExtArgs> = {}>(args?: Subset<T, Project$visionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectSettingNotifications<T extends Project$projectSettingNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectSettingNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grid<T extends Project$gridArgs<ExtArgs> = {}>(args?: Subset<T, Project$gridArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskStatuses<T extends Project$taskStatusesArgs<ExtArgs> = {}>(args?: Subset<T, Project$taskStatusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskPoints<T extends Project$taskPointsArgs<ExtArgs> = {}>(args?: Subset<T, Project$taskPointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Project$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Project$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskAutomations<T extends Project$taskAutomationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$taskAutomationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedulers<T extends Project$schedulersArgs<ExtArgs> = {}>(args?: Subset<T, Project$schedulersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fileStorages<T extends Project$fileStoragesArgs<ExtArgs> = {}>(args?: Subset<T, Project$fileStoragesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stats<T extends Project$statsArgs<ExtArgs> = {}>(args?: Subset<T, Project$statsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Project$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dashboard<T extends Project$dashboardArgs<ExtArgs> = {}>(args?: Subset<T, Project$dashboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly organizationId: FieldRef<"Project", 'String'>
    readonly desc: FieldRef<"Project", 'String'>
    readonly cover: FieldRef<"Project", 'String'>
    readonly icon: FieldRef<"Project", 'String'>
    readonly isArchived: FieldRef<"Project", 'Boolean'>
    readonly countMemberTask: FieldRef<"Project", 'Boolean'>
    readonly countProjectTask: FieldRef<"Project", 'Boolean'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly createdBy: FieldRef<"Project", 'String'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly updatedBy: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.projectView
   */
  export type Project$projectViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    where?: ProjectViewWhereInput
  }

  /**
   * Project.field
   */
  export type Project$fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    cursor?: FieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Project.vision
   */
  export type Project$visionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    where?: VisionWhereInput
    orderBy?: VisionOrderByWithRelationInput | VisionOrderByWithRelationInput[]
    cursor?: VisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisionScalarFieldEnum | VisionScalarFieldEnum[]
  }

  /**
   * Project.projectSettingNotifications
   */
  export type Project$projectSettingNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    where?: ProjectSettingNotificationWhereInput
    orderBy?: ProjectSettingNotificationOrderByWithRelationInput | ProjectSettingNotificationOrderByWithRelationInput[]
    cursor?: ProjectSettingNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSettingNotificationScalarFieldEnum | ProjectSettingNotificationScalarFieldEnum[]
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Project.grid
   */
  export type Project$gridArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    where?: GridWhereInput
    orderBy?: GridOrderByWithRelationInput | GridOrderByWithRelationInput[]
    cursor?: GridWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GridScalarFieldEnum | GridScalarFieldEnum[]
  }

  /**
   * Project.taskStatuses
   */
  export type Project$taskStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    where?: TaskStatusWhereInput
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    cursor?: TaskStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * Project.taskPoints
   */
  export type Project$taskPointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    where?: TaskPointWhereInput
    orderBy?: TaskPointOrderByWithRelationInput | TaskPointOrderByWithRelationInput[]
    cursor?: TaskPointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskPointScalarFieldEnum | TaskPointScalarFieldEnum[]
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project.tags
   */
  export type Project$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Project.taskAutomations
   */
  export type Project$taskAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    where?: TaskAutomationWhereInput
    orderBy?: TaskAutomationOrderByWithRelationInput | TaskAutomationOrderByWithRelationInput[]
    cursor?: TaskAutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAutomationScalarFieldEnum | TaskAutomationScalarFieldEnum[]
  }

  /**
   * Project.schedulers
   */
  export type Project$schedulersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    where?: SchedulerWhereInput
    orderBy?: SchedulerOrderByWithRelationInput | SchedulerOrderByWithRelationInput[]
    cursor?: SchedulerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchedulerScalarFieldEnum | SchedulerScalarFieldEnum[]
  }

  /**
   * Project.fileStorages
   */
  export type Project$fileStoragesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    where?: FileStorageWhereInput
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    cursor?: FileStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * Project.stats
   */
  export type Project$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    where?: StatWhereInput
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    cursor?: StatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Project.comments
   */
  export type Project$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Project.dashboard
   */
  export type Project$dashboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    where?: DashboardWhereInput
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    cursor?: DashboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectView
   */

  export type AggregateProjectView = {
    _count: ProjectViewCountAggregateOutputType | null
    _avg: ProjectViewAvgAggregateOutputType | null
    _sum: ProjectViewSumAggregateOutputType | null
    _min: ProjectViewMinAggregateOutputType | null
    _max: ProjectViewMaxAggregateOutputType | null
  }

  export type ProjectViewAvgAggregateOutputType = {
    order: number | null
  }

  export type ProjectViewSumAggregateOutputType = {
    order: number | null
  }

  export type ProjectViewMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProjectViewType | null
    onlyMe: boolean | null
    icon: string | null
    projectId: string | null
    order: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProjectViewMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProjectViewType | null
    onlyMe: boolean | null
    icon: string | null
    projectId: string | null
    order: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProjectViewCountAggregateOutputType = {
    id: number
    name: number
    type: number
    onlyMe: number
    icon: number
    projectId: number
    order: number
    data: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ProjectViewAvgAggregateInputType = {
    order?: true
  }

  export type ProjectViewSumAggregateInputType = {
    order?: true
  }

  export type ProjectViewMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    onlyMe?: true
    icon?: true
    projectId?: true
    order?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProjectViewMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    onlyMe?: true
    icon?: true
    projectId?: true
    order?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProjectViewCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    onlyMe?: true
    icon?: true
    projectId?: true
    order?: true
    data?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ProjectViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectView to aggregate.
     */
    where?: ProjectViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectViews to fetch.
     */
    orderBy?: ProjectViewOrderByWithRelationInput | ProjectViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectViews
    **/
    _count?: true | ProjectViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectViewMaxAggregateInputType
  }

  export type GetProjectViewAggregateType<T extends ProjectViewAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectView[P]>
      : GetScalarType<T[P], AggregateProjectView[P]>
  }




  export type ProjectViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectViewWhereInput
    orderBy?: ProjectViewOrderByWithAggregationInput | ProjectViewOrderByWithAggregationInput[]
    by: ProjectViewScalarFieldEnum[] | ProjectViewScalarFieldEnum
    having?: ProjectViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectViewCountAggregateInputType | true
    _avg?: ProjectViewAvgAggregateInputType
    _sum?: ProjectViewSumAggregateInputType
    _min?: ProjectViewMinAggregateInputType
    _max?: ProjectViewMaxAggregateInputType
  }

  export type ProjectViewGroupByOutputType = {
    id: string
    name: string | null
    type: $Enums.ProjectViewType
    onlyMe: boolean
    icon: string | null
    projectId: string | null
    order: number | null
    data: JsonValue | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: ProjectViewCountAggregateOutputType | null
    _avg: ProjectViewAvgAggregateOutputType | null
    _sum: ProjectViewSumAggregateOutputType | null
    _min: ProjectViewMinAggregateOutputType | null
    _max: ProjectViewMaxAggregateOutputType | null
  }

  type GetProjectViewGroupByPayload<T extends ProjectViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectViewGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectViewGroupByOutputType[P]>
        }
      >
    >


  export type ProjectViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    onlyMe?: boolean
    icon?: boolean
    projectId?: boolean
    order?: boolean
    data?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectView$projectArgs<ExtArgs>
  }, ExtArgs["result"]["projectView"]>

  export type ProjectViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    onlyMe?: boolean
    icon?: boolean
    projectId?: boolean
    order?: boolean
    data?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectView$projectArgs<ExtArgs>
  }, ExtArgs["result"]["projectView"]>

  export type ProjectViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    onlyMe?: boolean
    icon?: boolean
    projectId?: boolean
    order?: boolean
    data?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectView$projectArgs<ExtArgs>
  }, ExtArgs["result"]["projectView"]>

  export type ProjectViewSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    onlyMe?: boolean
    icon?: boolean
    projectId?: boolean
    order?: boolean
    data?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ProjectViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "onlyMe" | "icon" | "projectId" | "order" | "data" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["projectView"]>
  export type ProjectViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectView$projectArgs<ExtArgs>
  }
  export type ProjectViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectView$projectArgs<ExtArgs>
  }
  export type ProjectViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectView$projectArgs<ExtArgs>
  }

  export type $ProjectViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectView"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      type: $Enums.ProjectViewType
      onlyMe: boolean
      icon: string | null
      projectId: string | null
      order: number | null
      data: Prisma.JsonValue | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["projectView"]>
    composites: {}
  }

  type ProjectViewGetPayload<S extends boolean | null | undefined | ProjectViewDefaultArgs> = $Result.GetResult<Prisma.$ProjectViewPayload, S>

  type ProjectViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectViewCountAggregateInputType | true
    }

  export interface ProjectViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectView'], meta: { name: 'ProjectView' } }
    /**
     * Find zero or one ProjectView that matches the filter.
     * @param {ProjectViewFindUniqueArgs} args - Arguments to find a ProjectView
     * @example
     * // Get one ProjectView
     * const projectView = await prisma.projectView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectViewFindUniqueArgs>(args: SelectSubset<T, ProjectViewFindUniqueArgs<ExtArgs>>): Prisma__ProjectViewClient<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectViewFindUniqueOrThrowArgs} args - Arguments to find a ProjectView
     * @example
     * // Get one ProjectView
     * const projectView = await prisma.projectView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectViewClient<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectViewFindFirstArgs} args - Arguments to find a ProjectView
     * @example
     * // Get one ProjectView
     * const projectView = await prisma.projectView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectViewFindFirstArgs>(args?: SelectSubset<T, ProjectViewFindFirstArgs<ExtArgs>>): Prisma__ProjectViewClient<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectViewFindFirstOrThrowArgs} args - Arguments to find a ProjectView
     * @example
     * // Get one ProjectView
     * const projectView = await prisma.projectView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectViewClient<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectViews
     * const projectViews = await prisma.projectView.findMany()
     * 
     * // Get first 10 ProjectViews
     * const projectViews = await prisma.projectView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectViewWithIdOnly = await prisma.projectView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectViewFindManyArgs>(args?: SelectSubset<T, ProjectViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectView.
     * @param {ProjectViewCreateArgs} args - Arguments to create a ProjectView.
     * @example
     * // Create one ProjectView
     * const ProjectView = await prisma.projectView.create({
     *   data: {
     *     // ... data to create a ProjectView
     *   }
     * })
     * 
     */
    create<T extends ProjectViewCreateArgs>(args: SelectSubset<T, ProjectViewCreateArgs<ExtArgs>>): Prisma__ProjectViewClient<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectViews.
     * @param {ProjectViewCreateManyArgs} args - Arguments to create many ProjectViews.
     * @example
     * // Create many ProjectViews
     * const projectView = await prisma.projectView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectViewCreateManyArgs>(args?: SelectSubset<T, ProjectViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectViews and returns the data saved in the database.
     * @param {ProjectViewCreateManyAndReturnArgs} args - Arguments to create many ProjectViews.
     * @example
     * // Create many ProjectViews
     * const projectView = await prisma.projectView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectViews and only return the `id`
     * const projectViewWithIdOnly = await prisma.projectView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectView.
     * @param {ProjectViewDeleteArgs} args - Arguments to delete one ProjectView.
     * @example
     * // Delete one ProjectView
     * const ProjectView = await prisma.projectView.delete({
     *   where: {
     *     // ... filter to delete one ProjectView
     *   }
     * })
     * 
     */
    delete<T extends ProjectViewDeleteArgs>(args: SelectSubset<T, ProjectViewDeleteArgs<ExtArgs>>): Prisma__ProjectViewClient<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectView.
     * @param {ProjectViewUpdateArgs} args - Arguments to update one ProjectView.
     * @example
     * // Update one ProjectView
     * const projectView = await prisma.projectView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectViewUpdateArgs>(args: SelectSubset<T, ProjectViewUpdateArgs<ExtArgs>>): Prisma__ProjectViewClient<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectViews.
     * @param {ProjectViewDeleteManyArgs} args - Arguments to filter ProjectViews to delete.
     * @example
     * // Delete a few ProjectViews
     * const { count } = await prisma.projectView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectViewDeleteManyArgs>(args?: SelectSubset<T, ProjectViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectViews
     * const projectView = await prisma.projectView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectViewUpdateManyArgs>(args: SelectSubset<T, ProjectViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectViews and returns the data updated in the database.
     * @param {ProjectViewUpdateManyAndReturnArgs} args - Arguments to update many ProjectViews.
     * @example
     * // Update many ProjectViews
     * const projectView = await prisma.projectView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectViews and only return the `id`
     * const projectViewWithIdOnly = await prisma.projectView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectViewUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectView.
     * @param {ProjectViewUpsertArgs} args - Arguments to update or create a ProjectView.
     * @example
     * // Update or create a ProjectView
     * const projectView = await prisma.projectView.upsert({
     *   create: {
     *     // ... data to create a ProjectView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectView we want to update
     *   }
     * })
     */
    upsert<T extends ProjectViewUpsertArgs>(args: SelectSubset<T, ProjectViewUpsertArgs<ExtArgs>>): Prisma__ProjectViewClient<$Result.GetResult<Prisma.$ProjectViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectViewCountArgs} args - Arguments to filter ProjectViews to count.
     * @example
     * // Count the number of ProjectViews
     * const count = await prisma.projectView.count({
     *   where: {
     *     // ... the filter for the ProjectViews we want to count
     *   }
     * })
    **/
    count<T extends ProjectViewCountArgs>(
      args?: Subset<T, ProjectViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectViewAggregateArgs>(args: Subset<T, ProjectViewAggregateArgs>): Prisma.PrismaPromise<GetProjectViewAggregateType<T>>

    /**
     * Group by ProjectView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectViewGroupByArgs['orderBy'] }
        : { orderBy?: ProjectViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectView model
   */
  readonly fields: ProjectViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectView$projectArgs<ExtArgs> = {}>(args?: Subset<T, ProjectView$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectView model
   */
  interface ProjectViewFieldRefs {
    readonly id: FieldRef<"ProjectView", 'String'>
    readonly name: FieldRef<"ProjectView", 'String'>
    readonly type: FieldRef<"ProjectView", 'ProjectViewType'>
    readonly onlyMe: FieldRef<"ProjectView", 'Boolean'>
    readonly icon: FieldRef<"ProjectView", 'String'>
    readonly projectId: FieldRef<"ProjectView", 'String'>
    readonly order: FieldRef<"ProjectView", 'Int'>
    readonly data: FieldRef<"ProjectView", 'Json'>
    readonly createdAt: FieldRef<"ProjectView", 'DateTime'>
    readonly createdBy: FieldRef<"ProjectView", 'String'>
    readonly updatedAt: FieldRef<"ProjectView", 'DateTime'>
    readonly updatedBy: FieldRef<"ProjectView", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectView findUnique
   */
  export type ProjectViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectView to fetch.
     */
    where: ProjectViewWhereUniqueInput
  }

  /**
   * ProjectView findUniqueOrThrow
   */
  export type ProjectViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectView to fetch.
     */
    where: ProjectViewWhereUniqueInput
  }

  /**
   * ProjectView findFirst
   */
  export type ProjectViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectView to fetch.
     */
    where?: ProjectViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectViews to fetch.
     */
    orderBy?: ProjectViewOrderByWithRelationInput | ProjectViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectViews.
     */
    cursor?: ProjectViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectViews.
     */
    distinct?: ProjectViewScalarFieldEnum | ProjectViewScalarFieldEnum[]
  }

  /**
   * ProjectView findFirstOrThrow
   */
  export type ProjectViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectView to fetch.
     */
    where?: ProjectViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectViews to fetch.
     */
    orderBy?: ProjectViewOrderByWithRelationInput | ProjectViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectViews.
     */
    cursor?: ProjectViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectViews.
     */
    distinct?: ProjectViewScalarFieldEnum | ProjectViewScalarFieldEnum[]
  }

  /**
   * ProjectView findMany
   */
  export type ProjectViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectViews to fetch.
     */
    where?: ProjectViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectViews to fetch.
     */
    orderBy?: ProjectViewOrderByWithRelationInput | ProjectViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectViews.
     */
    cursor?: ProjectViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectViews.
     */
    skip?: number
    distinct?: ProjectViewScalarFieldEnum | ProjectViewScalarFieldEnum[]
  }

  /**
   * ProjectView create
   */
  export type ProjectViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectView.
     */
    data: XOR<ProjectViewCreateInput, ProjectViewUncheckedCreateInput>
  }

  /**
   * ProjectView createMany
   */
  export type ProjectViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectViews.
     */
    data: ProjectViewCreateManyInput | ProjectViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectView createManyAndReturn
   */
  export type ProjectViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectViews.
     */
    data: ProjectViewCreateManyInput | ProjectViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectView update
   */
  export type ProjectViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectView.
     */
    data: XOR<ProjectViewUpdateInput, ProjectViewUncheckedUpdateInput>
    /**
     * Choose, which ProjectView to update.
     */
    where: ProjectViewWhereUniqueInput
  }

  /**
   * ProjectView updateMany
   */
  export type ProjectViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectViews.
     */
    data: XOR<ProjectViewUpdateManyMutationInput, ProjectViewUncheckedUpdateManyInput>
    /**
     * Filter which ProjectViews to update
     */
    where?: ProjectViewWhereInput
    /**
     * Limit how many ProjectViews to update.
     */
    limit?: number
  }

  /**
   * ProjectView updateManyAndReturn
   */
  export type ProjectViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * The data used to update ProjectViews.
     */
    data: XOR<ProjectViewUpdateManyMutationInput, ProjectViewUncheckedUpdateManyInput>
    /**
     * Filter which ProjectViews to update
     */
    where?: ProjectViewWhereInput
    /**
     * Limit how many ProjectViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectView upsert
   */
  export type ProjectViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectView to update in case it exists.
     */
    where: ProjectViewWhereUniqueInput
    /**
     * In case the ProjectView found by the `where` argument doesn't exist, create a new ProjectView with this data.
     */
    create: XOR<ProjectViewCreateInput, ProjectViewUncheckedCreateInput>
    /**
     * In case the ProjectView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectViewUpdateInput, ProjectViewUncheckedUpdateInput>
  }

  /**
   * ProjectView delete
   */
  export type ProjectViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
    /**
     * Filter which ProjectView to delete.
     */
    where: ProjectViewWhereUniqueInput
  }

  /**
   * ProjectView deleteMany
   */
  export type ProjectViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectViews to delete
     */
    where?: ProjectViewWhereInput
    /**
     * Limit how many ProjectViews to delete.
     */
    limit?: number
  }

  /**
   * ProjectView.project
   */
  export type ProjectView$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * ProjectView without action
   */
  export type ProjectViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectView
     */
    select?: ProjectViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectView
     */
    omit?: ProjectViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectViewInclude<ExtArgs> | null
  }


  /**
   * Model ProjectSettingNotification
   */

  export type AggregateProjectSettingNotification = {
    _count: ProjectSettingNotificationCountAggregateOutputType | null
    _min: ProjectSettingNotificationMinAggregateOutputType | null
    _max: ProjectSettingNotificationMaxAggregateOutputType | null
  }

  export type ProjectSettingNotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    taskChanges: boolean | null
    remind: boolean | null
    overdue: boolean | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type ProjectSettingNotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    taskChanges: boolean | null
    remind: boolean | null
    overdue: boolean | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type ProjectSettingNotificationCountAggregateOutputType = {
    id: number
    userId: number
    projectId: number
    taskChanges: number
    remind: number
    overdue: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type ProjectSettingNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    taskChanges?: true
    remind?: true
    overdue?: true
    createdAt?: true
    createdBy?: true
  }

  export type ProjectSettingNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    taskChanges?: true
    remind?: true
    overdue?: true
    createdAt?: true
    createdBy?: true
  }

  export type ProjectSettingNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    taskChanges?: true
    remind?: true
    overdue?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type ProjectSettingNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSettingNotification to aggregate.
     */
    where?: ProjectSettingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettingNotifications to fetch.
     */
    orderBy?: ProjectSettingNotificationOrderByWithRelationInput | ProjectSettingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectSettingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettingNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectSettingNotifications
    **/
    _count?: true | ProjectSettingNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectSettingNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectSettingNotificationMaxAggregateInputType
  }

  export type GetProjectSettingNotificationAggregateType<T extends ProjectSettingNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectSettingNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectSettingNotification[P]>
      : GetScalarType<T[P], AggregateProjectSettingNotification[P]>
  }




  export type ProjectSettingNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingNotificationWhereInput
    orderBy?: ProjectSettingNotificationOrderByWithAggregationInput | ProjectSettingNotificationOrderByWithAggregationInput[]
    by: ProjectSettingNotificationScalarFieldEnum[] | ProjectSettingNotificationScalarFieldEnum
    having?: ProjectSettingNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectSettingNotificationCountAggregateInputType | true
    _min?: ProjectSettingNotificationMinAggregateInputType
    _max?: ProjectSettingNotificationMaxAggregateInputType
  }

  export type ProjectSettingNotificationGroupByOutputType = {
    id: string
    userId: string
    projectId: string
    taskChanges: boolean
    remind: boolean
    overdue: boolean
    createdAt: Date
    createdBy: string | null
    _count: ProjectSettingNotificationCountAggregateOutputType | null
    _min: ProjectSettingNotificationMinAggregateOutputType | null
    _max: ProjectSettingNotificationMaxAggregateOutputType | null
  }

  type GetProjectSettingNotificationGroupByPayload<T extends ProjectSettingNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectSettingNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectSettingNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectSettingNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectSettingNotificationGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSettingNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSettingNotification"]>

  export type ProjectSettingNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSettingNotification"]>

  export type ProjectSettingNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSettingNotification"]>

  export type ProjectSettingNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    projectId?: boolean
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type ProjectSettingNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "projectId" | "taskChanges" | "remind" | "overdue" | "createdAt" | "createdBy", ExtArgs["result"]["projectSettingNotification"]>
  export type ProjectSettingNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectSettingNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectSettingNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectSettingNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectSettingNotification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      projectId: string
      taskChanges: boolean
      remind: boolean
      overdue: boolean
      createdAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["projectSettingNotification"]>
    composites: {}
  }

  type ProjectSettingNotificationGetPayload<S extends boolean | null | undefined | ProjectSettingNotificationDefaultArgs> = $Result.GetResult<Prisma.$ProjectSettingNotificationPayload, S>

  type ProjectSettingNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectSettingNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectSettingNotificationCountAggregateInputType | true
    }

  export interface ProjectSettingNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectSettingNotification'], meta: { name: 'ProjectSettingNotification' } }
    /**
     * Find zero or one ProjectSettingNotification that matches the filter.
     * @param {ProjectSettingNotificationFindUniqueArgs} args - Arguments to find a ProjectSettingNotification
     * @example
     * // Get one ProjectSettingNotification
     * const projectSettingNotification = await prisma.projectSettingNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectSettingNotificationFindUniqueArgs>(args: SelectSubset<T, ProjectSettingNotificationFindUniqueArgs<ExtArgs>>): Prisma__ProjectSettingNotificationClient<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectSettingNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectSettingNotificationFindUniqueOrThrowArgs} args - Arguments to find a ProjectSettingNotification
     * @example
     * // Get one ProjectSettingNotification
     * const projectSettingNotification = await prisma.projectSettingNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectSettingNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectSettingNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectSettingNotificationClient<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectSettingNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingNotificationFindFirstArgs} args - Arguments to find a ProjectSettingNotification
     * @example
     * // Get one ProjectSettingNotification
     * const projectSettingNotification = await prisma.projectSettingNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectSettingNotificationFindFirstArgs>(args?: SelectSubset<T, ProjectSettingNotificationFindFirstArgs<ExtArgs>>): Prisma__ProjectSettingNotificationClient<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectSettingNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingNotificationFindFirstOrThrowArgs} args - Arguments to find a ProjectSettingNotification
     * @example
     * // Get one ProjectSettingNotification
     * const projectSettingNotification = await prisma.projectSettingNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectSettingNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectSettingNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectSettingNotificationClient<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectSettingNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectSettingNotifications
     * const projectSettingNotifications = await prisma.projectSettingNotification.findMany()
     * 
     * // Get first 10 ProjectSettingNotifications
     * const projectSettingNotifications = await prisma.projectSettingNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectSettingNotificationWithIdOnly = await prisma.projectSettingNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectSettingNotificationFindManyArgs>(args?: SelectSubset<T, ProjectSettingNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectSettingNotification.
     * @param {ProjectSettingNotificationCreateArgs} args - Arguments to create a ProjectSettingNotification.
     * @example
     * // Create one ProjectSettingNotification
     * const ProjectSettingNotification = await prisma.projectSettingNotification.create({
     *   data: {
     *     // ... data to create a ProjectSettingNotification
     *   }
     * })
     * 
     */
    create<T extends ProjectSettingNotificationCreateArgs>(args: SelectSubset<T, ProjectSettingNotificationCreateArgs<ExtArgs>>): Prisma__ProjectSettingNotificationClient<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectSettingNotifications.
     * @param {ProjectSettingNotificationCreateManyArgs} args - Arguments to create many ProjectSettingNotifications.
     * @example
     * // Create many ProjectSettingNotifications
     * const projectSettingNotification = await prisma.projectSettingNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectSettingNotificationCreateManyArgs>(args?: SelectSubset<T, ProjectSettingNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectSettingNotifications and returns the data saved in the database.
     * @param {ProjectSettingNotificationCreateManyAndReturnArgs} args - Arguments to create many ProjectSettingNotifications.
     * @example
     * // Create many ProjectSettingNotifications
     * const projectSettingNotification = await prisma.projectSettingNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectSettingNotifications and only return the `id`
     * const projectSettingNotificationWithIdOnly = await prisma.projectSettingNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectSettingNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectSettingNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectSettingNotification.
     * @param {ProjectSettingNotificationDeleteArgs} args - Arguments to delete one ProjectSettingNotification.
     * @example
     * // Delete one ProjectSettingNotification
     * const ProjectSettingNotification = await prisma.projectSettingNotification.delete({
     *   where: {
     *     // ... filter to delete one ProjectSettingNotification
     *   }
     * })
     * 
     */
    delete<T extends ProjectSettingNotificationDeleteArgs>(args: SelectSubset<T, ProjectSettingNotificationDeleteArgs<ExtArgs>>): Prisma__ProjectSettingNotificationClient<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectSettingNotification.
     * @param {ProjectSettingNotificationUpdateArgs} args - Arguments to update one ProjectSettingNotification.
     * @example
     * // Update one ProjectSettingNotification
     * const projectSettingNotification = await prisma.projectSettingNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectSettingNotificationUpdateArgs>(args: SelectSubset<T, ProjectSettingNotificationUpdateArgs<ExtArgs>>): Prisma__ProjectSettingNotificationClient<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectSettingNotifications.
     * @param {ProjectSettingNotificationDeleteManyArgs} args - Arguments to filter ProjectSettingNotifications to delete.
     * @example
     * // Delete a few ProjectSettingNotifications
     * const { count } = await prisma.projectSettingNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectSettingNotificationDeleteManyArgs>(args?: SelectSubset<T, ProjectSettingNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectSettingNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectSettingNotifications
     * const projectSettingNotification = await prisma.projectSettingNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectSettingNotificationUpdateManyArgs>(args: SelectSubset<T, ProjectSettingNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectSettingNotifications and returns the data updated in the database.
     * @param {ProjectSettingNotificationUpdateManyAndReturnArgs} args - Arguments to update many ProjectSettingNotifications.
     * @example
     * // Update many ProjectSettingNotifications
     * const projectSettingNotification = await prisma.projectSettingNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectSettingNotifications and only return the `id`
     * const projectSettingNotificationWithIdOnly = await prisma.projectSettingNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectSettingNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectSettingNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectSettingNotification.
     * @param {ProjectSettingNotificationUpsertArgs} args - Arguments to update or create a ProjectSettingNotification.
     * @example
     * // Update or create a ProjectSettingNotification
     * const projectSettingNotification = await prisma.projectSettingNotification.upsert({
     *   create: {
     *     // ... data to create a ProjectSettingNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectSettingNotification we want to update
     *   }
     * })
     */
    upsert<T extends ProjectSettingNotificationUpsertArgs>(args: SelectSubset<T, ProjectSettingNotificationUpsertArgs<ExtArgs>>): Prisma__ProjectSettingNotificationClient<$Result.GetResult<Prisma.$ProjectSettingNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectSettingNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingNotificationCountArgs} args - Arguments to filter ProjectSettingNotifications to count.
     * @example
     * // Count the number of ProjectSettingNotifications
     * const count = await prisma.projectSettingNotification.count({
     *   where: {
     *     // ... the filter for the ProjectSettingNotifications we want to count
     *   }
     * })
    **/
    count<T extends ProjectSettingNotificationCountArgs>(
      args?: Subset<T, ProjectSettingNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectSettingNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectSettingNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectSettingNotificationAggregateArgs>(args: Subset<T, ProjectSettingNotificationAggregateArgs>): Prisma.PrismaPromise<GetProjectSettingNotificationAggregateType<T>>

    /**
     * Group by ProjectSettingNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectSettingNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectSettingNotificationGroupByArgs['orderBy'] }
        : { orderBy?: ProjectSettingNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectSettingNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectSettingNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectSettingNotification model
   */
  readonly fields: ProjectSettingNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectSettingNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectSettingNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectSettingNotification model
   */
  interface ProjectSettingNotificationFieldRefs {
    readonly id: FieldRef<"ProjectSettingNotification", 'String'>
    readonly userId: FieldRef<"ProjectSettingNotification", 'String'>
    readonly projectId: FieldRef<"ProjectSettingNotification", 'String'>
    readonly taskChanges: FieldRef<"ProjectSettingNotification", 'Boolean'>
    readonly remind: FieldRef<"ProjectSettingNotification", 'Boolean'>
    readonly overdue: FieldRef<"ProjectSettingNotification", 'Boolean'>
    readonly createdAt: FieldRef<"ProjectSettingNotification", 'DateTime'>
    readonly createdBy: FieldRef<"ProjectSettingNotification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectSettingNotification findUnique
   */
  export type ProjectSettingNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingNotification to fetch.
     */
    where: ProjectSettingNotificationWhereUniqueInput
  }

  /**
   * ProjectSettingNotification findUniqueOrThrow
   */
  export type ProjectSettingNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingNotification to fetch.
     */
    where: ProjectSettingNotificationWhereUniqueInput
  }

  /**
   * ProjectSettingNotification findFirst
   */
  export type ProjectSettingNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingNotification to fetch.
     */
    where?: ProjectSettingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettingNotifications to fetch.
     */
    orderBy?: ProjectSettingNotificationOrderByWithRelationInput | ProjectSettingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSettingNotifications.
     */
    cursor?: ProjectSettingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettingNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSettingNotifications.
     */
    distinct?: ProjectSettingNotificationScalarFieldEnum | ProjectSettingNotificationScalarFieldEnum[]
  }

  /**
   * ProjectSettingNotification findFirstOrThrow
   */
  export type ProjectSettingNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingNotification to fetch.
     */
    where?: ProjectSettingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettingNotifications to fetch.
     */
    orderBy?: ProjectSettingNotificationOrderByWithRelationInput | ProjectSettingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSettingNotifications.
     */
    cursor?: ProjectSettingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettingNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSettingNotifications.
     */
    distinct?: ProjectSettingNotificationScalarFieldEnum | ProjectSettingNotificationScalarFieldEnum[]
  }

  /**
   * ProjectSettingNotification findMany
   */
  export type ProjectSettingNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingNotifications to fetch.
     */
    where?: ProjectSettingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettingNotifications to fetch.
     */
    orderBy?: ProjectSettingNotificationOrderByWithRelationInput | ProjectSettingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectSettingNotifications.
     */
    cursor?: ProjectSettingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettingNotifications.
     */
    skip?: number
    distinct?: ProjectSettingNotificationScalarFieldEnum | ProjectSettingNotificationScalarFieldEnum[]
  }

  /**
   * ProjectSettingNotification create
   */
  export type ProjectSettingNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectSettingNotification.
     */
    data: XOR<ProjectSettingNotificationCreateInput, ProjectSettingNotificationUncheckedCreateInput>
  }

  /**
   * ProjectSettingNotification createMany
   */
  export type ProjectSettingNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectSettingNotifications.
     */
    data: ProjectSettingNotificationCreateManyInput | ProjectSettingNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectSettingNotification createManyAndReturn
   */
  export type ProjectSettingNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectSettingNotifications.
     */
    data: ProjectSettingNotificationCreateManyInput | ProjectSettingNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectSettingNotification update
   */
  export type ProjectSettingNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectSettingNotification.
     */
    data: XOR<ProjectSettingNotificationUpdateInput, ProjectSettingNotificationUncheckedUpdateInput>
    /**
     * Choose, which ProjectSettingNotification to update.
     */
    where: ProjectSettingNotificationWhereUniqueInput
  }

  /**
   * ProjectSettingNotification updateMany
   */
  export type ProjectSettingNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectSettingNotifications.
     */
    data: XOR<ProjectSettingNotificationUpdateManyMutationInput, ProjectSettingNotificationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectSettingNotifications to update
     */
    where?: ProjectSettingNotificationWhereInput
    /**
     * Limit how many ProjectSettingNotifications to update.
     */
    limit?: number
  }

  /**
   * ProjectSettingNotification updateManyAndReturn
   */
  export type ProjectSettingNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * The data used to update ProjectSettingNotifications.
     */
    data: XOR<ProjectSettingNotificationUpdateManyMutationInput, ProjectSettingNotificationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectSettingNotifications to update
     */
    where?: ProjectSettingNotificationWhereInput
    /**
     * Limit how many ProjectSettingNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectSettingNotification upsert
   */
  export type ProjectSettingNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectSettingNotification to update in case it exists.
     */
    where: ProjectSettingNotificationWhereUniqueInput
    /**
     * In case the ProjectSettingNotification found by the `where` argument doesn't exist, create a new ProjectSettingNotification with this data.
     */
    create: XOR<ProjectSettingNotificationCreateInput, ProjectSettingNotificationUncheckedCreateInput>
    /**
     * In case the ProjectSettingNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectSettingNotificationUpdateInput, ProjectSettingNotificationUncheckedUpdateInput>
  }

  /**
   * ProjectSettingNotification delete
   */
  export type ProjectSettingNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
    /**
     * Filter which ProjectSettingNotification to delete.
     */
    where: ProjectSettingNotificationWhereUniqueInput
  }

  /**
   * ProjectSettingNotification deleteMany
   */
  export type ProjectSettingNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSettingNotifications to delete
     */
    where?: ProjectSettingNotificationWhereInput
    /**
     * Limit how many ProjectSettingNotifications to delete.
     */
    limit?: number
  }

  /**
   * ProjectSettingNotification without action
   */
  export type ProjectSettingNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingNotification
     */
    select?: ProjectSettingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSettingNotification
     */
    omit?: ProjectSettingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingNotificationInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    order: number | null
    checklistDone: number | null
    checklistTodos: number | null
    progress: number | null
    taskPoint: number | null
  }

  export type TaskSumAggregateOutputType = {
    order: number | null
    checklistDone: number | null
    checklistTodos: number | null
    progress: number | null
    taskPoint: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    desc: string | null
    dueDate: Date | null
    order: number | null
    type: $Enums.TaskType | null
    checklistDone: number | null
    checklistTodos: number | null
    cover: string | null
    plannedStartDate: Date | null
    plannedDueDate: Date | null
    startDate: Date | null
    projectId: string | null
    priority: $Enums.TaskPriority | null
    taskStatusId: string | null
    parentTaskId: string | null
    progress: number | null
    done: boolean | null
    taskPoint: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    desc: string | null
    dueDate: Date | null
    order: number | null
    type: $Enums.TaskType | null
    checklistDone: number | null
    checklistTodos: number | null
    cover: string | null
    plannedStartDate: Date | null
    plannedDueDate: Date | null
    startDate: Date | null
    projectId: string | null
    priority: $Enums.TaskPriority | null
    taskStatusId: string | null
    parentTaskId: string | null
    progress: number | null
    done: boolean | null
    taskPoint: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    desc: number
    dueDate: number
    order: number
    type: number
    checklistDone: number
    checklistTodos: number
    cover: number
    plannedStartDate: number
    plannedDueDate: number
    startDate: number
    projectId: number
    priority: number
    taskStatusId: number
    parentTaskId: number
    progress: number
    done: number
    taskPoint: number
    customFields: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    order?: true
    checklistDone?: true
    checklistTodos?: true
    progress?: true
    taskPoint?: true
  }

  export type TaskSumAggregateInputType = {
    order?: true
    checklistDone?: true
    checklistTodos?: true
    progress?: true
    taskPoint?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    desc?: true
    dueDate?: true
    order?: true
    type?: true
    checklistDone?: true
    checklistTodos?: true
    cover?: true
    plannedStartDate?: true
    plannedDueDate?: true
    startDate?: true
    projectId?: true
    priority?: true
    taskStatusId?: true
    parentTaskId?: true
    progress?: true
    done?: true
    taskPoint?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    desc?: true
    dueDate?: true
    order?: true
    type?: true
    checklistDone?: true
    checklistTodos?: true
    cover?: true
    plannedStartDate?: true
    plannedDueDate?: true
    startDate?: true
    projectId?: true
    priority?: true
    taskStatusId?: true
    parentTaskId?: true
    progress?: true
    done?: true
    taskPoint?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    desc?: true
    dueDate?: true
    order?: true
    type?: true
    checklistDone?: true
    checklistTodos?: true
    cover?: true
    plannedStartDate?: true
    plannedDueDate?: true
    startDate?: true
    projectId?: true
    priority?: true
    taskStatusId?: true
    parentTaskId?: true
    progress?: true
    done?: true
    taskPoint?: true
    customFields?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    desc: string | null
    dueDate: Date | null
    order: number
    type: $Enums.TaskType | null
    checklistDone: number | null
    checklistTodos: number | null
    cover: string | null
    plannedStartDate: Date | null
    plannedDueDate: Date | null
    startDate: Date | null
    projectId: string
    priority: $Enums.TaskPriority | null
    taskStatusId: string | null
    parentTaskId: string | null
    progress: number | null
    done: boolean
    taskPoint: number | null
    customFields: JsonValue | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    desc?: boolean
    dueDate?: boolean
    order?: boolean
    type?: boolean
    checklistDone?: boolean
    checklistTodos?: boolean
    cover?: boolean
    plannedStartDate?: boolean
    plannedDueDate?: boolean
    startDate?: boolean
    projectId?: boolean
    priority?: boolean
    taskStatusId?: boolean
    parentTaskId?: boolean
    progress?: boolean
    done?: boolean
    taskPoint?: boolean
    customFields?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    taskChecklists?: boolean | Task$taskChecklistsArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    timers?: boolean | Task$timersArgs<ExtArgs>
    taskTags?: boolean | Task$taskTagsArgs<ExtArgs>
    taskAssignees?: boolean | Task$taskAssigneesArgs<ExtArgs>
    fileStorages?: boolean | Task$fileStoragesArgs<ExtArgs>
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
    subTasks?: boolean | Task$subTasksArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    taskStatus?: boolean | Task$taskStatusArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    desc?: boolean
    dueDate?: boolean
    order?: boolean
    type?: boolean
    checklistDone?: boolean
    checklistTodos?: boolean
    cover?: boolean
    plannedStartDate?: boolean
    plannedDueDate?: boolean
    startDate?: boolean
    projectId?: boolean
    priority?: boolean
    taskStatusId?: boolean
    parentTaskId?: boolean
    progress?: boolean
    done?: boolean
    taskPoint?: boolean
    customFields?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    taskStatus?: boolean | Task$taskStatusArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    desc?: boolean
    dueDate?: boolean
    order?: boolean
    type?: boolean
    checklistDone?: boolean
    checklistTodos?: boolean
    cover?: boolean
    plannedStartDate?: boolean
    plannedDueDate?: boolean
    startDate?: boolean
    projectId?: boolean
    priority?: boolean
    taskStatusId?: boolean
    parentTaskId?: boolean
    progress?: boolean
    done?: boolean
    taskPoint?: boolean
    customFields?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    taskStatus?: boolean | Task$taskStatusArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    desc?: boolean
    dueDate?: boolean
    order?: boolean
    type?: boolean
    checklistDone?: boolean
    checklistTodos?: boolean
    cover?: boolean
    plannedStartDate?: boolean
    plannedDueDate?: boolean
    startDate?: boolean
    projectId?: boolean
    priority?: boolean
    taskStatusId?: boolean
    parentTaskId?: boolean
    progress?: boolean
    done?: boolean
    taskPoint?: boolean
    customFields?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "desc" | "dueDate" | "order" | "type" | "checklistDone" | "checklistTodos" | "cover" | "plannedStartDate" | "plannedDueDate" | "startDate" | "projectId" | "priority" | "taskStatusId" | "parentTaskId" | "progress" | "done" | "taskPoint" | "customFields" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskChecklists?: boolean | Task$taskChecklistsArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    timers?: boolean | Task$timersArgs<ExtArgs>
    taskTags?: boolean | Task$taskTagsArgs<ExtArgs>
    taskAssignees?: boolean | Task$taskAssigneesArgs<ExtArgs>
    fileStorages?: boolean | Task$fileStoragesArgs<ExtArgs>
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
    subTasks?: boolean | Task$subTasksArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    taskStatus?: boolean | Task$taskStatusArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    taskStatus?: boolean | Task$taskStatusArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    taskStatus?: boolean | Task$taskStatusArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      taskChecklists: Prisma.$TaskChecklistPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      timers: Prisma.$TimerPayload<ExtArgs>[]
      taskTags: Prisma.$TaskTagPayload<ExtArgs>[]
      taskAssignees: Prisma.$TaskAssigneePayload<ExtArgs>[]
      fileStorages: Prisma.$FileStoragePayload<ExtArgs>[]
      parentTask: Prisma.$TaskPayload<ExtArgs> | null
      subTasks: Prisma.$TaskPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>
      taskStatus: Prisma.$TaskStatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      desc: string | null
      dueDate: Date | null
      order: number
      type: $Enums.TaskType | null
      checklistDone: number | null
      checklistTodos: number | null
      cover: string | null
      plannedStartDate: Date | null
      plannedDueDate: Date | null
      startDate: Date | null
      projectId: string
      priority: $Enums.TaskPriority | null
      taskStatusId: string | null
      parentTaskId: string | null
      progress: number | null
      done: boolean
      taskPoint: number | null
      customFields: Prisma.JsonValue | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taskChecklists<T extends Task$taskChecklistsArgs<ExtArgs> = {}>(args?: Subset<T, Task$taskChecklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Task$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timers<T extends Task$timersArgs<ExtArgs> = {}>(args?: Subset<T, Task$timersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskTags<T extends Task$taskTagsArgs<ExtArgs> = {}>(args?: Subset<T, Task$taskTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskAssignees<T extends Task$taskAssigneesArgs<ExtArgs> = {}>(args?: Subset<T, Task$taskAssigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fileStorages<T extends Task$fileStoragesArgs<ExtArgs> = {}>(args?: Subset<T, Task$fileStoragesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parentTask<T extends Task$parentTaskArgs<ExtArgs> = {}>(args?: Subset<T, Task$parentTaskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subTasks<T extends Task$subTasksArgs<ExtArgs> = {}>(args?: Subset<T, Task$subTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taskStatus<T extends Task$taskStatusArgs<ExtArgs> = {}>(args?: Subset<T, Task$taskStatusArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly desc: FieldRef<"Task", 'String'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly order: FieldRef<"Task", 'Int'>
    readonly type: FieldRef<"Task", 'TaskType'>
    readonly checklistDone: FieldRef<"Task", 'Int'>
    readonly checklistTodos: FieldRef<"Task", 'Int'>
    readonly cover: FieldRef<"Task", 'String'>
    readonly plannedStartDate: FieldRef<"Task", 'DateTime'>
    readonly plannedDueDate: FieldRef<"Task", 'DateTime'>
    readonly startDate: FieldRef<"Task", 'DateTime'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'TaskPriority'>
    readonly taskStatusId: FieldRef<"Task", 'String'>
    readonly parentTaskId: FieldRef<"Task", 'String'>
    readonly progress: FieldRef<"Task", 'Int'>
    readonly done: FieldRef<"Task", 'Boolean'>
    readonly taskPoint: FieldRef<"Task", 'Int'>
    readonly customFields: FieldRef<"Task", 'Json'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly createdBy: FieldRef<"Task", 'String'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly updatedBy: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.taskChecklists
   */
  export type Task$taskChecklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    where?: TaskChecklistWhereInput
    orderBy?: TaskChecklistOrderByWithRelationInput | TaskChecklistOrderByWithRelationInput[]
    cursor?: TaskChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskChecklistScalarFieldEnum | TaskChecklistScalarFieldEnum[]
  }

  /**
   * Task.comments
   */
  export type Task$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Task.timers
   */
  export type Task$timersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    where?: TimerWhereInput
    orderBy?: TimerOrderByWithRelationInput | TimerOrderByWithRelationInput[]
    cursor?: TimerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimerScalarFieldEnum | TimerScalarFieldEnum[]
  }

  /**
   * Task.taskTags
   */
  export type Task$taskTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    where?: TaskTagWhereInput
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    cursor?: TaskTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * Task.taskAssignees
   */
  export type Task$taskAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    cursor?: TaskAssigneeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * Task.fileStorages
   */
  export type Task$fileStoragesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    where?: FileStorageWhereInput
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    cursor?: FileStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * Task.parentTask
   */
  export type Task$parentTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * Task.subTasks
   */
  export type Task$subTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task.taskStatus
   */
  export type Task$taskStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    where?: TaskStatusWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskStatus
   */

  export type AggregateTaskStatus = {
    _count: TaskStatusCountAggregateOutputType | null
    _avg: TaskStatusAvgAggregateOutputType | null
    _sum: TaskStatusSumAggregateOutputType | null
    _min: TaskStatusMinAggregateOutputType | null
    _max: TaskStatusMaxAggregateOutputType | null
  }

  export type TaskStatusAvgAggregateOutputType = {
    order: number | null
  }

  export type TaskStatusSumAggregateOutputType = {
    order: number | null
  }

  export type TaskStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    order: number | null
    projectId: string | null
    type: $Enums.StatusType | null
  }

  export type TaskStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    order: number | null
    projectId: string | null
    type: $Enums.StatusType | null
  }

  export type TaskStatusCountAggregateOutputType = {
    id: number
    name: number
    color: number
    order: number
    projectId: number
    type: number
    _all: number
  }


  export type TaskStatusAvgAggregateInputType = {
    order?: true
  }

  export type TaskStatusSumAggregateInputType = {
    order?: true
  }

  export type TaskStatusMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    order?: true
    projectId?: true
    type?: true
  }

  export type TaskStatusMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    order?: true
    projectId?: true
    type?: true
  }

  export type TaskStatusCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    order?: true
    projectId?: true
    type?: true
    _all?: true
  }

  export type TaskStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskStatus to aggregate.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskStatuses
    **/
    _count?: true | TaskStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskStatusMaxAggregateInputType
  }

  export type GetTaskStatusAggregateType<T extends TaskStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskStatus[P]>
      : GetScalarType<T[P], AggregateTaskStatus[P]>
  }




  export type TaskStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskStatusWhereInput
    orderBy?: TaskStatusOrderByWithAggregationInput | TaskStatusOrderByWithAggregationInput[]
    by: TaskStatusScalarFieldEnum[] | TaskStatusScalarFieldEnum
    having?: TaskStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskStatusCountAggregateInputType | true
    _avg?: TaskStatusAvgAggregateInputType
    _sum?: TaskStatusSumAggregateInputType
    _min?: TaskStatusMinAggregateInputType
    _max?: TaskStatusMaxAggregateInputType
  }

  export type TaskStatusGroupByOutputType = {
    id: string
    name: string
    color: string
    order: number
    projectId: string
    type: $Enums.StatusType
    _count: TaskStatusCountAggregateOutputType | null
    _avg: TaskStatusAvgAggregateOutputType | null
    _sum: TaskStatusSumAggregateOutputType | null
    _min: TaskStatusMinAggregateOutputType | null
    _max: TaskStatusMaxAggregateOutputType | null
  }

  type GetTaskStatusGroupByPayload<T extends TaskStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TaskStatusGroupByOutputType[P]>
        }
      >
    >


  export type TaskStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    order?: boolean
    projectId?: boolean
    type?: boolean
    tasks?: boolean | TaskStatus$tasksArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | TaskStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskStatus"]>

  export type TaskStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    order?: boolean
    projectId?: boolean
    type?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskStatus"]>

  export type TaskStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    order?: boolean
    projectId?: boolean
    type?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskStatus"]>

  export type TaskStatusSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    order?: boolean
    projectId?: boolean
    type?: boolean
  }

  export type TaskStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "order" | "projectId" | "type", ExtArgs["result"]["taskStatus"]>
  export type TaskStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TaskStatus$tasksArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | TaskStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TaskStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TaskStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskStatus"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      order: number
      projectId: string
      type: $Enums.StatusType
    }, ExtArgs["result"]["taskStatus"]>
    composites: {}
  }

  type TaskStatusGetPayload<S extends boolean | null | undefined | TaskStatusDefaultArgs> = $Result.GetResult<Prisma.$TaskStatusPayload, S>

  type TaskStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskStatusCountAggregateInputType | true
    }

  export interface TaskStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskStatus'], meta: { name: 'TaskStatus' } }
    /**
     * Find zero or one TaskStatus that matches the filter.
     * @param {TaskStatusFindUniqueArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskStatusFindUniqueArgs>(args: SelectSubset<T, TaskStatusFindUniqueArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskStatusFindUniqueOrThrowArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusFindFirstArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskStatusFindFirstArgs>(args?: SelectSubset<T, TaskStatusFindFirstArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusFindFirstOrThrowArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskStatuses
     * const taskStatuses = await prisma.taskStatus.findMany()
     * 
     * // Get first 10 TaskStatuses
     * const taskStatuses = await prisma.taskStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskStatusWithIdOnly = await prisma.taskStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskStatusFindManyArgs>(args?: SelectSubset<T, TaskStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskStatus.
     * @param {TaskStatusCreateArgs} args - Arguments to create a TaskStatus.
     * @example
     * // Create one TaskStatus
     * const TaskStatus = await prisma.taskStatus.create({
     *   data: {
     *     // ... data to create a TaskStatus
     *   }
     * })
     * 
     */
    create<T extends TaskStatusCreateArgs>(args: SelectSubset<T, TaskStatusCreateArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskStatuses.
     * @param {TaskStatusCreateManyArgs} args - Arguments to create many TaskStatuses.
     * @example
     * // Create many TaskStatuses
     * const taskStatus = await prisma.taskStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskStatusCreateManyArgs>(args?: SelectSubset<T, TaskStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskStatuses and returns the data saved in the database.
     * @param {TaskStatusCreateManyAndReturnArgs} args - Arguments to create many TaskStatuses.
     * @example
     * // Create many TaskStatuses
     * const taskStatus = await prisma.taskStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskStatuses and only return the `id`
     * const taskStatusWithIdOnly = await prisma.taskStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskStatus.
     * @param {TaskStatusDeleteArgs} args - Arguments to delete one TaskStatus.
     * @example
     * // Delete one TaskStatus
     * const TaskStatus = await prisma.taskStatus.delete({
     *   where: {
     *     // ... filter to delete one TaskStatus
     *   }
     * })
     * 
     */
    delete<T extends TaskStatusDeleteArgs>(args: SelectSubset<T, TaskStatusDeleteArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskStatus.
     * @param {TaskStatusUpdateArgs} args - Arguments to update one TaskStatus.
     * @example
     * // Update one TaskStatus
     * const taskStatus = await prisma.taskStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskStatusUpdateArgs>(args: SelectSubset<T, TaskStatusUpdateArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskStatuses.
     * @param {TaskStatusDeleteManyArgs} args - Arguments to filter TaskStatuses to delete.
     * @example
     * // Delete a few TaskStatuses
     * const { count } = await prisma.taskStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskStatusDeleteManyArgs>(args?: SelectSubset<T, TaskStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskStatuses
     * const taskStatus = await prisma.taskStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskStatusUpdateManyArgs>(args: SelectSubset<T, TaskStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskStatuses and returns the data updated in the database.
     * @param {TaskStatusUpdateManyAndReturnArgs} args - Arguments to update many TaskStatuses.
     * @example
     * // Update many TaskStatuses
     * const taskStatus = await prisma.taskStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskStatuses and only return the `id`
     * const taskStatusWithIdOnly = await prisma.taskStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskStatus.
     * @param {TaskStatusUpsertArgs} args - Arguments to update or create a TaskStatus.
     * @example
     * // Update or create a TaskStatus
     * const taskStatus = await prisma.taskStatus.upsert({
     *   create: {
     *     // ... data to create a TaskStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskStatus we want to update
     *   }
     * })
     */
    upsert<T extends TaskStatusUpsertArgs>(args: SelectSubset<T, TaskStatusUpsertArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusCountArgs} args - Arguments to filter TaskStatuses to count.
     * @example
     * // Count the number of TaskStatuses
     * const count = await prisma.taskStatus.count({
     *   where: {
     *     // ... the filter for the TaskStatuses we want to count
     *   }
     * })
    **/
    count<T extends TaskStatusCountArgs>(
      args?: Subset<T, TaskStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskStatusAggregateArgs>(args: Subset<T, TaskStatusAggregateArgs>): Prisma.PrismaPromise<GetTaskStatusAggregateType<T>>

    /**
     * Group by TaskStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskStatusGroupByArgs['orderBy'] }
        : { orderBy?: TaskStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskStatus model
   */
  readonly fields: TaskStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends TaskStatus$tasksArgs<ExtArgs> = {}>(args?: Subset<T, TaskStatus$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskStatus model
   */
  interface TaskStatusFieldRefs {
    readonly id: FieldRef<"TaskStatus", 'String'>
    readonly name: FieldRef<"TaskStatus", 'String'>
    readonly color: FieldRef<"TaskStatus", 'String'>
    readonly order: FieldRef<"TaskStatus", 'Int'>
    readonly projectId: FieldRef<"TaskStatus", 'String'>
    readonly type: FieldRef<"TaskStatus", 'StatusType'>
  }
    

  // Custom InputTypes
  /**
   * TaskStatus findUnique
   */
  export type TaskStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus findUniqueOrThrow
   */
  export type TaskStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus findFirst
   */
  export type TaskStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskStatuses.
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskStatuses.
     */
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * TaskStatus findFirstOrThrow
   */
  export type TaskStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskStatuses.
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskStatuses.
     */
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * TaskStatus findMany
   */
  export type TaskStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatuses to fetch.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskStatuses.
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * TaskStatus create
   */
  export type TaskStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskStatus.
     */
    data: XOR<TaskStatusCreateInput, TaskStatusUncheckedCreateInput>
  }

  /**
   * TaskStatus createMany
   */
  export type TaskStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskStatuses.
     */
    data: TaskStatusCreateManyInput | TaskStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskStatus createManyAndReturn
   */
  export type TaskStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * The data used to create many TaskStatuses.
     */
    data: TaskStatusCreateManyInput | TaskStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskStatus update
   */
  export type TaskStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskStatus.
     */
    data: XOR<TaskStatusUpdateInput, TaskStatusUncheckedUpdateInput>
    /**
     * Choose, which TaskStatus to update.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus updateMany
   */
  export type TaskStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskStatuses.
     */
    data: XOR<TaskStatusUpdateManyMutationInput, TaskStatusUncheckedUpdateManyInput>
    /**
     * Filter which TaskStatuses to update
     */
    where?: TaskStatusWhereInput
    /**
     * Limit how many TaskStatuses to update.
     */
    limit?: number
  }

  /**
   * TaskStatus updateManyAndReturn
   */
  export type TaskStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * The data used to update TaskStatuses.
     */
    data: XOR<TaskStatusUpdateManyMutationInput, TaskStatusUncheckedUpdateManyInput>
    /**
     * Filter which TaskStatuses to update
     */
    where?: TaskStatusWhereInput
    /**
     * Limit how many TaskStatuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskStatus upsert
   */
  export type TaskStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskStatus to update in case it exists.
     */
    where: TaskStatusWhereUniqueInput
    /**
     * In case the TaskStatus found by the `where` argument doesn't exist, create a new TaskStatus with this data.
     */
    create: XOR<TaskStatusCreateInput, TaskStatusUncheckedCreateInput>
    /**
     * In case the TaskStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskStatusUpdateInput, TaskStatusUncheckedUpdateInput>
  }

  /**
   * TaskStatus delete
   */
  export type TaskStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter which TaskStatus to delete.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus deleteMany
   */
  export type TaskStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskStatuses to delete
     */
    where?: TaskStatusWhereInput
    /**
     * Limit how many TaskStatuses to delete.
     */
    limit?: number
  }

  /**
   * TaskStatus.tasks
   */
  export type TaskStatus$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * TaskStatus without action
   */
  export type TaskStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskStatus
     */
    omit?: TaskStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
  }


  /**
   * Model TaskAssignee
   */

  export type AggregateTaskAssignee = {
    _count: TaskAssigneeCountAggregateOutputType | null
    _min: TaskAssigneeMinAggregateOutputType | null
    _max: TaskAssigneeMaxAggregateOutputType | null
  }

  export type TaskAssigneeMinAggregateOutputType = {
    taskId: string | null
    userId: string | null
    assignedAt: Date | null
  }

  export type TaskAssigneeMaxAggregateOutputType = {
    taskId: string | null
    userId: string | null
    assignedAt: Date | null
  }

  export type TaskAssigneeCountAggregateOutputType = {
    taskId: number
    userId: number
    assignedAt: number
    _all: number
  }


  export type TaskAssigneeMinAggregateInputType = {
    taskId?: true
    userId?: true
    assignedAt?: true
  }

  export type TaskAssigneeMaxAggregateInputType = {
    taskId?: true
    userId?: true
    assignedAt?: true
  }

  export type TaskAssigneeCountAggregateInputType = {
    taskId?: true
    userId?: true
    assignedAt?: true
    _all?: true
  }

  export type TaskAssigneeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignee to aggregate.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAssignees
    **/
    _count?: true | TaskAssigneeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAssigneeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAssigneeMaxAggregateInputType
  }

  export type GetTaskAssigneeAggregateType<T extends TaskAssigneeAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAssignee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignee[P]>
      : GetScalarType<T[P], AggregateTaskAssignee[P]>
  }




  export type TaskAssigneeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithAggregationInput | TaskAssigneeOrderByWithAggregationInput[]
    by: TaskAssigneeScalarFieldEnum[] | TaskAssigneeScalarFieldEnum
    having?: TaskAssigneeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAssigneeCountAggregateInputType | true
    _min?: TaskAssigneeMinAggregateInputType
    _max?: TaskAssigneeMaxAggregateInputType
  }

  export type TaskAssigneeGroupByOutputType = {
    taskId: string
    userId: string
    assignedAt: Date
    _count: TaskAssigneeCountAggregateOutputType | null
    _min: TaskAssigneeMinAggregateOutputType | null
    _max: TaskAssigneeMaxAggregateOutputType | null
  }

  type GetTaskAssigneeGroupByPayload<T extends TaskAssigneeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssigneeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAssigneeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>
        }
      >
    >


  export type TaskAssigneeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    userId?: boolean
    assignedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    userId?: boolean
    assignedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    userId?: boolean
    assignedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectScalar = {
    taskId?: boolean
    userId?: boolean
    assignedAt?: boolean
  }

  export type TaskAssigneeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"taskId" | "userId" | "assignedAt", ExtArgs["result"]["taskAssignee"]>
  export type TaskAssigneeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskAssigneeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskAssigneeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskAssigneePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAssignee"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      taskId: string
      userId: string
      assignedAt: Date
    }, ExtArgs["result"]["taskAssignee"]>
    composites: {}
  }

  type TaskAssigneeGetPayload<S extends boolean | null | undefined | TaskAssigneeDefaultArgs> = $Result.GetResult<Prisma.$TaskAssigneePayload, S>

  type TaskAssigneeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAssigneeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAssigneeCountAggregateInputType | true
    }

  export interface TaskAssigneeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignee'], meta: { name: 'TaskAssignee' } }
    /**
     * Find zero or one TaskAssignee that matches the filter.
     * @param {TaskAssigneeFindUniqueArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssigneeFindUniqueArgs>(args: SelectSubset<T, TaskAssigneeFindUniqueArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskAssignee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAssigneeFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssigneeFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssigneeFindFirstArgs>(args?: SelectSubset<T, TaskAssigneeFindFirstArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssigneeFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAssigneeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskAssignees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany()
     * 
     * // Get first 10 TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany({ take: 10 })
     * 
     * // Only select the `taskId`
     * const taskAssigneeWithTaskIdOnly = await prisma.taskAssignee.findMany({ select: { taskId: true } })
     * 
     */
    findMany<T extends TaskAssigneeFindManyArgs>(args?: SelectSubset<T, TaskAssigneeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskAssignee.
     * @param {TaskAssigneeCreateArgs} args - Arguments to create a TaskAssignee.
     * @example
     * // Create one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.create({
     *   data: {
     *     // ... data to create a TaskAssignee
     *   }
     * })
     * 
     */
    create<T extends TaskAssigneeCreateArgs>(args: SelectSubset<T, TaskAssigneeCreateArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskAssignees.
     * @param {TaskAssigneeCreateManyArgs} args - Arguments to create many TaskAssignees.
     * @example
     * // Create many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAssigneeCreateManyArgs>(args?: SelectSubset<T, TaskAssigneeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAssignees and returns the data saved in the database.
     * @param {TaskAssigneeCreateManyAndReturnArgs} args - Arguments to create many TaskAssignees.
     * @example
     * // Create many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAssignees and only return the `taskId`
     * const taskAssigneeWithTaskIdOnly = await prisma.taskAssignee.createManyAndReturn({
     *   select: { taskId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAssigneeCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAssigneeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskAssignee.
     * @param {TaskAssigneeDeleteArgs} args - Arguments to delete one TaskAssignee.
     * @example
     * // Delete one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignee
     *   }
     * })
     * 
     */
    delete<T extends TaskAssigneeDeleteArgs>(args: SelectSubset<T, TaskAssigneeDeleteArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskAssignee.
     * @param {TaskAssigneeUpdateArgs} args - Arguments to update one TaskAssignee.
     * @example
     * // Update one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAssigneeUpdateArgs>(args: SelectSubset<T, TaskAssigneeUpdateArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskAssignees.
     * @param {TaskAssigneeDeleteManyArgs} args - Arguments to filter TaskAssignees to delete.
     * @example
     * // Delete a few TaskAssignees
     * const { count } = await prisma.taskAssignee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAssigneeDeleteManyArgs>(args?: SelectSubset<T, TaskAssigneeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAssigneeUpdateManyArgs>(args: SelectSubset<T, TaskAssigneeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignees and returns the data updated in the database.
     * @param {TaskAssigneeUpdateManyAndReturnArgs} args - Arguments to update many TaskAssignees.
     * @example
     * // Update many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskAssignees and only return the `taskId`
     * const taskAssigneeWithTaskIdOnly = await prisma.taskAssignee.updateManyAndReturn({
     *   select: { taskId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskAssigneeUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskAssigneeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskAssignee.
     * @param {TaskAssigneeUpsertArgs} args - Arguments to update or create a TaskAssignee.
     * @example
     * // Update or create a TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.upsert({
     *   create: {
     *     // ... data to create a TaskAssignee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignee we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssigneeUpsertArgs>(args: SelectSubset<T, TaskAssigneeUpsertArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeCountArgs} args - Arguments to filter TaskAssignees to count.
     * @example
     * // Count the number of TaskAssignees
     * const count = await prisma.taskAssignee.count({
     *   where: {
     *     // ... the filter for the TaskAssignees we want to count
     *   }
     * })
    **/
    count<T extends TaskAssigneeCountArgs>(
      args?: Subset<T, TaskAssigneeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssigneeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAssigneeAggregateArgs>(args: Subset<T, TaskAssigneeAggregateArgs>): Prisma.PrismaPromise<GetTaskAssigneeAggregateType<T>>

    /**
     * Group by TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAssigneeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssigneeGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssigneeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAssigneeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAssigneeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAssignee model
   */
  readonly fields: TaskAssigneeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssigneeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAssignee model
   */
  interface TaskAssigneeFieldRefs {
    readonly taskId: FieldRef<"TaskAssignee", 'String'>
    readonly userId: FieldRef<"TaskAssignee", 'String'>
    readonly assignedAt: FieldRef<"TaskAssignee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAssignee findUnique
   */
  export type TaskAssigneeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee findUniqueOrThrow
   */
  export type TaskAssigneeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee findFirst
   */
  export type TaskAssigneeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee findFirstOrThrow
   */
  export type TaskAssigneeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee findMany
   */
  export type TaskAssigneeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignees to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee create
   */
  export type TaskAssigneeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAssignee.
     */
    data: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>
  }

  /**
   * TaskAssignee createMany
   */
  export type TaskAssigneeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAssignees.
     */
    data: TaskAssigneeCreateManyInput | TaskAssigneeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAssignee createManyAndReturn
   */
  export type TaskAssigneeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * The data used to create many TaskAssignees.
     */
    data: TaskAssigneeCreateManyInput | TaskAssigneeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignee update
   */
  export type TaskAssigneeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAssignee.
     */
    data: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>
    /**
     * Choose, which TaskAssignee to update.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee updateMany
   */
  export type TaskAssigneeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAssignees.
     */
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignees to update
     */
    where?: TaskAssigneeWhereInput
    /**
     * Limit how many TaskAssignees to update.
     */
    limit?: number
  }

  /**
   * TaskAssignee updateManyAndReturn
   */
  export type TaskAssigneeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * The data used to update TaskAssignees.
     */
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignees to update
     */
    where?: TaskAssigneeWhereInput
    /**
     * Limit how many TaskAssignees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignee upsert
   */
  export type TaskAssigneeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAssignee to update in case it exists.
     */
    where: TaskAssigneeWhereUniqueInput
    /**
     * In case the TaskAssignee found by the `where` argument doesn't exist, create a new TaskAssignee with this data.
     */
    create: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>
    /**
     * In case the TaskAssignee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>
  }

  /**
   * TaskAssignee delete
   */
  export type TaskAssigneeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter which TaskAssignee to delete.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee deleteMany
   */
  export type TaskAssigneeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignees to delete
     */
    where?: TaskAssigneeWhereInput
    /**
     * Limit how many TaskAssignees to delete.
     */
    limit?: number
  }

  /**
   * TaskAssignee without action
   */
  export type TaskAssigneeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
  }


  /**
   * Model TaskChecklist
   */

  export type AggregateTaskChecklist = {
    _count: TaskChecklistCountAggregateOutputType | null
    _avg: TaskChecklistAvgAggregateOutputType | null
    _sum: TaskChecklistSumAggregateOutputType | null
    _min: TaskChecklistMinAggregateOutputType | null
    _max: TaskChecklistMaxAggregateOutputType | null
  }

  export type TaskChecklistAvgAggregateOutputType = {
    order: number | null
  }

  export type TaskChecklistSumAggregateOutputType = {
    order: number | null
  }

  export type TaskChecklistMinAggregateOutputType = {
    id: string | null
    title: string | null
    order: number | null
    taskId: string | null
    done: boolean | null
    doneAt: Date | null
  }

  export type TaskChecklistMaxAggregateOutputType = {
    id: string | null
    title: string | null
    order: number | null
    taskId: string | null
    done: boolean | null
    doneAt: Date | null
  }

  export type TaskChecklistCountAggregateOutputType = {
    id: number
    title: number
    order: number
    taskId: number
    done: number
    doneAt: number
    _all: number
  }


  export type TaskChecklistAvgAggregateInputType = {
    order?: true
  }

  export type TaskChecklistSumAggregateInputType = {
    order?: true
  }

  export type TaskChecklistMinAggregateInputType = {
    id?: true
    title?: true
    order?: true
    taskId?: true
    done?: true
    doneAt?: true
  }

  export type TaskChecklistMaxAggregateInputType = {
    id?: true
    title?: true
    order?: true
    taskId?: true
    done?: true
    doneAt?: true
  }

  export type TaskChecklistCountAggregateInputType = {
    id?: true
    title?: true
    order?: true
    taskId?: true
    done?: true
    doneAt?: true
    _all?: true
  }

  export type TaskChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskChecklist to aggregate.
     */
    where?: TaskChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskChecklists to fetch.
     */
    orderBy?: TaskChecklistOrderByWithRelationInput | TaskChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskChecklists
    **/
    _count?: true | TaskChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskChecklistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskChecklistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskChecklistMaxAggregateInputType
  }

  export type GetTaskChecklistAggregateType<T extends TaskChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskChecklist[P]>
      : GetScalarType<T[P], AggregateTaskChecklist[P]>
  }




  export type TaskChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskChecklistWhereInput
    orderBy?: TaskChecklistOrderByWithAggregationInput | TaskChecklistOrderByWithAggregationInput[]
    by: TaskChecklistScalarFieldEnum[] | TaskChecklistScalarFieldEnum
    having?: TaskChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskChecklistCountAggregateInputType | true
    _avg?: TaskChecklistAvgAggregateInputType
    _sum?: TaskChecklistSumAggregateInputType
    _min?: TaskChecklistMinAggregateInputType
    _max?: TaskChecklistMaxAggregateInputType
  }

  export type TaskChecklistGroupByOutputType = {
    id: string
    title: string
    order: number
    taskId: string
    done: boolean | null
    doneAt: Date | null
    _count: TaskChecklistCountAggregateOutputType | null
    _avg: TaskChecklistAvgAggregateOutputType | null
    _sum: TaskChecklistSumAggregateOutputType | null
    _min: TaskChecklistMinAggregateOutputType | null
    _max: TaskChecklistMaxAggregateOutputType | null
  }

  type GetTaskChecklistGroupByPayload<T extends TaskChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], TaskChecklistGroupByOutputType[P]>
        }
      >
    >


  export type TaskChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
    taskId?: boolean
    done?: boolean
    doneAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskChecklist"]>

  export type TaskChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
    taskId?: boolean
    done?: boolean
    doneAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskChecklist"]>

  export type TaskChecklistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
    taskId?: boolean
    done?: boolean
    doneAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskChecklist"]>

  export type TaskChecklistSelectScalar = {
    id?: boolean
    title?: boolean
    order?: boolean
    taskId?: boolean
    done?: boolean
    doneAt?: boolean
  }

  export type TaskChecklistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "order" | "taskId" | "done" | "doneAt", ExtArgs["result"]["taskChecklist"]>
  export type TaskChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskChecklistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskChecklist"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      order: number
      taskId: string
      done: boolean | null
      doneAt: Date | null
    }, ExtArgs["result"]["taskChecklist"]>
    composites: {}
  }

  type TaskChecklistGetPayload<S extends boolean | null | undefined | TaskChecklistDefaultArgs> = $Result.GetResult<Prisma.$TaskChecklistPayload, S>

  type TaskChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskChecklistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskChecklistCountAggregateInputType | true
    }

  export interface TaskChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskChecklist'], meta: { name: 'TaskChecklist' } }
    /**
     * Find zero or one TaskChecklist that matches the filter.
     * @param {TaskChecklistFindUniqueArgs} args - Arguments to find a TaskChecklist
     * @example
     * // Get one TaskChecklist
     * const taskChecklist = await prisma.taskChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskChecklistFindUniqueArgs>(args: SelectSubset<T, TaskChecklistFindUniqueArgs<ExtArgs>>): Prisma__TaskChecklistClient<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskChecklist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskChecklistFindUniqueOrThrowArgs} args - Arguments to find a TaskChecklist
     * @example
     * // Get one TaskChecklist
     * const taskChecklist = await prisma.taskChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskChecklistClient<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskChecklistFindFirstArgs} args - Arguments to find a TaskChecklist
     * @example
     * // Get one TaskChecklist
     * const taskChecklist = await prisma.taskChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskChecklistFindFirstArgs>(args?: SelectSubset<T, TaskChecklistFindFirstArgs<ExtArgs>>): Prisma__TaskChecklistClient<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskChecklistFindFirstOrThrowArgs} args - Arguments to find a TaskChecklist
     * @example
     * // Get one TaskChecklist
     * const taskChecklist = await prisma.taskChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskChecklistClient<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskChecklists
     * const taskChecklists = await prisma.taskChecklist.findMany()
     * 
     * // Get first 10 TaskChecklists
     * const taskChecklists = await prisma.taskChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskChecklistWithIdOnly = await prisma.taskChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskChecklistFindManyArgs>(args?: SelectSubset<T, TaskChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskChecklist.
     * @param {TaskChecklistCreateArgs} args - Arguments to create a TaskChecklist.
     * @example
     * // Create one TaskChecklist
     * const TaskChecklist = await prisma.taskChecklist.create({
     *   data: {
     *     // ... data to create a TaskChecklist
     *   }
     * })
     * 
     */
    create<T extends TaskChecklistCreateArgs>(args: SelectSubset<T, TaskChecklistCreateArgs<ExtArgs>>): Prisma__TaskChecklistClient<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskChecklists.
     * @param {TaskChecklistCreateManyArgs} args - Arguments to create many TaskChecklists.
     * @example
     * // Create many TaskChecklists
     * const taskChecklist = await prisma.taskChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskChecklistCreateManyArgs>(args?: SelectSubset<T, TaskChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskChecklists and returns the data saved in the database.
     * @param {TaskChecklistCreateManyAndReturnArgs} args - Arguments to create many TaskChecklists.
     * @example
     * // Create many TaskChecklists
     * const taskChecklist = await prisma.taskChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskChecklists and only return the `id`
     * const taskChecklistWithIdOnly = await prisma.taskChecklist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskChecklist.
     * @param {TaskChecklistDeleteArgs} args - Arguments to delete one TaskChecklist.
     * @example
     * // Delete one TaskChecklist
     * const TaskChecklist = await prisma.taskChecklist.delete({
     *   where: {
     *     // ... filter to delete one TaskChecklist
     *   }
     * })
     * 
     */
    delete<T extends TaskChecklistDeleteArgs>(args: SelectSubset<T, TaskChecklistDeleteArgs<ExtArgs>>): Prisma__TaskChecklistClient<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskChecklist.
     * @param {TaskChecklistUpdateArgs} args - Arguments to update one TaskChecklist.
     * @example
     * // Update one TaskChecklist
     * const taskChecklist = await prisma.taskChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskChecklistUpdateArgs>(args: SelectSubset<T, TaskChecklistUpdateArgs<ExtArgs>>): Prisma__TaskChecklistClient<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskChecklists.
     * @param {TaskChecklistDeleteManyArgs} args - Arguments to filter TaskChecklists to delete.
     * @example
     * // Delete a few TaskChecklists
     * const { count } = await prisma.taskChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskChecklistDeleteManyArgs>(args?: SelectSubset<T, TaskChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskChecklists
     * const taskChecklist = await prisma.taskChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskChecklistUpdateManyArgs>(args: SelectSubset<T, TaskChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskChecklists and returns the data updated in the database.
     * @param {TaskChecklistUpdateManyAndReturnArgs} args - Arguments to update many TaskChecklists.
     * @example
     * // Update many TaskChecklists
     * const taskChecklist = await prisma.taskChecklist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskChecklists and only return the `id`
     * const taskChecklistWithIdOnly = await prisma.taskChecklist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskChecklistUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskChecklistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskChecklist.
     * @param {TaskChecklistUpsertArgs} args - Arguments to update or create a TaskChecklist.
     * @example
     * // Update or create a TaskChecklist
     * const taskChecklist = await prisma.taskChecklist.upsert({
     *   create: {
     *     // ... data to create a TaskChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskChecklist we want to update
     *   }
     * })
     */
    upsert<T extends TaskChecklistUpsertArgs>(args: SelectSubset<T, TaskChecklistUpsertArgs<ExtArgs>>): Prisma__TaskChecklistClient<$Result.GetResult<Prisma.$TaskChecklistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskChecklistCountArgs} args - Arguments to filter TaskChecklists to count.
     * @example
     * // Count the number of TaskChecklists
     * const count = await prisma.taskChecklist.count({
     *   where: {
     *     // ... the filter for the TaskChecklists we want to count
     *   }
     * })
    **/
    count<T extends TaskChecklistCountArgs>(
      args?: Subset<T, TaskChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskChecklistAggregateArgs>(args: Subset<T, TaskChecklistAggregateArgs>): Prisma.PrismaPromise<GetTaskChecklistAggregateType<T>>

    /**
     * Group by TaskChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskChecklistGroupByArgs['orderBy'] }
        : { orderBy?: TaskChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskChecklist model
   */
  readonly fields: TaskChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskChecklist model
   */
  interface TaskChecklistFieldRefs {
    readonly id: FieldRef<"TaskChecklist", 'String'>
    readonly title: FieldRef<"TaskChecklist", 'String'>
    readonly order: FieldRef<"TaskChecklist", 'Int'>
    readonly taskId: FieldRef<"TaskChecklist", 'String'>
    readonly done: FieldRef<"TaskChecklist", 'Boolean'>
    readonly doneAt: FieldRef<"TaskChecklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskChecklist findUnique
   */
  export type TaskChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    /**
     * Filter, which TaskChecklist to fetch.
     */
    where: TaskChecklistWhereUniqueInput
  }

  /**
   * TaskChecklist findUniqueOrThrow
   */
  export type TaskChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    /**
     * Filter, which TaskChecklist to fetch.
     */
    where: TaskChecklistWhereUniqueInput
  }

  /**
   * TaskChecklist findFirst
   */
  export type TaskChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    /**
     * Filter, which TaskChecklist to fetch.
     */
    where?: TaskChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskChecklists to fetch.
     */
    orderBy?: TaskChecklistOrderByWithRelationInput | TaskChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskChecklists.
     */
    cursor?: TaskChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskChecklists.
     */
    distinct?: TaskChecklistScalarFieldEnum | TaskChecklistScalarFieldEnum[]
  }

  /**
   * TaskChecklist findFirstOrThrow
   */
  export type TaskChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    /**
     * Filter, which TaskChecklist to fetch.
     */
    where?: TaskChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskChecklists to fetch.
     */
    orderBy?: TaskChecklistOrderByWithRelationInput | TaskChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskChecklists.
     */
    cursor?: TaskChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskChecklists.
     */
    distinct?: TaskChecklistScalarFieldEnum | TaskChecklistScalarFieldEnum[]
  }

  /**
   * TaskChecklist findMany
   */
  export type TaskChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    /**
     * Filter, which TaskChecklists to fetch.
     */
    where?: TaskChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskChecklists to fetch.
     */
    orderBy?: TaskChecklistOrderByWithRelationInput | TaskChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskChecklists.
     */
    cursor?: TaskChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskChecklists.
     */
    skip?: number
    distinct?: TaskChecklistScalarFieldEnum | TaskChecklistScalarFieldEnum[]
  }

  /**
   * TaskChecklist create
   */
  export type TaskChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskChecklist.
     */
    data: XOR<TaskChecklistCreateInput, TaskChecklistUncheckedCreateInput>
  }

  /**
   * TaskChecklist createMany
   */
  export type TaskChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskChecklists.
     */
    data: TaskChecklistCreateManyInput | TaskChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskChecklist createManyAndReturn
   */
  export type TaskChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * The data used to create many TaskChecklists.
     */
    data: TaskChecklistCreateManyInput | TaskChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskChecklist update
   */
  export type TaskChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskChecklist.
     */
    data: XOR<TaskChecklistUpdateInput, TaskChecklistUncheckedUpdateInput>
    /**
     * Choose, which TaskChecklist to update.
     */
    where: TaskChecklistWhereUniqueInput
  }

  /**
   * TaskChecklist updateMany
   */
  export type TaskChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskChecklists.
     */
    data: XOR<TaskChecklistUpdateManyMutationInput, TaskChecklistUncheckedUpdateManyInput>
    /**
     * Filter which TaskChecklists to update
     */
    where?: TaskChecklistWhereInput
    /**
     * Limit how many TaskChecklists to update.
     */
    limit?: number
  }

  /**
   * TaskChecklist updateManyAndReturn
   */
  export type TaskChecklistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * The data used to update TaskChecklists.
     */
    data: XOR<TaskChecklistUpdateManyMutationInput, TaskChecklistUncheckedUpdateManyInput>
    /**
     * Filter which TaskChecklists to update
     */
    where?: TaskChecklistWhereInput
    /**
     * Limit how many TaskChecklists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskChecklist upsert
   */
  export type TaskChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskChecklist to update in case it exists.
     */
    where: TaskChecklistWhereUniqueInput
    /**
     * In case the TaskChecklist found by the `where` argument doesn't exist, create a new TaskChecklist with this data.
     */
    create: XOR<TaskChecklistCreateInput, TaskChecklistUncheckedCreateInput>
    /**
     * In case the TaskChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskChecklistUpdateInput, TaskChecklistUncheckedUpdateInput>
  }

  /**
   * TaskChecklist delete
   */
  export type TaskChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
    /**
     * Filter which TaskChecklist to delete.
     */
    where: TaskChecklistWhereUniqueInput
  }

  /**
   * TaskChecklist deleteMany
   */
  export type TaskChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskChecklists to delete
     */
    where?: TaskChecklistWhereInput
    /**
     * Limit how many TaskChecklists to delete.
     */
    limit?: number
  }

  /**
   * TaskChecklist without action
   */
  export type TaskChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskChecklist
     */
    select?: TaskChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskChecklist
     */
    omit?: TaskChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskChecklistInclude<ExtArgs> | null
  }


  /**
   * Model TaskPoint
   */

  export type AggregateTaskPoint = {
    _count: TaskPointCountAggregateOutputType | null
    _avg: TaskPointAvgAggregateOutputType | null
    _sum: TaskPointSumAggregateOutputType | null
    _min: TaskPointMinAggregateOutputType | null
    _max: TaskPointMaxAggregateOutputType | null
  }

  export type TaskPointAvgAggregateOutputType = {
    point: number | null
  }

  export type TaskPointSumAggregateOutputType = {
    point: number | null
  }

  export type TaskPointMinAggregateOutputType = {
    id: string | null
    point: number | null
    projectId: string | null
    icon: string | null
  }

  export type TaskPointMaxAggregateOutputType = {
    id: string | null
    point: number | null
    projectId: string | null
    icon: string | null
  }

  export type TaskPointCountAggregateOutputType = {
    id: number
    point: number
    projectId: number
    icon: number
    _all: number
  }


  export type TaskPointAvgAggregateInputType = {
    point?: true
  }

  export type TaskPointSumAggregateInputType = {
    point?: true
  }

  export type TaskPointMinAggregateInputType = {
    id?: true
    point?: true
    projectId?: true
    icon?: true
  }

  export type TaskPointMaxAggregateInputType = {
    id?: true
    point?: true
    projectId?: true
    icon?: true
  }

  export type TaskPointCountAggregateInputType = {
    id?: true
    point?: true
    projectId?: true
    icon?: true
    _all?: true
  }

  export type TaskPointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskPoint to aggregate.
     */
    where?: TaskPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskPoints to fetch.
     */
    orderBy?: TaskPointOrderByWithRelationInput | TaskPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskPoints
    **/
    _count?: true | TaskPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskPointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskPointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskPointMaxAggregateInputType
  }

  export type GetTaskPointAggregateType<T extends TaskPointAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskPoint[P]>
      : GetScalarType<T[P], AggregateTaskPoint[P]>
  }




  export type TaskPointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskPointWhereInput
    orderBy?: TaskPointOrderByWithAggregationInput | TaskPointOrderByWithAggregationInput[]
    by: TaskPointScalarFieldEnum[] | TaskPointScalarFieldEnum
    having?: TaskPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskPointCountAggregateInputType | true
    _avg?: TaskPointAvgAggregateInputType
    _sum?: TaskPointSumAggregateInputType
    _min?: TaskPointMinAggregateInputType
    _max?: TaskPointMaxAggregateInputType
  }

  export type TaskPointGroupByOutputType = {
    id: string
    point: number
    projectId: string
    icon: string | null
    _count: TaskPointCountAggregateOutputType | null
    _avg: TaskPointAvgAggregateOutputType | null
    _sum: TaskPointSumAggregateOutputType | null
    _min: TaskPointMinAggregateOutputType | null
    _max: TaskPointMaxAggregateOutputType | null
  }

  type GetTaskPointGroupByPayload<T extends TaskPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskPointGroupByOutputType[P]>
            : GetScalarType<T[P], TaskPointGroupByOutputType[P]>
        }
      >
    >


  export type TaskPointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    point?: boolean
    projectId?: boolean
    icon?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskPoint"]>

  export type TaskPointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    point?: boolean
    projectId?: boolean
    icon?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskPoint"]>

  export type TaskPointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    point?: boolean
    projectId?: boolean
    icon?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskPoint"]>

  export type TaskPointSelectScalar = {
    id?: boolean
    point?: boolean
    projectId?: boolean
    icon?: boolean
  }

  export type TaskPointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "point" | "projectId" | "icon", ExtArgs["result"]["taskPoint"]>
  export type TaskPointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TaskPointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TaskPointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TaskPointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskPoint"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      point: number
      projectId: string
      icon: string | null
    }, ExtArgs["result"]["taskPoint"]>
    composites: {}
  }

  type TaskPointGetPayload<S extends boolean | null | undefined | TaskPointDefaultArgs> = $Result.GetResult<Prisma.$TaskPointPayload, S>

  type TaskPointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskPointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskPointCountAggregateInputType | true
    }

  export interface TaskPointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskPoint'], meta: { name: 'TaskPoint' } }
    /**
     * Find zero or one TaskPoint that matches the filter.
     * @param {TaskPointFindUniqueArgs} args - Arguments to find a TaskPoint
     * @example
     * // Get one TaskPoint
     * const taskPoint = await prisma.taskPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskPointFindUniqueArgs>(args: SelectSubset<T, TaskPointFindUniqueArgs<ExtArgs>>): Prisma__TaskPointClient<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskPoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskPointFindUniqueOrThrowArgs} args - Arguments to find a TaskPoint
     * @example
     * // Get one TaskPoint
     * const taskPoint = await prisma.taskPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskPointFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskPointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskPointClient<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPointFindFirstArgs} args - Arguments to find a TaskPoint
     * @example
     * // Get one TaskPoint
     * const taskPoint = await prisma.taskPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskPointFindFirstArgs>(args?: SelectSubset<T, TaskPointFindFirstArgs<ExtArgs>>): Prisma__TaskPointClient<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskPoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPointFindFirstOrThrowArgs} args - Arguments to find a TaskPoint
     * @example
     * // Get one TaskPoint
     * const taskPoint = await prisma.taskPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskPointFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskPointFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskPointClient<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskPoints
     * const taskPoints = await prisma.taskPoint.findMany()
     * 
     * // Get first 10 TaskPoints
     * const taskPoints = await prisma.taskPoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskPointWithIdOnly = await prisma.taskPoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskPointFindManyArgs>(args?: SelectSubset<T, TaskPointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskPoint.
     * @param {TaskPointCreateArgs} args - Arguments to create a TaskPoint.
     * @example
     * // Create one TaskPoint
     * const TaskPoint = await prisma.taskPoint.create({
     *   data: {
     *     // ... data to create a TaskPoint
     *   }
     * })
     * 
     */
    create<T extends TaskPointCreateArgs>(args: SelectSubset<T, TaskPointCreateArgs<ExtArgs>>): Prisma__TaskPointClient<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskPoints.
     * @param {TaskPointCreateManyArgs} args - Arguments to create many TaskPoints.
     * @example
     * // Create many TaskPoints
     * const taskPoint = await prisma.taskPoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskPointCreateManyArgs>(args?: SelectSubset<T, TaskPointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskPoints and returns the data saved in the database.
     * @param {TaskPointCreateManyAndReturnArgs} args - Arguments to create many TaskPoints.
     * @example
     * // Create many TaskPoints
     * const taskPoint = await prisma.taskPoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskPoints and only return the `id`
     * const taskPointWithIdOnly = await prisma.taskPoint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskPointCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskPointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskPoint.
     * @param {TaskPointDeleteArgs} args - Arguments to delete one TaskPoint.
     * @example
     * // Delete one TaskPoint
     * const TaskPoint = await prisma.taskPoint.delete({
     *   where: {
     *     // ... filter to delete one TaskPoint
     *   }
     * })
     * 
     */
    delete<T extends TaskPointDeleteArgs>(args: SelectSubset<T, TaskPointDeleteArgs<ExtArgs>>): Prisma__TaskPointClient<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskPoint.
     * @param {TaskPointUpdateArgs} args - Arguments to update one TaskPoint.
     * @example
     * // Update one TaskPoint
     * const taskPoint = await prisma.taskPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskPointUpdateArgs>(args: SelectSubset<T, TaskPointUpdateArgs<ExtArgs>>): Prisma__TaskPointClient<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskPoints.
     * @param {TaskPointDeleteManyArgs} args - Arguments to filter TaskPoints to delete.
     * @example
     * // Delete a few TaskPoints
     * const { count } = await prisma.taskPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskPointDeleteManyArgs>(args?: SelectSubset<T, TaskPointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskPoints
     * const taskPoint = await prisma.taskPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskPointUpdateManyArgs>(args: SelectSubset<T, TaskPointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskPoints and returns the data updated in the database.
     * @param {TaskPointUpdateManyAndReturnArgs} args - Arguments to update many TaskPoints.
     * @example
     * // Update many TaskPoints
     * const taskPoint = await prisma.taskPoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskPoints and only return the `id`
     * const taskPointWithIdOnly = await prisma.taskPoint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskPointUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskPointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskPoint.
     * @param {TaskPointUpsertArgs} args - Arguments to update or create a TaskPoint.
     * @example
     * // Update or create a TaskPoint
     * const taskPoint = await prisma.taskPoint.upsert({
     *   create: {
     *     // ... data to create a TaskPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskPoint we want to update
     *   }
     * })
     */
    upsert<T extends TaskPointUpsertArgs>(args: SelectSubset<T, TaskPointUpsertArgs<ExtArgs>>): Prisma__TaskPointClient<$Result.GetResult<Prisma.$TaskPointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPointCountArgs} args - Arguments to filter TaskPoints to count.
     * @example
     * // Count the number of TaskPoints
     * const count = await prisma.taskPoint.count({
     *   where: {
     *     // ... the filter for the TaskPoints we want to count
     *   }
     * })
    **/
    count<T extends TaskPointCountArgs>(
      args?: Subset<T, TaskPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskPointAggregateArgs>(args: Subset<T, TaskPointAggregateArgs>): Prisma.PrismaPromise<GetTaskPointAggregateType<T>>

    /**
     * Group by TaskPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskPointGroupByArgs['orderBy'] }
        : { orderBy?: TaskPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskPoint model
   */
  readonly fields: TaskPointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskPointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskPoint model
   */
  interface TaskPointFieldRefs {
    readonly id: FieldRef<"TaskPoint", 'String'>
    readonly point: FieldRef<"TaskPoint", 'Int'>
    readonly projectId: FieldRef<"TaskPoint", 'String'>
    readonly icon: FieldRef<"TaskPoint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskPoint findUnique
   */
  export type TaskPointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    /**
     * Filter, which TaskPoint to fetch.
     */
    where: TaskPointWhereUniqueInput
  }

  /**
   * TaskPoint findUniqueOrThrow
   */
  export type TaskPointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    /**
     * Filter, which TaskPoint to fetch.
     */
    where: TaskPointWhereUniqueInput
  }

  /**
   * TaskPoint findFirst
   */
  export type TaskPointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    /**
     * Filter, which TaskPoint to fetch.
     */
    where?: TaskPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskPoints to fetch.
     */
    orderBy?: TaskPointOrderByWithRelationInput | TaskPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskPoints.
     */
    cursor?: TaskPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskPoints.
     */
    distinct?: TaskPointScalarFieldEnum | TaskPointScalarFieldEnum[]
  }

  /**
   * TaskPoint findFirstOrThrow
   */
  export type TaskPointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    /**
     * Filter, which TaskPoint to fetch.
     */
    where?: TaskPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskPoints to fetch.
     */
    orderBy?: TaskPointOrderByWithRelationInput | TaskPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskPoints.
     */
    cursor?: TaskPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskPoints.
     */
    distinct?: TaskPointScalarFieldEnum | TaskPointScalarFieldEnum[]
  }

  /**
   * TaskPoint findMany
   */
  export type TaskPointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    /**
     * Filter, which TaskPoints to fetch.
     */
    where?: TaskPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskPoints to fetch.
     */
    orderBy?: TaskPointOrderByWithRelationInput | TaskPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskPoints.
     */
    cursor?: TaskPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskPoints.
     */
    skip?: number
    distinct?: TaskPointScalarFieldEnum | TaskPointScalarFieldEnum[]
  }

  /**
   * TaskPoint create
   */
  export type TaskPointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskPoint.
     */
    data: XOR<TaskPointCreateInput, TaskPointUncheckedCreateInput>
  }

  /**
   * TaskPoint createMany
   */
  export type TaskPointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskPoints.
     */
    data: TaskPointCreateManyInput | TaskPointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskPoint createManyAndReturn
   */
  export type TaskPointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * The data used to create many TaskPoints.
     */
    data: TaskPointCreateManyInput | TaskPointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskPoint update
   */
  export type TaskPointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskPoint.
     */
    data: XOR<TaskPointUpdateInput, TaskPointUncheckedUpdateInput>
    /**
     * Choose, which TaskPoint to update.
     */
    where: TaskPointWhereUniqueInput
  }

  /**
   * TaskPoint updateMany
   */
  export type TaskPointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskPoints.
     */
    data: XOR<TaskPointUpdateManyMutationInput, TaskPointUncheckedUpdateManyInput>
    /**
     * Filter which TaskPoints to update
     */
    where?: TaskPointWhereInput
    /**
     * Limit how many TaskPoints to update.
     */
    limit?: number
  }

  /**
   * TaskPoint updateManyAndReturn
   */
  export type TaskPointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * The data used to update TaskPoints.
     */
    data: XOR<TaskPointUpdateManyMutationInput, TaskPointUncheckedUpdateManyInput>
    /**
     * Filter which TaskPoints to update
     */
    where?: TaskPointWhereInput
    /**
     * Limit how many TaskPoints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskPoint upsert
   */
  export type TaskPointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskPoint to update in case it exists.
     */
    where: TaskPointWhereUniqueInput
    /**
     * In case the TaskPoint found by the `where` argument doesn't exist, create a new TaskPoint with this data.
     */
    create: XOR<TaskPointCreateInput, TaskPointUncheckedCreateInput>
    /**
     * In case the TaskPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskPointUpdateInput, TaskPointUncheckedUpdateInput>
  }

  /**
   * TaskPoint delete
   */
  export type TaskPointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
    /**
     * Filter which TaskPoint to delete.
     */
    where: TaskPointWhereUniqueInput
  }

  /**
   * TaskPoint deleteMany
   */
  export type TaskPointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskPoints to delete
     */
    where?: TaskPointWhereInput
    /**
     * Limit how many TaskPoints to delete.
     */
    limit?: number
  }

  /**
   * TaskPoint without action
   */
  export type TaskPointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPoint
     */
    select?: TaskPointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPoint
     */
    omit?: TaskPointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPointInclude<ExtArgs> | null
  }


  /**
   * Model TaskAutomation
   */

  export type AggregateTaskAutomation = {
    _count: TaskAutomationCountAggregateOutputType | null
    _min: TaskAutomationMinAggregateOutputType | null
    _max: TaskAutomationMaxAggregateOutputType | null
  }

  export type TaskAutomationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    projectId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TaskAutomationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    projectId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TaskAutomationCountAggregateOutputType = {
    id: number
    organizationId: number
    projectId: number
    when: number
    then: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type TaskAutomationMinAggregateInputType = {
    id?: true
    organizationId?: true
    projectId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TaskAutomationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    projectId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TaskAutomationCountAggregateInputType = {
    id?: true
    organizationId?: true
    projectId?: true
    when?: true
    then?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type TaskAutomationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAutomation to aggregate.
     */
    where?: TaskAutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAutomations to fetch.
     */
    orderBy?: TaskAutomationOrderByWithRelationInput | TaskAutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAutomations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAutomations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAutomations
    **/
    _count?: true | TaskAutomationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAutomationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAutomationMaxAggregateInputType
  }

  export type GetTaskAutomationAggregateType<T extends TaskAutomationAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAutomation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAutomation[P]>
      : GetScalarType<T[P], AggregateTaskAutomation[P]>
  }




  export type TaskAutomationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAutomationWhereInput
    orderBy?: TaskAutomationOrderByWithAggregationInput | TaskAutomationOrderByWithAggregationInput[]
    by: TaskAutomationScalarFieldEnum[] | TaskAutomationScalarFieldEnum
    having?: TaskAutomationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAutomationCountAggregateInputType | true
    _min?: TaskAutomationMinAggregateInputType
    _max?: TaskAutomationMaxAggregateInputType
  }

  export type TaskAutomationGroupByOutputType = {
    id: string
    organizationId: string
    projectId: string
    when: JsonValue
    then: JsonValue
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: TaskAutomationCountAggregateOutputType | null
    _min: TaskAutomationMinAggregateOutputType | null
    _max: TaskAutomationMaxAggregateOutputType | null
  }

  type GetTaskAutomationGroupByPayload<T extends TaskAutomationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAutomationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAutomationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAutomationGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAutomationGroupByOutputType[P]>
        }
      >
    >


  export type TaskAutomationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    when?: boolean
    then?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAutomation"]>

  export type TaskAutomationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    when?: boolean
    then?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAutomation"]>

  export type TaskAutomationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    when?: boolean
    then?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAutomation"]>

  export type TaskAutomationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    when?: boolean
    then?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type TaskAutomationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "projectId" | "when" | "then" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["taskAutomation"]>
  export type TaskAutomationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TaskAutomationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TaskAutomationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TaskAutomationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAutomation"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      projectId: string
      when: Prisma.JsonValue
      then: Prisma.JsonValue
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["taskAutomation"]>
    composites: {}
  }

  type TaskAutomationGetPayload<S extends boolean | null | undefined | TaskAutomationDefaultArgs> = $Result.GetResult<Prisma.$TaskAutomationPayload, S>

  type TaskAutomationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAutomationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAutomationCountAggregateInputType | true
    }

  export interface TaskAutomationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAutomation'], meta: { name: 'TaskAutomation' } }
    /**
     * Find zero or one TaskAutomation that matches the filter.
     * @param {TaskAutomationFindUniqueArgs} args - Arguments to find a TaskAutomation
     * @example
     * // Get one TaskAutomation
     * const taskAutomation = await prisma.taskAutomation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAutomationFindUniqueArgs>(args: SelectSubset<T, TaskAutomationFindUniqueArgs<ExtArgs>>): Prisma__TaskAutomationClient<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskAutomation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAutomationFindUniqueOrThrowArgs} args - Arguments to find a TaskAutomation
     * @example
     * // Get one TaskAutomation
     * const taskAutomation = await prisma.taskAutomation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAutomationFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAutomationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAutomationClient<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAutomation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAutomationFindFirstArgs} args - Arguments to find a TaskAutomation
     * @example
     * // Get one TaskAutomation
     * const taskAutomation = await prisma.taskAutomation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAutomationFindFirstArgs>(args?: SelectSubset<T, TaskAutomationFindFirstArgs<ExtArgs>>): Prisma__TaskAutomationClient<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAutomation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAutomationFindFirstOrThrowArgs} args - Arguments to find a TaskAutomation
     * @example
     * // Get one TaskAutomation
     * const taskAutomation = await prisma.taskAutomation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAutomationFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAutomationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAutomationClient<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskAutomations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAutomationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAutomations
     * const taskAutomations = await prisma.taskAutomation.findMany()
     * 
     * // Get first 10 TaskAutomations
     * const taskAutomations = await prisma.taskAutomation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAutomationWithIdOnly = await prisma.taskAutomation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAutomationFindManyArgs>(args?: SelectSubset<T, TaskAutomationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskAutomation.
     * @param {TaskAutomationCreateArgs} args - Arguments to create a TaskAutomation.
     * @example
     * // Create one TaskAutomation
     * const TaskAutomation = await prisma.taskAutomation.create({
     *   data: {
     *     // ... data to create a TaskAutomation
     *   }
     * })
     * 
     */
    create<T extends TaskAutomationCreateArgs>(args: SelectSubset<T, TaskAutomationCreateArgs<ExtArgs>>): Prisma__TaskAutomationClient<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskAutomations.
     * @param {TaskAutomationCreateManyArgs} args - Arguments to create many TaskAutomations.
     * @example
     * // Create many TaskAutomations
     * const taskAutomation = await prisma.taskAutomation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAutomationCreateManyArgs>(args?: SelectSubset<T, TaskAutomationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAutomations and returns the data saved in the database.
     * @param {TaskAutomationCreateManyAndReturnArgs} args - Arguments to create many TaskAutomations.
     * @example
     * // Create many TaskAutomations
     * const taskAutomation = await prisma.taskAutomation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAutomations and only return the `id`
     * const taskAutomationWithIdOnly = await prisma.taskAutomation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAutomationCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAutomationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskAutomation.
     * @param {TaskAutomationDeleteArgs} args - Arguments to delete one TaskAutomation.
     * @example
     * // Delete one TaskAutomation
     * const TaskAutomation = await prisma.taskAutomation.delete({
     *   where: {
     *     // ... filter to delete one TaskAutomation
     *   }
     * })
     * 
     */
    delete<T extends TaskAutomationDeleteArgs>(args: SelectSubset<T, TaskAutomationDeleteArgs<ExtArgs>>): Prisma__TaskAutomationClient<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskAutomation.
     * @param {TaskAutomationUpdateArgs} args - Arguments to update one TaskAutomation.
     * @example
     * // Update one TaskAutomation
     * const taskAutomation = await prisma.taskAutomation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAutomationUpdateArgs>(args: SelectSubset<T, TaskAutomationUpdateArgs<ExtArgs>>): Prisma__TaskAutomationClient<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskAutomations.
     * @param {TaskAutomationDeleteManyArgs} args - Arguments to filter TaskAutomations to delete.
     * @example
     * // Delete a few TaskAutomations
     * const { count } = await prisma.taskAutomation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAutomationDeleteManyArgs>(args?: SelectSubset<T, TaskAutomationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAutomations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAutomationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAutomations
     * const taskAutomation = await prisma.taskAutomation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAutomationUpdateManyArgs>(args: SelectSubset<T, TaskAutomationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAutomations and returns the data updated in the database.
     * @param {TaskAutomationUpdateManyAndReturnArgs} args - Arguments to update many TaskAutomations.
     * @example
     * // Update many TaskAutomations
     * const taskAutomation = await prisma.taskAutomation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskAutomations and only return the `id`
     * const taskAutomationWithIdOnly = await prisma.taskAutomation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskAutomationUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskAutomationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskAutomation.
     * @param {TaskAutomationUpsertArgs} args - Arguments to update or create a TaskAutomation.
     * @example
     * // Update or create a TaskAutomation
     * const taskAutomation = await prisma.taskAutomation.upsert({
     *   create: {
     *     // ... data to create a TaskAutomation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAutomation we want to update
     *   }
     * })
     */
    upsert<T extends TaskAutomationUpsertArgs>(args: SelectSubset<T, TaskAutomationUpsertArgs<ExtArgs>>): Prisma__TaskAutomationClient<$Result.GetResult<Prisma.$TaskAutomationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskAutomations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAutomationCountArgs} args - Arguments to filter TaskAutomations to count.
     * @example
     * // Count the number of TaskAutomations
     * const count = await prisma.taskAutomation.count({
     *   where: {
     *     // ... the filter for the TaskAutomations we want to count
     *   }
     * })
    **/
    count<T extends TaskAutomationCountArgs>(
      args?: Subset<T, TaskAutomationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAutomationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAutomation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAutomationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAutomationAggregateArgs>(args: Subset<T, TaskAutomationAggregateArgs>): Prisma.PrismaPromise<GetTaskAutomationAggregateType<T>>

    /**
     * Group by TaskAutomation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAutomationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAutomationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAutomationGroupByArgs['orderBy'] }
        : { orderBy?: TaskAutomationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAutomationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAutomationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAutomation model
   */
  readonly fields: TaskAutomationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAutomation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAutomationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAutomation model
   */
  interface TaskAutomationFieldRefs {
    readonly id: FieldRef<"TaskAutomation", 'String'>
    readonly organizationId: FieldRef<"TaskAutomation", 'String'>
    readonly projectId: FieldRef<"TaskAutomation", 'String'>
    readonly when: FieldRef<"TaskAutomation", 'Json'>
    readonly then: FieldRef<"TaskAutomation", 'Json'>
    readonly createdAt: FieldRef<"TaskAutomation", 'DateTime'>
    readonly createdBy: FieldRef<"TaskAutomation", 'String'>
    readonly updatedAt: FieldRef<"TaskAutomation", 'DateTime'>
    readonly updatedBy: FieldRef<"TaskAutomation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskAutomation findUnique
   */
  export type TaskAutomationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    /**
     * Filter, which TaskAutomation to fetch.
     */
    where: TaskAutomationWhereUniqueInput
  }

  /**
   * TaskAutomation findUniqueOrThrow
   */
  export type TaskAutomationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    /**
     * Filter, which TaskAutomation to fetch.
     */
    where: TaskAutomationWhereUniqueInput
  }

  /**
   * TaskAutomation findFirst
   */
  export type TaskAutomationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    /**
     * Filter, which TaskAutomation to fetch.
     */
    where?: TaskAutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAutomations to fetch.
     */
    orderBy?: TaskAutomationOrderByWithRelationInput | TaskAutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAutomations.
     */
    cursor?: TaskAutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAutomations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAutomations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAutomations.
     */
    distinct?: TaskAutomationScalarFieldEnum | TaskAutomationScalarFieldEnum[]
  }

  /**
   * TaskAutomation findFirstOrThrow
   */
  export type TaskAutomationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    /**
     * Filter, which TaskAutomation to fetch.
     */
    where?: TaskAutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAutomations to fetch.
     */
    orderBy?: TaskAutomationOrderByWithRelationInput | TaskAutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAutomations.
     */
    cursor?: TaskAutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAutomations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAutomations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAutomations.
     */
    distinct?: TaskAutomationScalarFieldEnum | TaskAutomationScalarFieldEnum[]
  }

  /**
   * TaskAutomation findMany
   */
  export type TaskAutomationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    /**
     * Filter, which TaskAutomations to fetch.
     */
    where?: TaskAutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAutomations to fetch.
     */
    orderBy?: TaskAutomationOrderByWithRelationInput | TaskAutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAutomations.
     */
    cursor?: TaskAutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAutomations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAutomations.
     */
    skip?: number
    distinct?: TaskAutomationScalarFieldEnum | TaskAutomationScalarFieldEnum[]
  }

  /**
   * TaskAutomation create
   */
  export type TaskAutomationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAutomation.
     */
    data: XOR<TaskAutomationCreateInput, TaskAutomationUncheckedCreateInput>
  }

  /**
   * TaskAutomation createMany
   */
  export type TaskAutomationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAutomations.
     */
    data: TaskAutomationCreateManyInput | TaskAutomationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAutomation createManyAndReturn
   */
  export type TaskAutomationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * The data used to create many TaskAutomations.
     */
    data: TaskAutomationCreateManyInput | TaskAutomationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAutomation update
   */
  export type TaskAutomationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAutomation.
     */
    data: XOR<TaskAutomationUpdateInput, TaskAutomationUncheckedUpdateInput>
    /**
     * Choose, which TaskAutomation to update.
     */
    where: TaskAutomationWhereUniqueInput
  }

  /**
   * TaskAutomation updateMany
   */
  export type TaskAutomationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAutomations.
     */
    data: XOR<TaskAutomationUpdateManyMutationInput, TaskAutomationUncheckedUpdateManyInput>
    /**
     * Filter which TaskAutomations to update
     */
    where?: TaskAutomationWhereInput
    /**
     * Limit how many TaskAutomations to update.
     */
    limit?: number
  }

  /**
   * TaskAutomation updateManyAndReturn
   */
  export type TaskAutomationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * The data used to update TaskAutomations.
     */
    data: XOR<TaskAutomationUpdateManyMutationInput, TaskAutomationUncheckedUpdateManyInput>
    /**
     * Filter which TaskAutomations to update
     */
    where?: TaskAutomationWhereInput
    /**
     * Limit how many TaskAutomations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAutomation upsert
   */
  export type TaskAutomationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAutomation to update in case it exists.
     */
    where: TaskAutomationWhereUniqueInput
    /**
     * In case the TaskAutomation found by the `where` argument doesn't exist, create a new TaskAutomation with this data.
     */
    create: XOR<TaskAutomationCreateInput, TaskAutomationUncheckedCreateInput>
    /**
     * In case the TaskAutomation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAutomationUpdateInput, TaskAutomationUncheckedUpdateInput>
  }

  /**
   * TaskAutomation delete
   */
  export type TaskAutomationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
    /**
     * Filter which TaskAutomation to delete.
     */
    where: TaskAutomationWhereUniqueInput
  }

  /**
   * TaskAutomation deleteMany
   */
  export type TaskAutomationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAutomations to delete
     */
    where?: TaskAutomationWhereInput
    /**
     * Limit how many TaskAutomations to delete.
     */
    limit?: number
  }

  /**
   * TaskAutomation without action
   */
  export type TaskAutomationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAutomation
     */
    select?: TaskAutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAutomation
     */
    omit?: TaskAutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAutomationInclude<ExtArgs> | null
  }


  /**
   * Model Vision
   */

  export type AggregateVision = {
    _count: VisionCountAggregateOutputType | null
    _avg: VisionAvgAggregateOutputType | null
    _sum: VisionSumAggregateOutputType | null
    _min: VisionMinAggregateOutputType | null
    _max: VisionMaxAggregateOutputType | null
  }

  export type VisionAvgAggregateOutputType = {
    progress: number | null
  }

  export type VisionSumAggregateOutputType = {
    progress: number | null
  }

  export type VisionMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    dueDate: Date | null
    progress: number | null
    projectId: string | null
    organizationId: string | null
    parentId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type VisionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    dueDate: Date | null
    progress: number | null
    projectId: string | null
    organizationId: string | null
    parentId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type VisionCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    dueDate: number
    progress: number
    projectId: number
    organizationId: number
    parentId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type VisionAvgAggregateInputType = {
    progress?: true
  }

  export type VisionSumAggregateInputType = {
    progress?: true
  }

  export type VisionMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    dueDate?: true
    progress?: true
    projectId?: true
    organizationId?: true
    parentId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type VisionMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    dueDate?: true
    progress?: true
    projectId?: true
    organizationId?: true
    parentId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type VisionCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    dueDate?: true
    progress?: true
    projectId?: true
    organizationId?: true
    parentId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type VisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vision to aggregate.
     */
    where?: VisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visions to fetch.
     */
    orderBy?: VisionOrderByWithRelationInput | VisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visions
    **/
    _count?: true | VisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisionMaxAggregateInputType
  }

  export type GetVisionAggregateType<T extends VisionAggregateArgs> = {
        [P in keyof T & keyof AggregateVision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVision[P]>
      : GetScalarType<T[P], AggregateVision[P]>
  }




  export type VisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisionWhereInput
    orderBy?: VisionOrderByWithAggregationInput | VisionOrderByWithAggregationInput[]
    by: VisionScalarFieldEnum[] | VisionScalarFieldEnum
    having?: VisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisionCountAggregateInputType | true
    _avg?: VisionAvgAggregateInputType
    _sum?: VisionSumAggregateInputType
    _min?: VisionMinAggregateInputType
    _max?: VisionMaxAggregateInputType
  }

  export type VisionGroupByOutputType = {
    id: string
    name: string
    startDate: Date | null
    dueDate: Date | null
    progress: number | null
    projectId: string | null
    organizationId: string | null
    parentId: string | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: VisionCountAggregateOutputType | null
    _avg: VisionAvgAggregateOutputType | null
    _sum: VisionSumAggregateOutputType | null
    _min: VisionMinAggregateOutputType | null
    _max: VisionMaxAggregateOutputType | null
  }

  type GetVisionGroupByPayload<T extends VisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisionGroupByOutputType[P]>
            : GetScalarType<T[P], VisionGroupByOutputType[P]>
        }
      >
    >


  export type VisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    dueDate?: boolean
    progress?: boolean
    projectId?: boolean
    organizationId?: boolean
    parentId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | Vision$projectArgs<ExtArgs>
    organization?: boolean | Vision$organizationArgs<ExtArgs>
    parent?: boolean | Vision$parentArgs<ExtArgs>
    children?: boolean | Vision$childrenArgs<ExtArgs>
    _count?: boolean | VisionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vision"]>

  export type VisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    dueDate?: boolean
    progress?: boolean
    projectId?: boolean
    organizationId?: boolean
    parentId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | Vision$projectArgs<ExtArgs>
    organization?: boolean | Vision$organizationArgs<ExtArgs>
    parent?: boolean | Vision$parentArgs<ExtArgs>
  }, ExtArgs["result"]["vision"]>

  export type VisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    dueDate?: boolean
    progress?: boolean
    projectId?: boolean
    organizationId?: boolean
    parentId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | Vision$projectArgs<ExtArgs>
    organization?: boolean | Vision$organizationArgs<ExtArgs>
    parent?: boolean | Vision$parentArgs<ExtArgs>
  }, ExtArgs["result"]["vision"]>

  export type VisionSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    dueDate?: boolean
    progress?: boolean
    projectId?: boolean
    organizationId?: boolean
    parentId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type VisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "dueDate" | "progress" | "projectId" | "organizationId" | "parentId" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["vision"]>
  export type VisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Vision$projectArgs<ExtArgs>
    organization?: boolean | Vision$organizationArgs<ExtArgs>
    parent?: boolean | Vision$parentArgs<ExtArgs>
    children?: boolean | Vision$childrenArgs<ExtArgs>
    _count?: boolean | VisionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Vision$projectArgs<ExtArgs>
    organization?: boolean | Vision$organizationArgs<ExtArgs>
    parent?: boolean | Vision$parentArgs<ExtArgs>
  }
  export type VisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Vision$projectArgs<ExtArgs>
    organization?: boolean | Vision$organizationArgs<ExtArgs>
    parent?: boolean | Vision$parentArgs<ExtArgs>
  }

  export type $VisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vision"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      parent: Prisma.$VisionPayload<ExtArgs> | null
      children: Prisma.$VisionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date | null
      dueDate: Date | null
      progress: number | null
      projectId: string | null
      organizationId: string | null
      parentId: string | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["vision"]>
    composites: {}
  }

  type VisionGetPayload<S extends boolean | null | undefined | VisionDefaultArgs> = $Result.GetResult<Prisma.$VisionPayload, S>

  type VisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisionCountAggregateInputType | true
    }

  export interface VisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vision'], meta: { name: 'Vision' } }
    /**
     * Find zero or one Vision that matches the filter.
     * @param {VisionFindUniqueArgs} args - Arguments to find a Vision
     * @example
     * // Get one Vision
     * const vision = await prisma.vision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisionFindUniqueArgs>(args: SelectSubset<T, VisionFindUniqueArgs<ExtArgs>>): Prisma__VisionClient<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisionFindUniqueOrThrowArgs} args - Arguments to find a Vision
     * @example
     * // Get one Vision
     * const vision = await prisma.vision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisionFindUniqueOrThrowArgs>(args: SelectSubset<T, VisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisionClient<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionFindFirstArgs} args - Arguments to find a Vision
     * @example
     * // Get one Vision
     * const vision = await prisma.vision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisionFindFirstArgs>(args?: SelectSubset<T, VisionFindFirstArgs<ExtArgs>>): Prisma__VisionClient<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionFindFirstOrThrowArgs} args - Arguments to find a Vision
     * @example
     * // Get one Vision
     * const vision = await prisma.vision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisionFindFirstOrThrowArgs>(args?: SelectSubset<T, VisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisionClient<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visions
     * const visions = await prisma.vision.findMany()
     * 
     * // Get first 10 Visions
     * const visions = await prisma.vision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visionWithIdOnly = await prisma.vision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisionFindManyArgs>(args?: SelectSubset<T, VisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vision.
     * @param {VisionCreateArgs} args - Arguments to create a Vision.
     * @example
     * // Create one Vision
     * const Vision = await prisma.vision.create({
     *   data: {
     *     // ... data to create a Vision
     *   }
     * })
     * 
     */
    create<T extends VisionCreateArgs>(args: SelectSubset<T, VisionCreateArgs<ExtArgs>>): Prisma__VisionClient<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visions.
     * @param {VisionCreateManyArgs} args - Arguments to create many Visions.
     * @example
     * // Create many Visions
     * const vision = await prisma.vision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisionCreateManyArgs>(args?: SelectSubset<T, VisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Visions and returns the data saved in the database.
     * @param {VisionCreateManyAndReturnArgs} args - Arguments to create many Visions.
     * @example
     * // Create many Visions
     * const vision = await prisma.vision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Visions and only return the `id`
     * const visionWithIdOnly = await prisma.vision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisionCreateManyAndReturnArgs>(args?: SelectSubset<T, VisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vision.
     * @param {VisionDeleteArgs} args - Arguments to delete one Vision.
     * @example
     * // Delete one Vision
     * const Vision = await prisma.vision.delete({
     *   where: {
     *     // ... filter to delete one Vision
     *   }
     * })
     * 
     */
    delete<T extends VisionDeleteArgs>(args: SelectSubset<T, VisionDeleteArgs<ExtArgs>>): Prisma__VisionClient<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vision.
     * @param {VisionUpdateArgs} args - Arguments to update one Vision.
     * @example
     * // Update one Vision
     * const vision = await prisma.vision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisionUpdateArgs>(args: SelectSubset<T, VisionUpdateArgs<ExtArgs>>): Prisma__VisionClient<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visions.
     * @param {VisionDeleteManyArgs} args - Arguments to filter Visions to delete.
     * @example
     * // Delete a few Visions
     * const { count } = await prisma.vision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisionDeleteManyArgs>(args?: SelectSubset<T, VisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visions
     * const vision = await prisma.vision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisionUpdateManyArgs>(args: SelectSubset<T, VisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visions and returns the data updated in the database.
     * @param {VisionUpdateManyAndReturnArgs} args - Arguments to update many Visions.
     * @example
     * // Update many Visions
     * const vision = await prisma.vision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Visions and only return the `id`
     * const visionWithIdOnly = await prisma.vision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisionUpdateManyAndReturnArgs>(args: SelectSubset<T, VisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vision.
     * @param {VisionUpsertArgs} args - Arguments to update or create a Vision.
     * @example
     * // Update or create a Vision
     * const vision = await prisma.vision.upsert({
     *   create: {
     *     // ... data to create a Vision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vision we want to update
     *   }
     * })
     */
    upsert<T extends VisionUpsertArgs>(args: SelectSubset<T, VisionUpsertArgs<ExtArgs>>): Prisma__VisionClient<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionCountArgs} args - Arguments to filter Visions to count.
     * @example
     * // Count the number of Visions
     * const count = await prisma.vision.count({
     *   where: {
     *     // ... the filter for the Visions we want to count
     *   }
     * })
    **/
    count<T extends VisionCountArgs>(
      args?: Subset<T, VisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisionAggregateArgs>(args: Subset<T, VisionAggregateArgs>): Prisma.PrismaPromise<GetVisionAggregateType<T>>

    /**
     * Group by Vision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisionGroupByArgs['orderBy'] }
        : { orderBy?: VisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vision model
   */
  readonly fields: VisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends Vision$projectArgs<ExtArgs> = {}>(args?: Subset<T, Vision$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organization<T extends Vision$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Vision$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends Vision$parentArgs<ExtArgs> = {}>(args?: Subset<T, Vision$parentArgs<ExtArgs>>): Prisma__VisionClient<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Vision$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Vision$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vision model
   */
  interface VisionFieldRefs {
    readonly id: FieldRef<"Vision", 'String'>
    readonly name: FieldRef<"Vision", 'String'>
    readonly startDate: FieldRef<"Vision", 'DateTime'>
    readonly dueDate: FieldRef<"Vision", 'DateTime'>
    readonly progress: FieldRef<"Vision", 'Int'>
    readonly projectId: FieldRef<"Vision", 'String'>
    readonly organizationId: FieldRef<"Vision", 'String'>
    readonly parentId: FieldRef<"Vision", 'String'>
    readonly createdAt: FieldRef<"Vision", 'DateTime'>
    readonly createdBy: FieldRef<"Vision", 'String'>
    readonly updatedAt: FieldRef<"Vision", 'DateTime'>
    readonly updatedBy: FieldRef<"Vision", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vision findUnique
   */
  export type VisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    /**
     * Filter, which Vision to fetch.
     */
    where: VisionWhereUniqueInput
  }

  /**
   * Vision findUniqueOrThrow
   */
  export type VisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    /**
     * Filter, which Vision to fetch.
     */
    where: VisionWhereUniqueInput
  }

  /**
   * Vision findFirst
   */
  export type VisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    /**
     * Filter, which Vision to fetch.
     */
    where?: VisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visions to fetch.
     */
    orderBy?: VisionOrderByWithRelationInput | VisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visions.
     */
    cursor?: VisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visions.
     */
    distinct?: VisionScalarFieldEnum | VisionScalarFieldEnum[]
  }

  /**
   * Vision findFirstOrThrow
   */
  export type VisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    /**
     * Filter, which Vision to fetch.
     */
    where?: VisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visions to fetch.
     */
    orderBy?: VisionOrderByWithRelationInput | VisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visions.
     */
    cursor?: VisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visions.
     */
    distinct?: VisionScalarFieldEnum | VisionScalarFieldEnum[]
  }

  /**
   * Vision findMany
   */
  export type VisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    /**
     * Filter, which Visions to fetch.
     */
    where?: VisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visions to fetch.
     */
    orderBy?: VisionOrderByWithRelationInput | VisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visions.
     */
    cursor?: VisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visions.
     */
    skip?: number
    distinct?: VisionScalarFieldEnum | VisionScalarFieldEnum[]
  }

  /**
   * Vision create
   */
  export type VisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    /**
     * The data needed to create a Vision.
     */
    data: XOR<VisionCreateInput, VisionUncheckedCreateInput>
  }

  /**
   * Vision createMany
   */
  export type VisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visions.
     */
    data: VisionCreateManyInput | VisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vision createManyAndReturn
   */
  export type VisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * The data used to create many Visions.
     */
    data: VisionCreateManyInput | VisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vision update
   */
  export type VisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    /**
     * The data needed to update a Vision.
     */
    data: XOR<VisionUpdateInput, VisionUncheckedUpdateInput>
    /**
     * Choose, which Vision to update.
     */
    where: VisionWhereUniqueInput
  }

  /**
   * Vision updateMany
   */
  export type VisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visions.
     */
    data: XOR<VisionUpdateManyMutationInput, VisionUncheckedUpdateManyInput>
    /**
     * Filter which Visions to update
     */
    where?: VisionWhereInput
    /**
     * Limit how many Visions to update.
     */
    limit?: number
  }

  /**
   * Vision updateManyAndReturn
   */
  export type VisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * The data used to update Visions.
     */
    data: XOR<VisionUpdateManyMutationInput, VisionUncheckedUpdateManyInput>
    /**
     * Filter which Visions to update
     */
    where?: VisionWhereInput
    /**
     * Limit how many Visions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vision upsert
   */
  export type VisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    /**
     * The filter to search for the Vision to update in case it exists.
     */
    where: VisionWhereUniqueInput
    /**
     * In case the Vision found by the `where` argument doesn't exist, create a new Vision with this data.
     */
    create: XOR<VisionCreateInput, VisionUncheckedCreateInput>
    /**
     * In case the Vision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisionUpdateInput, VisionUncheckedUpdateInput>
  }

  /**
   * Vision delete
   */
  export type VisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    /**
     * Filter which Vision to delete.
     */
    where: VisionWhereUniqueInput
  }

  /**
   * Vision deleteMany
   */
  export type VisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visions to delete
     */
    where?: VisionWhereInput
    /**
     * Limit how many Visions to delete.
     */
    limit?: number
  }

  /**
   * Vision.project
   */
  export type Vision$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Vision.organization
   */
  export type Vision$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Vision.parent
   */
  export type Vision$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    where?: VisionWhereInput
  }

  /**
   * Vision.children
   */
  export type Vision$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
    where?: VisionWhereInput
    orderBy?: VisionOrderByWithRelationInput | VisionOrderByWithRelationInput[]
    cursor?: VisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisionScalarFieldEnum | VisionScalarFieldEnum[]
  }

  /**
   * Vision without action
   */
  export type VisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vision
     */
    select?: VisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vision
     */
    omit?: VisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisionInclude<ExtArgs> | null
  }


  /**
   * Model Field
   */

  export type AggregateField = {
    _count: FieldCountAggregateOutputType | null
    _avg: FieldAvgAggregateOutputType | null
    _sum: FieldSumAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  export type FieldAvgAggregateOutputType = {
    width: number | null
    order: number | null
  }

  export type FieldSumAggregateOutputType = {
    width: number | null
    order: number | null
  }

  export type FieldMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    type: $Enums.FieldType | null
    icon: string | null
    hidden: boolean | null
    width: number | null
    order: number | null
    desc: string | null
  }

  export type FieldMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    type: $Enums.FieldType | null
    icon: string | null
    hidden: boolean | null
    width: number | null
    order: number | null
    desc: string | null
  }

  export type FieldCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    type: number
    icon: number
    hidden: number
    width: number
    order: number
    desc: number
    data: number
    config: number
    _all: number
  }


  export type FieldAvgAggregateInputType = {
    width?: true
    order?: true
  }

  export type FieldSumAggregateInputType = {
    width?: true
    order?: true
  }

  export type FieldMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    icon?: true
    hidden?: true
    width?: true
    order?: true
    desc?: true
  }

  export type FieldMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    icon?: true
    hidden?: true
    width?: true
    order?: true
    desc?: true
  }

  export type FieldCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    icon?: true
    hidden?: true
    width?: true
    order?: true
    desc?: true
    data?: true
    config?: true
    _all?: true
  }

  export type FieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Field to aggregate.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fields
    **/
    _count?: true | FieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldMaxAggregateInputType
  }

  export type GetFieldAggregateType<T extends FieldAggregateArgs> = {
        [P in keyof T & keyof AggregateField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateField[P]>
      : GetScalarType<T[P], AggregateField[P]>
  }




  export type FieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithAggregationInput | FieldOrderByWithAggregationInput[]
    by: FieldScalarFieldEnum[] | FieldScalarFieldEnum
    having?: FieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldCountAggregateInputType | true
    _avg?: FieldAvgAggregateInputType
    _sum?: FieldSumAggregateInputType
    _min?: FieldMinAggregateInputType
    _max?: FieldMaxAggregateInputType
  }

  export type FieldGroupByOutputType = {
    id: string
    projectId: string
    name: string
    type: $Enums.FieldType
    icon: string | null
    hidden: boolean
    width: number
    order: number
    desc: string | null
    data: JsonValue | null
    config: JsonValue | null
    _count: FieldCountAggregateOutputType | null
    _avg: FieldAvgAggregateOutputType | null
    _sum: FieldSumAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  type GetFieldGroupByPayload<T extends FieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldGroupByOutputType[P]>
            : GetScalarType<T[P], FieldGroupByOutputType[P]>
        }
      >
    >


  export type FieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    icon?: boolean
    hidden?: boolean
    width?: boolean
    order?: boolean
    desc?: boolean
    data?: boolean
    config?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["field"]>

  export type FieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    icon?: boolean
    hidden?: boolean
    width?: boolean
    order?: boolean
    desc?: boolean
    data?: boolean
    config?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["field"]>

  export type FieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    icon?: boolean
    hidden?: boolean
    width?: boolean
    order?: boolean
    desc?: boolean
    data?: boolean
    config?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["field"]>

  export type FieldSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    icon?: boolean
    hidden?: boolean
    width?: boolean
    order?: boolean
    desc?: boolean
    data?: boolean
    config?: boolean
  }

  export type FieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "type" | "icon" | "hidden" | "width" | "order" | "desc" | "data" | "config", ExtArgs["result"]["field"]>
  export type FieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type FieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type FieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $FieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Field"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      type: $Enums.FieldType
      icon: string | null
      hidden: boolean
      width: number
      order: number
      desc: string | null
      data: Prisma.JsonValue | null
      config: Prisma.JsonValue | null
    }, ExtArgs["result"]["field"]>
    composites: {}
  }

  type FieldGetPayload<S extends boolean | null | undefined | FieldDefaultArgs> = $Result.GetResult<Prisma.$FieldPayload, S>

  type FieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldCountAggregateInputType | true
    }

  export interface FieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Field'], meta: { name: 'Field' } }
    /**
     * Find zero or one Field that matches the filter.
     * @param {FieldFindUniqueArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldFindUniqueArgs>(args: SelectSubset<T, FieldFindUniqueArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Field that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldFindUniqueOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Field that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldFindFirstArgs>(args?: SelectSubset<T, FieldFindFirstArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Field that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fields
     * const fields = await prisma.field.findMany()
     * 
     * // Get first 10 Fields
     * const fields = await prisma.field.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldWithIdOnly = await prisma.field.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldFindManyArgs>(args?: SelectSubset<T, FieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Field.
     * @param {FieldCreateArgs} args - Arguments to create a Field.
     * @example
     * // Create one Field
     * const Field = await prisma.field.create({
     *   data: {
     *     // ... data to create a Field
     *   }
     * })
     * 
     */
    create<T extends FieldCreateArgs>(args: SelectSubset<T, FieldCreateArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fields.
     * @param {FieldCreateManyArgs} args - Arguments to create many Fields.
     * @example
     * // Create many Fields
     * const field = await prisma.field.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldCreateManyArgs>(args?: SelectSubset<T, FieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fields and returns the data saved in the database.
     * @param {FieldCreateManyAndReturnArgs} args - Arguments to create many Fields.
     * @example
     * // Create many Fields
     * const field = await prisma.field.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fields and only return the `id`
     * const fieldWithIdOnly = await prisma.field.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FieldCreateManyAndReturnArgs>(args?: SelectSubset<T, FieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Field.
     * @param {FieldDeleteArgs} args - Arguments to delete one Field.
     * @example
     * // Delete one Field
     * const Field = await prisma.field.delete({
     *   where: {
     *     // ... filter to delete one Field
     *   }
     * })
     * 
     */
    delete<T extends FieldDeleteArgs>(args: SelectSubset<T, FieldDeleteArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Field.
     * @param {FieldUpdateArgs} args - Arguments to update one Field.
     * @example
     * // Update one Field
     * const field = await prisma.field.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldUpdateArgs>(args: SelectSubset<T, FieldUpdateArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fields.
     * @param {FieldDeleteManyArgs} args - Arguments to filter Fields to delete.
     * @example
     * // Delete a few Fields
     * const { count } = await prisma.field.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldDeleteManyArgs>(args?: SelectSubset<T, FieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fields
     * const field = await prisma.field.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldUpdateManyArgs>(args: SelectSubset<T, FieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields and returns the data updated in the database.
     * @param {FieldUpdateManyAndReturnArgs} args - Arguments to update many Fields.
     * @example
     * // Update many Fields
     * const field = await prisma.field.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fields and only return the `id`
     * const fieldWithIdOnly = await prisma.field.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FieldUpdateManyAndReturnArgs>(args: SelectSubset<T, FieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Field.
     * @param {FieldUpsertArgs} args - Arguments to update or create a Field.
     * @example
     * // Update or create a Field
     * const field = await prisma.field.upsert({
     *   create: {
     *     // ... data to create a Field
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Field we want to update
     *   }
     * })
     */
    upsert<T extends FieldUpsertArgs>(args: SelectSubset<T, FieldUpsertArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldCountArgs} args - Arguments to filter Fields to count.
     * @example
     * // Count the number of Fields
     * const count = await prisma.field.count({
     *   where: {
     *     // ... the filter for the Fields we want to count
     *   }
     * })
    **/
    count<T extends FieldCountArgs>(
      args?: Subset<T, FieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldAggregateArgs>(args: Subset<T, FieldAggregateArgs>): Prisma.PrismaPromise<GetFieldAggregateType<T>>

    /**
     * Group by Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldGroupByArgs['orderBy'] }
        : { orderBy?: FieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Field model
   */
  readonly fields: FieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Field.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Field model
   */
  interface FieldFieldRefs {
    readonly id: FieldRef<"Field", 'String'>
    readonly projectId: FieldRef<"Field", 'String'>
    readonly name: FieldRef<"Field", 'String'>
    readonly type: FieldRef<"Field", 'FieldType'>
    readonly icon: FieldRef<"Field", 'String'>
    readonly hidden: FieldRef<"Field", 'Boolean'>
    readonly width: FieldRef<"Field", 'Int'>
    readonly order: FieldRef<"Field", 'Int'>
    readonly desc: FieldRef<"Field", 'String'>
    readonly data: FieldRef<"Field", 'Json'>
    readonly config: FieldRef<"Field", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Field findUnique
   */
  export type FieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findUniqueOrThrow
   */
  export type FieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findFirst
   */
  export type FieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findFirstOrThrow
   */
  export type FieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findMany
   */
  export type FieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Fields to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field create
   */
  export type FieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to create a Field.
     */
    data: XOR<FieldCreateInput, FieldUncheckedCreateInput>
  }

  /**
   * Field createMany
   */
  export type FieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fields.
     */
    data: FieldCreateManyInput | FieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Field createManyAndReturn
   */
  export type FieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * The data used to create many Fields.
     */
    data: FieldCreateManyInput | FieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Field update
   */
  export type FieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to update a Field.
     */
    data: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
    /**
     * Choose, which Field to update.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field updateMany
   */
  export type FieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fields.
     */
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyInput>
    /**
     * Filter which Fields to update
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to update.
     */
    limit?: number
  }

  /**
   * Field updateManyAndReturn
   */
  export type FieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * The data used to update Fields.
     */
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyInput>
    /**
     * Filter which Fields to update
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Field upsert
   */
  export type FieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The filter to search for the Field to update in case it exists.
     */
    where: FieldWhereUniqueInput
    /**
     * In case the Field found by the `where` argument doesn't exist, create a new Field with this data.
     */
    create: XOR<FieldCreateInput, FieldUncheckedCreateInput>
    /**
     * In case the Field was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
  }

  /**
   * Field delete
   */
  export type FieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter which Field to delete.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field deleteMany
   */
  export type FieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fields to delete
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to delete.
     */
    limit?: number
  }

  /**
   * Field without action
   */
  export type FieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
  }


  /**
   * Model Grid
   */

  export type AggregateGrid = {
    _count: GridCountAggregateOutputType | null
    _min: GridMinAggregateOutputType | null
    _max: GridMaxAggregateOutputType | null
  }

  export type GridMinAggregateOutputType = {
    id: string | null
    title: string | null
    cover: string | null
    projectId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type GridMaxAggregateOutputType = {
    id: string | null
    title: string | null
    cover: string | null
    projectId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type GridCountAggregateOutputType = {
    id: number
    title: number
    cover: number
    projectId: number
    customFields: number
    isDeleted: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type GridMinAggregateInputType = {
    id?: true
    title?: true
    cover?: true
    projectId?: true
    isDeleted?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type GridMaxAggregateInputType = {
    id?: true
    title?: true
    cover?: true
    projectId?: true
    isDeleted?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type GridCountAggregateInputType = {
    id?: true
    title?: true
    cover?: true
    projectId?: true
    customFields?: true
    isDeleted?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type GridAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grid to aggregate.
     */
    where?: GridWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grids to fetch.
     */
    orderBy?: GridOrderByWithRelationInput | GridOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GridWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grids
    **/
    _count?: true | GridCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GridMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GridMaxAggregateInputType
  }

  export type GetGridAggregateType<T extends GridAggregateArgs> = {
        [P in keyof T & keyof AggregateGrid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrid[P]>
      : GetScalarType<T[P], AggregateGrid[P]>
  }




  export type GridGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GridWhereInput
    orderBy?: GridOrderByWithAggregationInput | GridOrderByWithAggregationInput[]
    by: GridScalarFieldEnum[] | GridScalarFieldEnum
    having?: GridScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GridCountAggregateInputType | true
    _min?: GridMinAggregateInputType
    _max?: GridMaxAggregateInputType
  }

  export type GridGroupByOutputType = {
    id: string
    title: string
    cover: string | null
    projectId: string
    customFields: JsonValue | null
    isDeleted: boolean | null
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: GridCountAggregateOutputType | null
    _min: GridMinAggregateOutputType | null
    _max: GridMaxAggregateOutputType | null
  }

  type GetGridGroupByPayload<T extends GridGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GridGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GridGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GridGroupByOutputType[P]>
            : GetScalarType<T[P], GridGroupByOutputType[P]>
        }
      >
    >


  export type GridSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    cover?: boolean
    projectId?: boolean
    customFields?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grid"]>

  export type GridSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    cover?: boolean
    projectId?: boolean
    customFields?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grid"]>

  export type GridSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    cover?: boolean
    projectId?: boolean
    customFields?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grid"]>

  export type GridSelectScalar = {
    id?: boolean
    title?: boolean
    cover?: boolean
    projectId?: boolean
    customFields?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type GridOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "cover" | "projectId" | "customFields" | "isDeleted" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["grid"]>
  export type GridInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type GridIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type GridIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $GridPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grid"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      cover: string | null
      projectId: string
      customFields: Prisma.JsonValue | null
      isDeleted: boolean | null
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["grid"]>
    composites: {}
  }

  type GridGetPayload<S extends boolean | null | undefined | GridDefaultArgs> = $Result.GetResult<Prisma.$GridPayload, S>

  type GridCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GridFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GridCountAggregateInputType | true
    }

  export interface GridDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grid'], meta: { name: 'Grid' } }
    /**
     * Find zero or one Grid that matches the filter.
     * @param {GridFindUniqueArgs} args - Arguments to find a Grid
     * @example
     * // Get one Grid
     * const grid = await prisma.grid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GridFindUniqueArgs>(args: SelectSubset<T, GridFindUniqueArgs<ExtArgs>>): Prisma__GridClient<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GridFindUniqueOrThrowArgs} args - Arguments to find a Grid
     * @example
     * // Get one Grid
     * const grid = await prisma.grid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GridFindUniqueOrThrowArgs>(args: SelectSubset<T, GridFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GridClient<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GridFindFirstArgs} args - Arguments to find a Grid
     * @example
     * // Get one Grid
     * const grid = await prisma.grid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GridFindFirstArgs>(args?: SelectSubset<T, GridFindFirstArgs<ExtArgs>>): Prisma__GridClient<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GridFindFirstOrThrowArgs} args - Arguments to find a Grid
     * @example
     * // Get one Grid
     * const grid = await prisma.grid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GridFindFirstOrThrowArgs>(args?: SelectSubset<T, GridFindFirstOrThrowArgs<ExtArgs>>): Prisma__GridClient<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GridFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grids
     * const grids = await prisma.grid.findMany()
     * 
     * // Get first 10 Grids
     * const grids = await prisma.grid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gridWithIdOnly = await prisma.grid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GridFindManyArgs>(args?: SelectSubset<T, GridFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grid.
     * @param {GridCreateArgs} args - Arguments to create a Grid.
     * @example
     * // Create one Grid
     * const Grid = await prisma.grid.create({
     *   data: {
     *     // ... data to create a Grid
     *   }
     * })
     * 
     */
    create<T extends GridCreateArgs>(args: SelectSubset<T, GridCreateArgs<ExtArgs>>): Prisma__GridClient<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grids.
     * @param {GridCreateManyArgs} args - Arguments to create many Grids.
     * @example
     * // Create many Grids
     * const grid = await prisma.grid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GridCreateManyArgs>(args?: SelectSubset<T, GridCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grids and returns the data saved in the database.
     * @param {GridCreateManyAndReturnArgs} args - Arguments to create many Grids.
     * @example
     * // Create many Grids
     * const grid = await prisma.grid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grids and only return the `id`
     * const gridWithIdOnly = await prisma.grid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GridCreateManyAndReturnArgs>(args?: SelectSubset<T, GridCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grid.
     * @param {GridDeleteArgs} args - Arguments to delete one Grid.
     * @example
     * // Delete one Grid
     * const Grid = await prisma.grid.delete({
     *   where: {
     *     // ... filter to delete one Grid
     *   }
     * })
     * 
     */
    delete<T extends GridDeleteArgs>(args: SelectSubset<T, GridDeleteArgs<ExtArgs>>): Prisma__GridClient<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grid.
     * @param {GridUpdateArgs} args - Arguments to update one Grid.
     * @example
     * // Update one Grid
     * const grid = await prisma.grid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GridUpdateArgs>(args: SelectSubset<T, GridUpdateArgs<ExtArgs>>): Prisma__GridClient<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grids.
     * @param {GridDeleteManyArgs} args - Arguments to filter Grids to delete.
     * @example
     * // Delete a few Grids
     * const { count } = await prisma.grid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GridDeleteManyArgs>(args?: SelectSubset<T, GridDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GridUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grids
     * const grid = await prisma.grid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GridUpdateManyArgs>(args: SelectSubset<T, GridUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grids and returns the data updated in the database.
     * @param {GridUpdateManyAndReturnArgs} args - Arguments to update many Grids.
     * @example
     * // Update many Grids
     * const grid = await prisma.grid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grids and only return the `id`
     * const gridWithIdOnly = await prisma.grid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GridUpdateManyAndReturnArgs>(args: SelectSubset<T, GridUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grid.
     * @param {GridUpsertArgs} args - Arguments to update or create a Grid.
     * @example
     * // Update or create a Grid
     * const grid = await prisma.grid.upsert({
     *   create: {
     *     // ... data to create a Grid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grid we want to update
     *   }
     * })
     */
    upsert<T extends GridUpsertArgs>(args: SelectSubset<T, GridUpsertArgs<ExtArgs>>): Prisma__GridClient<$Result.GetResult<Prisma.$GridPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GridCountArgs} args - Arguments to filter Grids to count.
     * @example
     * // Count the number of Grids
     * const count = await prisma.grid.count({
     *   where: {
     *     // ... the filter for the Grids we want to count
     *   }
     * })
    **/
    count<T extends GridCountArgs>(
      args?: Subset<T, GridCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GridCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GridAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GridAggregateArgs>(args: Subset<T, GridAggregateArgs>): Prisma.PrismaPromise<GetGridAggregateType<T>>

    /**
     * Group by Grid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GridGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GridGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GridGroupByArgs['orderBy'] }
        : { orderBy?: GridGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GridGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGridGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grid model
   */
  readonly fields: GridFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GridClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grid model
   */
  interface GridFieldRefs {
    readonly id: FieldRef<"Grid", 'String'>
    readonly title: FieldRef<"Grid", 'String'>
    readonly cover: FieldRef<"Grid", 'String'>
    readonly projectId: FieldRef<"Grid", 'String'>
    readonly customFields: FieldRef<"Grid", 'Json'>
    readonly isDeleted: FieldRef<"Grid", 'Boolean'>
    readonly createdAt: FieldRef<"Grid", 'DateTime'>
    readonly createdBy: FieldRef<"Grid", 'String'>
    readonly updatedAt: FieldRef<"Grid", 'DateTime'>
    readonly updatedBy: FieldRef<"Grid", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Grid findUnique
   */
  export type GridFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    /**
     * Filter, which Grid to fetch.
     */
    where: GridWhereUniqueInput
  }

  /**
   * Grid findUniqueOrThrow
   */
  export type GridFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    /**
     * Filter, which Grid to fetch.
     */
    where: GridWhereUniqueInput
  }

  /**
   * Grid findFirst
   */
  export type GridFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    /**
     * Filter, which Grid to fetch.
     */
    where?: GridWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grids to fetch.
     */
    orderBy?: GridOrderByWithRelationInput | GridOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grids.
     */
    cursor?: GridWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grids.
     */
    distinct?: GridScalarFieldEnum | GridScalarFieldEnum[]
  }

  /**
   * Grid findFirstOrThrow
   */
  export type GridFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    /**
     * Filter, which Grid to fetch.
     */
    where?: GridWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grids to fetch.
     */
    orderBy?: GridOrderByWithRelationInput | GridOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grids.
     */
    cursor?: GridWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grids.
     */
    distinct?: GridScalarFieldEnum | GridScalarFieldEnum[]
  }

  /**
   * Grid findMany
   */
  export type GridFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    /**
     * Filter, which Grids to fetch.
     */
    where?: GridWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grids to fetch.
     */
    orderBy?: GridOrderByWithRelationInput | GridOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grids.
     */
    cursor?: GridWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grids.
     */
    skip?: number
    distinct?: GridScalarFieldEnum | GridScalarFieldEnum[]
  }

  /**
   * Grid create
   */
  export type GridCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    /**
     * The data needed to create a Grid.
     */
    data: XOR<GridCreateInput, GridUncheckedCreateInput>
  }

  /**
   * Grid createMany
   */
  export type GridCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grids.
     */
    data: GridCreateManyInput | GridCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grid createManyAndReturn
   */
  export type GridCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * The data used to create many Grids.
     */
    data: GridCreateManyInput | GridCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grid update
   */
  export type GridUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    /**
     * The data needed to update a Grid.
     */
    data: XOR<GridUpdateInput, GridUncheckedUpdateInput>
    /**
     * Choose, which Grid to update.
     */
    where: GridWhereUniqueInput
  }

  /**
   * Grid updateMany
   */
  export type GridUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grids.
     */
    data: XOR<GridUpdateManyMutationInput, GridUncheckedUpdateManyInput>
    /**
     * Filter which Grids to update
     */
    where?: GridWhereInput
    /**
     * Limit how many Grids to update.
     */
    limit?: number
  }

  /**
   * Grid updateManyAndReturn
   */
  export type GridUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * The data used to update Grids.
     */
    data: XOR<GridUpdateManyMutationInput, GridUncheckedUpdateManyInput>
    /**
     * Filter which Grids to update
     */
    where?: GridWhereInput
    /**
     * Limit how many Grids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grid upsert
   */
  export type GridUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    /**
     * The filter to search for the Grid to update in case it exists.
     */
    where: GridWhereUniqueInput
    /**
     * In case the Grid found by the `where` argument doesn't exist, create a new Grid with this data.
     */
    create: XOR<GridCreateInput, GridUncheckedCreateInput>
    /**
     * In case the Grid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GridUpdateInput, GridUncheckedUpdateInput>
  }

  /**
   * Grid delete
   */
  export type GridDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
    /**
     * Filter which Grid to delete.
     */
    where: GridWhereUniqueInput
  }

  /**
   * Grid deleteMany
   */
  export type GridDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grids to delete
     */
    where?: GridWhereInput
    /**
     * Limit how many Grids to delete.
     */
    limit?: number
  }

  /**
   * Grid without action
   */
  export type GridDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grid
     */
    select?: GridSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grid
     */
    omit?: GridOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GridInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    projectId: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    projectId: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    projectId: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    projectId?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    projectId?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    projectId?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    color: string
    projectId: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    projectId?: boolean
    taskTags?: boolean | Tag$taskTagsArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    projectId?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "projectId", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskTags?: boolean | Tag$taskTagsArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      taskTags: Prisma.$TaskTagPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      projectId: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taskTags<T extends Tag$taskTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$taskTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly projectId: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.taskTags
   */
  export type Tag$taskTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    where?: TaskTagWhereInput
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    cursor?: TaskTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TaskTag
   */

  export type AggregateTaskTag = {
    _count: TaskTagCountAggregateOutputType | null
    _min: TaskTagMinAggregateOutputType | null
    _max: TaskTagMaxAggregateOutputType | null
  }

  export type TaskTagMinAggregateOutputType = {
    taskId: string | null
    tagId: string | null
  }

  export type TaskTagMaxAggregateOutputType = {
    taskId: string | null
    tagId: string | null
  }

  export type TaskTagCountAggregateOutputType = {
    taskId: number
    tagId: number
    _all: number
  }


  export type TaskTagMinAggregateInputType = {
    taskId?: true
    tagId?: true
  }

  export type TaskTagMaxAggregateInputType = {
    taskId?: true
    tagId?: true
  }

  export type TaskTagCountAggregateInputType = {
    taskId?: true
    tagId?: true
    _all?: true
  }

  export type TaskTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTag to aggregate.
     */
    where?: TaskTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTags to fetch.
     */
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskTags
    **/
    _count?: true | TaskTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskTagMaxAggregateInputType
  }

  export type GetTaskTagAggregateType<T extends TaskTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskTag[P]>
      : GetScalarType<T[P], AggregateTaskTag[P]>
  }




  export type TaskTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTagWhereInput
    orderBy?: TaskTagOrderByWithAggregationInput | TaskTagOrderByWithAggregationInput[]
    by: TaskTagScalarFieldEnum[] | TaskTagScalarFieldEnum
    having?: TaskTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskTagCountAggregateInputType | true
    _min?: TaskTagMinAggregateInputType
    _max?: TaskTagMaxAggregateInputType
  }

  export type TaskTagGroupByOutputType = {
    taskId: string
    tagId: string
    _count: TaskTagCountAggregateOutputType | null
    _min: TaskTagMinAggregateOutputType | null
    _max: TaskTagMaxAggregateOutputType | null
  }

  type GetTaskTagGroupByPayload<T extends TaskTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskTagGroupByOutputType[P]>
            : GetScalarType<T[P], TaskTagGroupByOutputType[P]>
        }
      >
    >


  export type TaskTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    tagId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTag"]>

  export type TaskTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    tagId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTag"]>

  export type TaskTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    tagId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTag"]>

  export type TaskTagSelectScalar = {
    taskId?: boolean
    tagId?: boolean
  }

  export type TaskTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"taskId" | "tagId", ExtArgs["result"]["taskTag"]>
  export type TaskTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TaskTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TaskTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TaskTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskTag"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      taskId: string
      tagId: string
    }, ExtArgs["result"]["taskTag"]>
    composites: {}
  }

  type TaskTagGetPayload<S extends boolean | null | undefined | TaskTagDefaultArgs> = $Result.GetResult<Prisma.$TaskTagPayload, S>

  type TaskTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskTagCountAggregateInputType | true
    }

  export interface TaskTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskTag'], meta: { name: 'TaskTag' } }
    /**
     * Find zero or one TaskTag that matches the filter.
     * @param {TaskTagFindUniqueArgs} args - Arguments to find a TaskTag
     * @example
     * // Get one TaskTag
     * const taskTag = await prisma.taskTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskTagFindUniqueArgs>(args: SelectSubset<T, TaskTagFindUniqueArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskTagFindUniqueOrThrowArgs} args - Arguments to find a TaskTag
     * @example
     * // Get one TaskTag
     * const taskTag = await prisma.taskTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskTagFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagFindFirstArgs} args - Arguments to find a TaskTag
     * @example
     * // Get one TaskTag
     * const taskTag = await prisma.taskTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskTagFindFirstArgs>(args?: SelectSubset<T, TaskTagFindFirstArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagFindFirstOrThrowArgs} args - Arguments to find a TaskTag
     * @example
     * // Get one TaskTag
     * const taskTag = await prisma.taskTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskTagFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskTags
     * const taskTags = await prisma.taskTag.findMany()
     * 
     * // Get first 10 TaskTags
     * const taskTags = await prisma.taskTag.findMany({ take: 10 })
     * 
     * // Only select the `taskId`
     * const taskTagWithTaskIdOnly = await prisma.taskTag.findMany({ select: { taskId: true } })
     * 
     */
    findMany<T extends TaskTagFindManyArgs>(args?: SelectSubset<T, TaskTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskTag.
     * @param {TaskTagCreateArgs} args - Arguments to create a TaskTag.
     * @example
     * // Create one TaskTag
     * const TaskTag = await prisma.taskTag.create({
     *   data: {
     *     // ... data to create a TaskTag
     *   }
     * })
     * 
     */
    create<T extends TaskTagCreateArgs>(args: SelectSubset<T, TaskTagCreateArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskTags.
     * @param {TaskTagCreateManyArgs} args - Arguments to create many TaskTags.
     * @example
     * // Create many TaskTags
     * const taskTag = await prisma.taskTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskTagCreateManyArgs>(args?: SelectSubset<T, TaskTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskTags and returns the data saved in the database.
     * @param {TaskTagCreateManyAndReturnArgs} args - Arguments to create many TaskTags.
     * @example
     * // Create many TaskTags
     * const taskTag = await prisma.taskTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskTags and only return the `taskId`
     * const taskTagWithTaskIdOnly = await prisma.taskTag.createManyAndReturn({
     *   select: { taskId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskTagCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskTag.
     * @param {TaskTagDeleteArgs} args - Arguments to delete one TaskTag.
     * @example
     * // Delete one TaskTag
     * const TaskTag = await prisma.taskTag.delete({
     *   where: {
     *     // ... filter to delete one TaskTag
     *   }
     * })
     * 
     */
    delete<T extends TaskTagDeleteArgs>(args: SelectSubset<T, TaskTagDeleteArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskTag.
     * @param {TaskTagUpdateArgs} args - Arguments to update one TaskTag.
     * @example
     * // Update one TaskTag
     * const taskTag = await prisma.taskTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskTagUpdateArgs>(args: SelectSubset<T, TaskTagUpdateArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskTags.
     * @param {TaskTagDeleteManyArgs} args - Arguments to filter TaskTags to delete.
     * @example
     * // Delete a few TaskTags
     * const { count } = await prisma.taskTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskTagDeleteManyArgs>(args?: SelectSubset<T, TaskTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskTags
     * const taskTag = await prisma.taskTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskTagUpdateManyArgs>(args: SelectSubset<T, TaskTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTags and returns the data updated in the database.
     * @param {TaskTagUpdateManyAndReturnArgs} args - Arguments to update many TaskTags.
     * @example
     * // Update many TaskTags
     * const taskTag = await prisma.taskTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskTags and only return the `taskId`
     * const taskTagWithTaskIdOnly = await prisma.taskTag.updateManyAndReturn({
     *   select: { taskId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskTagUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskTag.
     * @param {TaskTagUpsertArgs} args - Arguments to update or create a TaskTag.
     * @example
     * // Update or create a TaskTag
     * const taskTag = await prisma.taskTag.upsert({
     *   create: {
     *     // ... data to create a TaskTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskTag we want to update
     *   }
     * })
     */
    upsert<T extends TaskTagUpsertArgs>(args: SelectSubset<T, TaskTagUpsertArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagCountArgs} args - Arguments to filter TaskTags to count.
     * @example
     * // Count the number of TaskTags
     * const count = await prisma.taskTag.count({
     *   where: {
     *     // ... the filter for the TaskTags we want to count
     *   }
     * })
    **/
    count<T extends TaskTagCountArgs>(
      args?: Subset<T, TaskTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskTagAggregateArgs>(args: Subset<T, TaskTagAggregateArgs>): Prisma.PrismaPromise<GetTaskTagAggregateType<T>>

    /**
     * Group by TaskTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskTagGroupByArgs['orderBy'] }
        : { orderBy?: TaskTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskTag model
   */
  readonly fields: TaskTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskTag model
   */
  interface TaskTagFieldRefs {
    readonly taskId: FieldRef<"TaskTag", 'String'>
    readonly tagId: FieldRef<"TaskTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskTag findUnique
   */
  export type TaskTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTag to fetch.
     */
    where: TaskTagWhereUniqueInput
  }

  /**
   * TaskTag findUniqueOrThrow
   */
  export type TaskTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTag to fetch.
     */
    where: TaskTagWhereUniqueInput
  }

  /**
   * TaskTag findFirst
   */
  export type TaskTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTag to fetch.
     */
    where?: TaskTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTags to fetch.
     */
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTags.
     */
    cursor?: TaskTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTags.
     */
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * TaskTag findFirstOrThrow
   */
  export type TaskTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTag to fetch.
     */
    where?: TaskTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTags to fetch.
     */
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTags.
     */
    cursor?: TaskTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTags.
     */
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * TaskTag findMany
   */
  export type TaskTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTags to fetch.
     */
    where?: TaskTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTags to fetch.
     */
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskTags.
     */
    cursor?: TaskTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTags.
     */
    skip?: number
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * TaskTag create
   */
  export type TaskTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskTag.
     */
    data: XOR<TaskTagCreateInput, TaskTagUncheckedCreateInput>
  }

  /**
   * TaskTag createMany
   */
  export type TaskTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskTags.
     */
    data: TaskTagCreateManyInput | TaskTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskTag createManyAndReturn
   */
  export type TaskTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * The data used to create many TaskTags.
     */
    data: TaskTagCreateManyInput | TaskTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTag update
   */
  export type TaskTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskTag.
     */
    data: XOR<TaskTagUpdateInput, TaskTagUncheckedUpdateInput>
    /**
     * Choose, which TaskTag to update.
     */
    where: TaskTagWhereUniqueInput
  }

  /**
   * TaskTag updateMany
   */
  export type TaskTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskTags.
     */
    data: XOR<TaskTagUpdateManyMutationInput, TaskTagUncheckedUpdateManyInput>
    /**
     * Filter which TaskTags to update
     */
    where?: TaskTagWhereInput
    /**
     * Limit how many TaskTags to update.
     */
    limit?: number
  }

  /**
   * TaskTag updateManyAndReturn
   */
  export type TaskTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * The data used to update TaskTags.
     */
    data: XOR<TaskTagUpdateManyMutationInput, TaskTagUncheckedUpdateManyInput>
    /**
     * Filter which TaskTags to update
     */
    where?: TaskTagWhereInput
    /**
     * Limit how many TaskTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTag upsert
   */
  export type TaskTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskTag to update in case it exists.
     */
    where: TaskTagWhereUniqueInput
    /**
     * In case the TaskTag found by the `where` argument doesn't exist, create a new TaskTag with this data.
     */
    create: XOR<TaskTagCreateInput, TaskTagUncheckedCreateInput>
    /**
     * In case the TaskTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskTagUpdateInput, TaskTagUncheckedUpdateInput>
  }

  /**
   * TaskTag delete
   */
  export type TaskTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter which TaskTag to delete.
     */
    where: TaskTagWhereUniqueInput
  }

  /**
   * TaskTag deleteMany
   */
  export type TaskTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTags to delete
     */
    where?: TaskTagWhereInput
    /**
     * Limit how many TaskTags to delete.
     */
    limit?: number
  }

  /**
   * TaskTag without action
   */
  export type TaskTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
  }


  /**
   * Model Scheduler
   */

  export type AggregateScheduler = {
    _count: SchedulerCountAggregateOutputType | null
    _min: SchedulerMinAggregateOutputType | null
    _max: SchedulerMaxAggregateOutputType | null
  }

  export type SchedulerMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    projectId: string | null
    cronId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SchedulerMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    projectId: string | null
    cronId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SchedulerCountAggregateOutputType = {
    id: number
    organizationId: number
    projectId: number
    cronId: number
    trigger: number
    action: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SchedulerMinAggregateInputType = {
    id?: true
    organizationId?: true
    projectId?: true
    cronId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SchedulerMaxAggregateInputType = {
    id?: true
    organizationId?: true
    projectId?: true
    cronId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SchedulerCountAggregateInputType = {
    id?: true
    organizationId?: true
    projectId?: true
    cronId?: true
    trigger?: true
    action?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SchedulerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scheduler to aggregate.
     */
    where?: SchedulerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedulers to fetch.
     */
    orderBy?: SchedulerOrderByWithRelationInput | SchedulerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchedulerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedulers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedulers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedulers
    **/
    _count?: true | SchedulerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchedulerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchedulerMaxAggregateInputType
  }

  export type GetSchedulerAggregateType<T extends SchedulerAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduler]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduler[P]>
      : GetScalarType<T[P], AggregateScheduler[P]>
  }




  export type SchedulerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchedulerWhereInput
    orderBy?: SchedulerOrderByWithAggregationInput | SchedulerOrderByWithAggregationInput[]
    by: SchedulerScalarFieldEnum[] | SchedulerScalarFieldEnum
    having?: SchedulerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchedulerCountAggregateInputType | true
    _min?: SchedulerMinAggregateInputType
    _max?: SchedulerMaxAggregateInputType
  }

  export type SchedulerGroupByOutputType = {
    id: string
    organizationId: string
    projectId: string
    cronId: string | null
    trigger: JsonValue
    action: JsonValue
    createdAt: Date
    createdBy: string | null
    updatedAt: Date
    updatedBy: string | null
    _count: SchedulerCountAggregateOutputType | null
    _min: SchedulerMinAggregateOutputType | null
    _max: SchedulerMaxAggregateOutputType | null
  }

  type GetSchedulerGroupByPayload<T extends SchedulerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchedulerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchedulerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchedulerGroupByOutputType[P]>
            : GetScalarType<T[P], SchedulerGroupByOutputType[P]>
        }
      >
    >


  export type SchedulerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    cronId?: boolean
    trigger?: boolean
    action?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduler"]>

  export type SchedulerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    cronId?: boolean
    trigger?: boolean
    action?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduler"]>

  export type SchedulerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    cronId?: boolean
    trigger?: boolean
    action?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduler"]>

  export type SchedulerSelectScalar = {
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    cronId?: boolean
    trigger?: boolean
    action?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type SchedulerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "projectId" | "cronId" | "trigger" | "action" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["scheduler"]>
  export type SchedulerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SchedulerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SchedulerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SchedulerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Scheduler"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      projectId: string
      cronId: string | null
      trigger: Prisma.JsonValue
      action: Prisma.JsonValue
      createdAt: Date
      createdBy: string | null
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["scheduler"]>
    composites: {}
  }

  type SchedulerGetPayload<S extends boolean | null | undefined | SchedulerDefaultArgs> = $Result.GetResult<Prisma.$SchedulerPayload, S>

  type SchedulerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchedulerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchedulerCountAggregateInputType | true
    }

  export interface SchedulerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Scheduler'], meta: { name: 'Scheduler' } }
    /**
     * Find zero or one Scheduler that matches the filter.
     * @param {SchedulerFindUniqueArgs} args - Arguments to find a Scheduler
     * @example
     * // Get one Scheduler
     * const scheduler = await prisma.scheduler.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchedulerFindUniqueArgs>(args: SelectSubset<T, SchedulerFindUniqueArgs<ExtArgs>>): Prisma__SchedulerClient<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Scheduler that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchedulerFindUniqueOrThrowArgs} args - Arguments to find a Scheduler
     * @example
     * // Get one Scheduler
     * const scheduler = await prisma.scheduler.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchedulerFindUniqueOrThrowArgs>(args: SelectSubset<T, SchedulerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchedulerClient<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scheduler that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulerFindFirstArgs} args - Arguments to find a Scheduler
     * @example
     * // Get one Scheduler
     * const scheduler = await prisma.scheduler.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchedulerFindFirstArgs>(args?: SelectSubset<T, SchedulerFindFirstArgs<ExtArgs>>): Prisma__SchedulerClient<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scheduler that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulerFindFirstOrThrowArgs} args - Arguments to find a Scheduler
     * @example
     * // Get one Scheduler
     * const scheduler = await prisma.scheduler.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchedulerFindFirstOrThrowArgs>(args?: SelectSubset<T, SchedulerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchedulerClient<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedulers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedulers
     * const schedulers = await prisma.scheduler.findMany()
     * 
     * // Get first 10 Schedulers
     * const schedulers = await prisma.scheduler.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schedulerWithIdOnly = await prisma.scheduler.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchedulerFindManyArgs>(args?: SelectSubset<T, SchedulerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Scheduler.
     * @param {SchedulerCreateArgs} args - Arguments to create a Scheduler.
     * @example
     * // Create one Scheduler
     * const Scheduler = await prisma.scheduler.create({
     *   data: {
     *     // ... data to create a Scheduler
     *   }
     * })
     * 
     */
    create<T extends SchedulerCreateArgs>(args: SelectSubset<T, SchedulerCreateArgs<ExtArgs>>): Prisma__SchedulerClient<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedulers.
     * @param {SchedulerCreateManyArgs} args - Arguments to create many Schedulers.
     * @example
     * // Create many Schedulers
     * const scheduler = await prisma.scheduler.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchedulerCreateManyArgs>(args?: SelectSubset<T, SchedulerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedulers and returns the data saved in the database.
     * @param {SchedulerCreateManyAndReturnArgs} args - Arguments to create many Schedulers.
     * @example
     * // Create many Schedulers
     * const scheduler = await prisma.scheduler.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedulers and only return the `id`
     * const schedulerWithIdOnly = await prisma.scheduler.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchedulerCreateManyAndReturnArgs>(args?: SelectSubset<T, SchedulerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Scheduler.
     * @param {SchedulerDeleteArgs} args - Arguments to delete one Scheduler.
     * @example
     * // Delete one Scheduler
     * const Scheduler = await prisma.scheduler.delete({
     *   where: {
     *     // ... filter to delete one Scheduler
     *   }
     * })
     * 
     */
    delete<T extends SchedulerDeleteArgs>(args: SelectSubset<T, SchedulerDeleteArgs<ExtArgs>>): Prisma__SchedulerClient<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Scheduler.
     * @param {SchedulerUpdateArgs} args - Arguments to update one Scheduler.
     * @example
     * // Update one Scheduler
     * const scheduler = await prisma.scheduler.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchedulerUpdateArgs>(args: SelectSubset<T, SchedulerUpdateArgs<ExtArgs>>): Prisma__SchedulerClient<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedulers.
     * @param {SchedulerDeleteManyArgs} args - Arguments to filter Schedulers to delete.
     * @example
     * // Delete a few Schedulers
     * const { count } = await prisma.scheduler.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchedulerDeleteManyArgs>(args?: SelectSubset<T, SchedulerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedulers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedulers
     * const scheduler = await prisma.scheduler.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchedulerUpdateManyArgs>(args: SelectSubset<T, SchedulerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedulers and returns the data updated in the database.
     * @param {SchedulerUpdateManyAndReturnArgs} args - Arguments to update many Schedulers.
     * @example
     * // Update many Schedulers
     * const scheduler = await prisma.scheduler.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedulers and only return the `id`
     * const schedulerWithIdOnly = await prisma.scheduler.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchedulerUpdateManyAndReturnArgs>(args: SelectSubset<T, SchedulerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Scheduler.
     * @param {SchedulerUpsertArgs} args - Arguments to update or create a Scheduler.
     * @example
     * // Update or create a Scheduler
     * const scheduler = await prisma.scheduler.upsert({
     *   create: {
     *     // ... data to create a Scheduler
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scheduler we want to update
     *   }
     * })
     */
    upsert<T extends SchedulerUpsertArgs>(args: SelectSubset<T, SchedulerUpsertArgs<ExtArgs>>): Prisma__SchedulerClient<$Result.GetResult<Prisma.$SchedulerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedulers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulerCountArgs} args - Arguments to filter Schedulers to count.
     * @example
     * // Count the number of Schedulers
     * const count = await prisma.scheduler.count({
     *   where: {
     *     // ... the filter for the Schedulers we want to count
     *   }
     * })
    **/
    count<T extends SchedulerCountArgs>(
      args?: Subset<T, SchedulerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchedulerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scheduler.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchedulerAggregateArgs>(args: Subset<T, SchedulerAggregateArgs>): Prisma.PrismaPromise<GetSchedulerAggregateType<T>>

    /**
     * Group by Scheduler.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchedulerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchedulerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchedulerGroupByArgs['orderBy'] }
        : { orderBy?: SchedulerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchedulerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchedulerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Scheduler model
   */
  readonly fields: SchedulerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Scheduler.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchedulerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Scheduler model
   */
  interface SchedulerFieldRefs {
    readonly id: FieldRef<"Scheduler", 'String'>
    readonly organizationId: FieldRef<"Scheduler", 'String'>
    readonly projectId: FieldRef<"Scheduler", 'String'>
    readonly cronId: FieldRef<"Scheduler", 'String'>
    readonly trigger: FieldRef<"Scheduler", 'Json'>
    readonly action: FieldRef<"Scheduler", 'Json'>
    readonly createdAt: FieldRef<"Scheduler", 'DateTime'>
    readonly createdBy: FieldRef<"Scheduler", 'String'>
    readonly updatedAt: FieldRef<"Scheduler", 'DateTime'>
    readonly updatedBy: FieldRef<"Scheduler", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Scheduler findUnique
   */
  export type SchedulerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    /**
     * Filter, which Scheduler to fetch.
     */
    where: SchedulerWhereUniqueInput
  }

  /**
   * Scheduler findUniqueOrThrow
   */
  export type SchedulerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    /**
     * Filter, which Scheduler to fetch.
     */
    where: SchedulerWhereUniqueInput
  }

  /**
   * Scheduler findFirst
   */
  export type SchedulerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    /**
     * Filter, which Scheduler to fetch.
     */
    where?: SchedulerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedulers to fetch.
     */
    orderBy?: SchedulerOrderByWithRelationInput | SchedulerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedulers.
     */
    cursor?: SchedulerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedulers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedulers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedulers.
     */
    distinct?: SchedulerScalarFieldEnum | SchedulerScalarFieldEnum[]
  }

  /**
   * Scheduler findFirstOrThrow
   */
  export type SchedulerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    /**
     * Filter, which Scheduler to fetch.
     */
    where?: SchedulerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedulers to fetch.
     */
    orderBy?: SchedulerOrderByWithRelationInput | SchedulerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedulers.
     */
    cursor?: SchedulerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedulers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedulers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedulers.
     */
    distinct?: SchedulerScalarFieldEnum | SchedulerScalarFieldEnum[]
  }

  /**
   * Scheduler findMany
   */
  export type SchedulerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    /**
     * Filter, which Schedulers to fetch.
     */
    where?: SchedulerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedulers to fetch.
     */
    orderBy?: SchedulerOrderByWithRelationInput | SchedulerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedulers.
     */
    cursor?: SchedulerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedulers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedulers.
     */
    skip?: number
    distinct?: SchedulerScalarFieldEnum | SchedulerScalarFieldEnum[]
  }

  /**
   * Scheduler create
   */
  export type SchedulerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    /**
     * The data needed to create a Scheduler.
     */
    data: XOR<SchedulerCreateInput, SchedulerUncheckedCreateInput>
  }

  /**
   * Scheduler createMany
   */
  export type SchedulerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedulers.
     */
    data: SchedulerCreateManyInput | SchedulerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Scheduler createManyAndReturn
   */
  export type SchedulerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * The data used to create many Schedulers.
     */
    data: SchedulerCreateManyInput | SchedulerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Scheduler update
   */
  export type SchedulerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    /**
     * The data needed to update a Scheduler.
     */
    data: XOR<SchedulerUpdateInput, SchedulerUncheckedUpdateInput>
    /**
     * Choose, which Scheduler to update.
     */
    where: SchedulerWhereUniqueInput
  }

  /**
   * Scheduler updateMany
   */
  export type SchedulerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedulers.
     */
    data: XOR<SchedulerUpdateManyMutationInput, SchedulerUncheckedUpdateManyInput>
    /**
     * Filter which Schedulers to update
     */
    where?: SchedulerWhereInput
    /**
     * Limit how many Schedulers to update.
     */
    limit?: number
  }

  /**
   * Scheduler updateManyAndReturn
   */
  export type SchedulerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * The data used to update Schedulers.
     */
    data: XOR<SchedulerUpdateManyMutationInput, SchedulerUncheckedUpdateManyInput>
    /**
     * Filter which Schedulers to update
     */
    where?: SchedulerWhereInput
    /**
     * Limit how many Schedulers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Scheduler upsert
   */
  export type SchedulerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    /**
     * The filter to search for the Scheduler to update in case it exists.
     */
    where: SchedulerWhereUniqueInput
    /**
     * In case the Scheduler found by the `where` argument doesn't exist, create a new Scheduler with this data.
     */
    create: XOR<SchedulerCreateInput, SchedulerUncheckedCreateInput>
    /**
     * In case the Scheduler was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchedulerUpdateInput, SchedulerUncheckedUpdateInput>
  }

  /**
   * Scheduler delete
   */
  export type SchedulerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
    /**
     * Filter which Scheduler to delete.
     */
    where: SchedulerWhereUniqueInput
  }

  /**
   * Scheduler deleteMany
   */
  export type SchedulerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedulers to delete
     */
    where?: SchedulerWhereInput
    /**
     * Limit how many Schedulers to delete.
     */
    limit?: number
  }

  /**
   * Scheduler without action
   */
  export type SchedulerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scheduler
     */
    select?: SchedulerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scheduler
     */
    omit?: SchedulerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchedulerInclude<ExtArgs> | null
  }


  /**
   * Model FileStorage
   */

  export type AggregateFileStorage = {
    _count: FileStorageCountAggregateOutputType | null
    _avg: FileStorageAvgAggregateOutputType | null
    _sum: FileStorageSumAggregateOutputType | null
    _min: FileStorageMinAggregateOutputType | null
    _max: FileStorageMaxAggregateOutputType | null
  }

  export type FileStorageAvgAggregateOutputType = {
    size: number | null
  }

  export type FileStorageSumAggregateOutputType = {
    size: number | null
  }

  export type FileStorageMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    projectId: string | null
    taskId: string | null
    name: string | null
    keyName: string | null
    type: $Enums.FileType | null
    url: string | null
    size: number | null
    mimeType: string | null
    parentId: string | null
    owner: string | null
    ownerType: $Enums.FileOwnerType | null
    isDeleted: boolean | null
    createdAt: Date | null
    createdBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type FileStorageMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    projectId: string | null
    taskId: string | null
    name: string | null
    keyName: string | null
    type: $Enums.FileType | null
    url: string | null
    size: number | null
    mimeType: string | null
    parentId: string | null
    owner: string | null
    ownerType: $Enums.FileOwnerType | null
    isDeleted: boolean | null
    createdAt: Date | null
    createdBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type FileStorageCountAggregateOutputType = {
    id: number
    organizationId: number
    projectId: number
    taskId: number
    name: number
    keyName: number
    type: number
    url: number
    size: number
    mimeType: number
    parentId: number
    owner: number
    ownerType: number
    isDeleted: number
    createdAt: number
    createdBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type FileStorageAvgAggregateInputType = {
    size?: true
  }

  export type FileStorageSumAggregateInputType = {
    size?: true
  }

  export type FileStorageMinAggregateInputType = {
    id?: true
    organizationId?: true
    projectId?: true
    taskId?: true
    name?: true
    keyName?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    parentId?: true
    owner?: true
    ownerType?: true
    isDeleted?: true
    createdAt?: true
    createdBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type FileStorageMaxAggregateInputType = {
    id?: true
    organizationId?: true
    projectId?: true
    taskId?: true
    name?: true
    keyName?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    parentId?: true
    owner?: true
    ownerType?: true
    isDeleted?: true
    createdAt?: true
    createdBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type FileStorageCountAggregateInputType = {
    id?: true
    organizationId?: true
    projectId?: true
    taskId?: true
    name?: true
    keyName?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    parentId?: true
    owner?: true
    ownerType?: true
    isDeleted?: true
    createdAt?: true
    createdBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type FileStorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileStorage to aggregate.
     */
    where?: FileStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileStorages to fetch.
     */
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileStorages
    **/
    _count?: true | FileStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileStorageMaxAggregateInputType
  }

  export type GetFileStorageAggregateType<T extends FileStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateFileStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileStorage[P]>
      : GetScalarType<T[P], AggregateFileStorage[P]>
  }




  export type FileStorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileStorageWhereInput
    orderBy?: FileStorageOrderByWithAggregationInput | FileStorageOrderByWithAggregationInput[]
    by: FileStorageScalarFieldEnum[] | FileStorageScalarFieldEnum
    having?: FileStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileStorageCountAggregateInputType | true
    _avg?: FileStorageAvgAggregateInputType
    _sum?: FileStorageSumAggregateInputType
    _min?: FileStorageMinAggregateInputType
    _max?: FileStorageMaxAggregateInputType
  }

  export type FileStorageGroupByOutputType = {
    id: string
    organizationId: string | null
    projectId: string | null
    taskId: string | null
    name: string
    keyName: string
    type: $Enums.FileType
    url: string | null
    size: number | null
    mimeType: string | null
    parentId: string | null
    owner: string | null
    ownerType: $Enums.FileOwnerType | null
    isDeleted: boolean | null
    createdAt: Date
    createdBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: FileStorageCountAggregateOutputType | null
    _avg: FileStorageAvgAggregateOutputType | null
    _sum: FileStorageSumAggregateOutputType | null
    _min: FileStorageMinAggregateOutputType | null
    _max: FileStorageMaxAggregateOutputType | null
  }

  type GetFileStorageGroupByPayload<T extends FileStorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileStorageGroupByOutputType[P]>
            : GetScalarType<T[P], FileStorageGroupByOutputType[P]>
        }
      >
    >


  export type FileStorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    taskId?: boolean
    name?: boolean
    keyName?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    parentId?: boolean
    owner?: boolean
    ownerType?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    organization?: boolean | FileStorage$organizationArgs<ExtArgs>
    project?: boolean | FileStorage$projectArgs<ExtArgs>
    task?: boolean | FileStorage$taskArgs<ExtArgs>
  }, ExtArgs["result"]["fileStorage"]>

  export type FileStorageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    taskId?: boolean
    name?: boolean
    keyName?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    parentId?: boolean
    owner?: boolean
    ownerType?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    organization?: boolean | FileStorage$organizationArgs<ExtArgs>
    project?: boolean | FileStorage$projectArgs<ExtArgs>
    task?: boolean | FileStorage$taskArgs<ExtArgs>
  }, ExtArgs["result"]["fileStorage"]>

  export type FileStorageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    taskId?: boolean
    name?: boolean
    keyName?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    parentId?: boolean
    owner?: boolean
    ownerType?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    organization?: boolean | FileStorage$organizationArgs<ExtArgs>
    project?: boolean | FileStorage$projectArgs<ExtArgs>
    task?: boolean | FileStorage$taskArgs<ExtArgs>
  }, ExtArgs["result"]["fileStorage"]>

  export type FileStorageSelectScalar = {
    id?: boolean
    organizationId?: boolean
    projectId?: boolean
    taskId?: boolean
    name?: boolean
    keyName?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    parentId?: boolean
    owner?: boolean
    ownerType?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type FileStorageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "projectId" | "taskId" | "name" | "keyName" | "type" | "url" | "size" | "mimeType" | "parentId" | "owner" | "ownerType" | "isDeleted" | "createdAt" | "createdBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["fileStorage"]>
  export type FileStorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | FileStorage$organizationArgs<ExtArgs>
    project?: boolean | FileStorage$projectArgs<ExtArgs>
    task?: boolean | FileStorage$taskArgs<ExtArgs>
  }
  export type FileStorageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | FileStorage$organizationArgs<ExtArgs>
    project?: boolean | FileStorage$projectArgs<ExtArgs>
    task?: boolean | FileStorage$taskArgs<ExtArgs>
  }
  export type FileStorageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | FileStorage$organizationArgs<ExtArgs>
    project?: boolean | FileStorage$projectArgs<ExtArgs>
    task?: boolean | FileStorage$taskArgs<ExtArgs>
  }

  export type $FileStoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileStorage"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      task: Prisma.$TaskPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string | null
      projectId: string | null
      taskId: string | null
      name: string
      keyName: string
      type: $Enums.FileType
      url: string | null
      size: number | null
      mimeType: string | null
      parentId: string | null
      owner: string | null
      ownerType: $Enums.FileOwnerType | null
      isDeleted: boolean | null
      createdAt: Date
      createdBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["fileStorage"]>
    composites: {}
  }

  type FileStorageGetPayload<S extends boolean | null | undefined | FileStorageDefaultArgs> = $Result.GetResult<Prisma.$FileStoragePayload, S>

  type FileStorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileStorageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileStorageCountAggregateInputType | true
    }

  export interface FileStorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileStorage'], meta: { name: 'FileStorage' } }
    /**
     * Find zero or one FileStorage that matches the filter.
     * @param {FileStorageFindUniqueArgs} args - Arguments to find a FileStorage
     * @example
     * // Get one FileStorage
     * const fileStorage = await prisma.fileStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileStorageFindUniqueArgs>(args: SelectSubset<T, FileStorageFindUniqueArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileStorage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileStorageFindUniqueOrThrowArgs} args - Arguments to find a FileStorage
     * @example
     * // Get one FileStorage
     * const fileStorage = await prisma.fileStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileStorageFindUniqueOrThrowArgs>(args: SelectSubset<T, FileStorageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageFindFirstArgs} args - Arguments to find a FileStorage
     * @example
     * // Get one FileStorage
     * const fileStorage = await prisma.fileStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileStorageFindFirstArgs>(args?: SelectSubset<T, FileStorageFindFirstArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileStorage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageFindFirstOrThrowArgs} args - Arguments to find a FileStorage
     * @example
     * // Get one FileStorage
     * const fileStorage = await prisma.fileStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileStorageFindFirstOrThrowArgs>(args?: SelectSubset<T, FileStorageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileStorages
     * const fileStorages = await prisma.fileStorage.findMany()
     * 
     * // Get first 10 FileStorages
     * const fileStorages = await prisma.fileStorage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileStorageWithIdOnly = await prisma.fileStorage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileStorageFindManyArgs>(args?: SelectSubset<T, FileStorageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileStorage.
     * @param {FileStorageCreateArgs} args - Arguments to create a FileStorage.
     * @example
     * // Create one FileStorage
     * const FileStorage = await prisma.fileStorage.create({
     *   data: {
     *     // ... data to create a FileStorage
     *   }
     * })
     * 
     */
    create<T extends FileStorageCreateArgs>(args: SelectSubset<T, FileStorageCreateArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileStorages.
     * @param {FileStorageCreateManyArgs} args - Arguments to create many FileStorages.
     * @example
     * // Create many FileStorages
     * const fileStorage = await prisma.fileStorage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileStorageCreateManyArgs>(args?: SelectSubset<T, FileStorageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileStorages and returns the data saved in the database.
     * @param {FileStorageCreateManyAndReturnArgs} args - Arguments to create many FileStorages.
     * @example
     * // Create many FileStorages
     * const fileStorage = await prisma.fileStorage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileStorages and only return the `id`
     * const fileStorageWithIdOnly = await prisma.fileStorage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileStorageCreateManyAndReturnArgs>(args?: SelectSubset<T, FileStorageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileStorage.
     * @param {FileStorageDeleteArgs} args - Arguments to delete one FileStorage.
     * @example
     * // Delete one FileStorage
     * const FileStorage = await prisma.fileStorage.delete({
     *   where: {
     *     // ... filter to delete one FileStorage
     *   }
     * })
     * 
     */
    delete<T extends FileStorageDeleteArgs>(args: SelectSubset<T, FileStorageDeleteArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileStorage.
     * @param {FileStorageUpdateArgs} args - Arguments to update one FileStorage.
     * @example
     * // Update one FileStorage
     * const fileStorage = await prisma.fileStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileStorageUpdateArgs>(args: SelectSubset<T, FileStorageUpdateArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileStorages.
     * @param {FileStorageDeleteManyArgs} args - Arguments to filter FileStorages to delete.
     * @example
     * // Delete a few FileStorages
     * const { count } = await prisma.fileStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileStorageDeleteManyArgs>(args?: SelectSubset<T, FileStorageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileStorages
     * const fileStorage = await prisma.fileStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileStorageUpdateManyArgs>(args: SelectSubset<T, FileStorageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileStorages and returns the data updated in the database.
     * @param {FileStorageUpdateManyAndReturnArgs} args - Arguments to update many FileStorages.
     * @example
     * // Update many FileStorages
     * const fileStorage = await prisma.fileStorage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileStorages and only return the `id`
     * const fileStorageWithIdOnly = await prisma.fileStorage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileStorageUpdateManyAndReturnArgs>(args: SelectSubset<T, FileStorageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileStorage.
     * @param {FileStorageUpsertArgs} args - Arguments to update or create a FileStorage.
     * @example
     * // Update or create a FileStorage
     * const fileStorage = await prisma.fileStorage.upsert({
     *   create: {
     *     // ... data to create a FileStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileStorage we want to update
     *   }
     * })
     */
    upsert<T extends FileStorageUpsertArgs>(args: SelectSubset<T, FileStorageUpsertArgs<ExtArgs>>): Prisma__FileStorageClient<$Result.GetResult<Prisma.$FileStoragePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageCountArgs} args - Arguments to filter FileStorages to count.
     * @example
     * // Count the number of FileStorages
     * const count = await prisma.fileStorage.count({
     *   where: {
     *     // ... the filter for the FileStorages we want to count
     *   }
     * })
    **/
    count<T extends FileStorageCountArgs>(
      args?: Subset<T, FileStorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileStorageAggregateArgs>(args: Subset<T, FileStorageAggregateArgs>): Prisma.PrismaPromise<GetFileStorageAggregateType<T>>

    /**
     * Group by FileStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileStorageGroupByArgs['orderBy'] }
        : { orderBy?: FileStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileStorage model
   */
  readonly fields: FileStorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileStorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends FileStorage$organizationArgs<ExtArgs> = {}>(args?: Subset<T, FileStorage$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends FileStorage$projectArgs<ExtArgs> = {}>(args?: Subset<T, FileStorage$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    task<T extends FileStorage$taskArgs<ExtArgs> = {}>(args?: Subset<T, FileStorage$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileStorage model
   */
  interface FileStorageFieldRefs {
    readonly id: FieldRef<"FileStorage", 'String'>
    readonly organizationId: FieldRef<"FileStorage", 'String'>
    readonly projectId: FieldRef<"FileStorage", 'String'>
    readonly taskId: FieldRef<"FileStorage", 'String'>
    readonly name: FieldRef<"FileStorage", 'String'>
    readonly keyName: FieldRef<"FileStorage", 'String'>
    readonly type: FieldRef<"FileStorage", 'FileType'>
    readonly url: FieldRef<"FileStorage", 'String'>
    readonly size: FieldRef<"FileStorage", 'Float'>
    readonly mimeType: FieldRef<"FileStorage", 'String'>
    readonly parentId: FieldRef<"FileStorage", 'String'>
    readonly owner: FieldRef<"FileStorage", 'String'>
    readonly ownerType: FieldRef<"FileStorage", 'FileOwnerType'>
    readonly isDeleted: FieldRef<"FileStorage", 'Boolean'>
    readonly createdAt: FieldRef<"FileStorage", 'DateTime'>
    readonly createdBy: FieldRef<"FileStorage", 'String'>
    readonly deletedAt: FieldRef<"FileStorage", 'DateTime'>
    readonly deletedBy: FieldRef<"FileStorage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FileStorage findUnique
   */
  export type FileStorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorage to fetch.
     */
    where: FileStorageWhereUniqueInput
  }

  /**
   * FileStorage findUniqueOrThrow
   */
  export type FileStorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorage to fetch.
     */
    where: FileStorageWhereUniqueInput
  }

  /**
   * FileStorage findFirst
   */
  export type FileStorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorage to fetch.
     */
    where?: FileStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileStorages to fetch.
     */
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileStorages.
     */
    cursor?: FileStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileStorages.
     */
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * FileStorage findFirstOrThrow
   */
  export type FileStorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorage to fetch.
     */
    where?: FileStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileStorages to fetch.
     */
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileStorages.
     */
    cursor?: FileStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileStorages.
     */
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * FileStorage findMany
   */
  export type FileStorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter, which FileStorages to fetch.
     */
    where?: FileStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileStorages to fetch.
     */
    orderBy?: FileStorageOrderByWithRelationInput | FileStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileStorages.
     */
    cursor?: FileStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileStorages.
     */
    skip?: number
    distinct?: FileStorageScalarFieldEnum | FileStorageScalarFieldEnum[]
  }

  /**
   * FileStorage create
   */
  export type FileStorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * The data needed to create a FileStorage.
     */
    data: XOR<FileStorageCreateInput, FileStorageUncheckedCreateInput>
  }

  /**
   * FileStorage createMany
   */
  export type FileStorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileStorages.
     */
    data: FileStorageCreateManyInput | FileStorageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileStorage createManyAndReturn
   */
  export type FileStorageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * The data used to create many FileStorages.
     */
    data: FileStorageCreateManyInput | FileStorageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileStorage update
   */
  export type FileStorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * The data needed to update a FileStorage.
     */
    data: XOR<FileStorageUpdateInput, FileStorageUncheckedUpdateInput>
    /**
     * Choose, which FileStorage to update.
     */
    where: FileStorageWhereUniqueInput
  }

  /**
   * FileStorage updateMany
   */
  export type FileStorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileStorages.
     */
    data: XOR<FileStorageUpdateManyMutationInput, FileStorageUncheckedUpdateManyInput>
    /**
     * Filter which FileStorages to update
     */
    where?: FileStorageWhereInput
    /**
     * Limit how many FileStorages to update.
     */
    limit?: number
  }

  /**
   * FileStorage updateManyAndReturn
   */
  export type FileStorageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * The data used to update FileStorages.
     */
    data: XOR<FileStorageUpdateManyMutationInput, FileStorageUncheckedUpdateManyInput>
    /**
     * Filter which FileStorages to update
     */
    where?: FileStorageWhereInput
    /**
     * Limit how many FileStorages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileStorage upsert
   */
  export type FileStorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * The filter to search for the FileStorage to update in case it exists.
     */
    where: FileStorageWhereUniqueInput
    /**
     * In case the FileStorage found by the `where` argument doesn't exist, create a new FileStorage with this data.
     */
    create: XOR<FileStorageCreateInput, FileStorageUncheckedCreateInput>
    /**
     * In case the FileStorage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileStorageUpdateInput, FileStorageUncheckedUpdateInput>
  }

  /**
   * FileStorage delete
   */
  export type FileStorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
    /**
     * Filter which FileStorage to delete.
     */
    where: FileStorageWhereUniqueInput
  }

  /**
   * FileStorage deleteMany
   */
  export type FileStorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileStorages to delete
     */
    where?: FileStorageWhereInput
    /**
     * Limit how many FileStorages to delete.
     */
    limit?: number
  }

  /**
   * FileStorage.organization
   */
  export type FileStorage$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * FileStorage.project
   */
  export type FileStorage$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * FileStorage.task
   */
  export type FileStorage$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * FileStorage without action
   */
  export type FileStorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileStorage
     */
    select?: FileStorageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileStorage
     */
    omit?: FileStorageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileStorageInclude<ExtArgs> | null
  }


  /**
   * Model Stat
   */

  export type AggregateStat = {
    _count: StatCountAggregateOutputType | null
    _avg: StatAvgAggregateOutputType | null
    _sum: StatSumAggregateOutputType | null
    _min: StatMinAggregateOutputType | null
    _max: StatMaxAggregateOutputType | null
  }

  export type StatAvgAggregateOutputType = {
    year: number | null
    month: number | null
    date: number | null
  }

  export type StatSumAggregateOutputType = {
    year: number | null
    month: number | null
    date: number | null
  }

  export type StatMinAggregateOutputType = {
    id: string | null
    type: $Enums.StatType | null
    userId: string | null
    projectId: string | null
    organizationId: string | null
    year: number | null
    month: number | null
    date: number | null
    updatedAt: Date | null
  }

  export type StatMaxAggregateOutputType = {
    id: string | null
    type: $Enums.StatType | null
    userId: string | null
    projectId: string | null
    organizationId: string | null
    year: number | null
    month: number | null
    date: number | null
    updatedAt: Date | null
  }

  export type StatCountAggregateOutputType = {
    id: number
    type: number
    data: number
    userId: number
    projectId: number
    organizationId: number
    year: number
    month: number
    date: number
    updatedAt: number
    _all: number
  }


  export type StatAvgAggregateInputType = {
    year?: true
    month?: true
    date?: true
  }

  export type StatSumAggregateInputType = {
    year?: true
    month?: true
    date?: true
  }

  export type StatMinAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    projectId?: true
    organizationId?: true
    year?: true
    month?: true
    date?: true
    updatedAt?: true
  }

  export type StatMaxAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    projectId?: true
    organizationId?: true
    year?: true
    month?: true
    date?: true
    updatedAt?: true
  }

  export type StatCountAggregateInputType = {
    id?: true
    type?: true
    data?: true
    userId?: true
    projectId?: true
    organizationId?: true
    year?: true
    month?: true
    date?: true
    updatedAt?: true
    _all?: true
  }

  export type StatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stat to aggregate.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stats
    **/
    _count?: true | StatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatMaxAggregateInputType
  }

  export type GetStatAggregateType<T extends StatAggregateArgs> = {
        [P in keyof T & keyof AggregateStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStat[P]>
      : GetScalarType<T[P], AggregateStat[P]>
  }




  export type StatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatWhereInput
    orderBy?: StatOrderByWithAggregationInput | StatOrderByWithAggregationInput[]
    by: StatScalarFieldEnum[] | StatScalarFieldEnum
    having?: StatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatCountAggregateInputType | true
    _avg?: StatAvgAggregateInputType
    _sum?: StatSumAggregateInputType
    _min?: StatMinAggregateInputType
    _max?: StatMaxAggregateInputType
  }

  export type StatGroupByOutputType = {
    id: string
    type: $Enums.StatType
    data: JsonValue | null
    userId: string | null
    projectId: string | null
    organizationId: string | null
    year: number
    month: number
    date: number
    updatedAt: Date | null
    _count: StatCountAggregateOutputType | null
    _avg: StatAvgAggregateOutputType | null
    _sum: StatSumAggregateOutputType | null
    _min: StatMinAggregateOutputType | null
    _max: StatMaxAggregateOutputType | null
  }

  type GetStatGroupByPayload<T extends StatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatGroupByOutputType[P]>
            : GetScalarType<T[P], StatGroupByOutputType[P]>
        }
      >
    >


  export type StatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    userId?: boolean
    projectId?: boolean
    organizationId?: boolean
    year?: boolean
    month?: boolean
    date?: boolean
    updatedAt?: boolean
    user?: boolean | Stat$userArgs<ExtArgs>
    project?: boolean | Stat$projectArgs<ExtArgs>
    organization?: boolean | Stat$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["stat"]>

  export type StatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    userId?: boolean
    projectId?: boolean
    organizationId?: boolean
    year?: boolean
    month?: boolean
    date?: boolean
    updatedAt?: boolean
    user?: boolean | Stat$userArgs<ExtArgs>
    project?: boolean | Stat$projectArgs<ExtArgs>
    organization?: boolean | Stat$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["stat"]>

  export type StatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    userId?: boolean
    projectId?: boolean
    organizationId?: boolean
    year?: boolean
    month?: boolean
    date?: boolean
    updatedAt?: boolean
    user?: boolean | Stat$userArgs<ExtArgs>
    project?: boolean | Stat$projectArgs<ExtArgs>
    organization?: boolean | Stat$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["stat"]>

  export type StatSelectScalar = {
    id?: boolean
    type?: boolean
    data?: boolean
    userId?: boolean
    projectId?: boolean
    organizationId?: boolean
    year?: boolean
    month?: boolean
    date?: boolean
    updatedAt?: boolean
  }

  export type StatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "data" | "userId" | "projectId" | "organizationId" | "year" | "month" | "date" | "updatedAt", ExtArgs["result"]["stat"]>
  export type StatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Stat$userArgs<ExtArgs>
    project?: boolean | Stat$projectArgs<ExtArgs>
    organization?: boolean | Stat$organizationArgs<ExtArgs>
  }
  export type StatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Stat$userArgs<ExtArgs>
    project?: boolean | Stat$projectArgs<ExtArgs>
    organization?: boolean | Stat$organizationArgs<ExtArgs>
  }
  export type StatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Stat$userArgs<ExtArgs>
    project?: boolean | Stat$projectArgs<ExtArgs>
    organization?: boolean | Stat$organizationArgs<ExtArgs>
  }

  export type $StatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stat"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.StatType
      data: Prisma.JsonValue | null
      userId: string | null
      projectId: string | null
      organizationId: string | null
      year: number
      month: number
      date: number
      updatedAt: Date | null
    }, ExtArgs["result"]["stat"]>
    composites: {}
  }

  type StatGetPayload<S extends boolean | null | undefined | StatDefaultArgs> = $Result.GetResult<Prisma.$StatPayload, S>

  type StatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatCountAggregateInputType | true
    }

  export interface StatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stat'], meta: { name: 'Stat' } }
    /**
     * Find zero or one Stat that matches the filter.
     * @param {StatFindUniqueArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatFindUniqueArgs>(args: SelectSubset<T, StatFindUniqueArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatFindUniqueOrThrowArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatFindUniqueOrThrowArgs>(args: SelectSubset<T, StatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatFindFirstArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatFindFirstArgs>(args?: SelectSubset<T, StatFindFirstArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatFindFirstOrThrowArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatFindFirstOrThrowArgs>(args?: SelectSubset<T, StatFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stats
     * const stats = await prisma.stat.findMany()
     * 
     * // Get first 10 Stats
     * const stats = await prisma.stat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statWithIdOnly = await prisma.stat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatFindManyArgs>(args?: SelectSubset<T, StatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stat.
     * @param {StatCreateArgs} args - Arguments to create a Stat.
     * @example
     * // Create one Stat
     * const Stat = await prisma.stat.create({
     *   data: {
     *     // ... data to create a Stat
     *   }
     * })
     * 
     */
    create<T extends StatCreateArgs>(args: SelectSubset<T, StatCreateArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stats.
     * @param {StatCreateManyArgs} args - Arguments to create many Stats.
     * @example
     * // Create many Stats
     * const stat = await prisma.stat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatCreateManyArgs>(args?: SelectSubset<T, StatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stats and returns the data saved in the database.
     * @param {StatCreateManyAndReturnArgs} args - Arguments to create many Stats.
     * @example
     * // Create many Stats
     * const stat = await prisma.stat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stats and only return the `id`
     * const statWithIdOnly = await prisma.stat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatCreateManyAndReturnArgs>(args?: SelectSubset<T, StatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stat.
     * @param {StatDeleteArgs} args - Arguments to delete one Stat.
     * @example
     * // Delete one Stat
     * const Stat = await prisma.stat.delete({
     *   where: {
     *     // ... filter to delete one Stat
     *   }
     * })
     * 
     */
    delete<T extends StatDeleteArgs>(args: SelectSubset<T, StatDeleteArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stat.
     * @param {StatUpdateArgs} args - Arguments to update one Stat.
     * @example
     * // Update one Stat
     * const stat = await prisma.stat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatUpdateArgs>(args: SelectSubset<T, StatUpdateArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stats.
     * @param {StatDeleteManyArgs} args - Arguments to filter Stats to delete.
     * @example
     * // Delete a few Stats
     * const { count } = await prisma.stat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatDeleteManyArgs>(args?: SelectSubset<T, StatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stats
     * const stat = await prisma.stat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatUpdateManyArgs>(args: SelectSubset<T, StatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stats and returns the data updated in the database.
     * @param {StatUpdateManyAndReturnArgs} args - Arguments to update many Stats.
     * @example
     * // Update many Stats
     * const stat = await prisma.stat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stats and only return the `id`
     * const statWithIdOnly = await prisma.stat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StatUpdateManyAndReturnArgs>(args: SelectSubset<T, StatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stat.
     * @param {StatUpsertArgs} args - Arguments to update or create a Stat.
     * @example
     * // Update or create a Stat
     * const stat = await prisma.stat.upsert({
     *   create: {
     *     // ... data to create a Stat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stat we want to update
     *   }
     * })
     */
    upsert<T extends StatUpsertArgs>(args: SelectSubset<T, StatUpsertArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatCountArgs} args - Arguments to filter Stats to count.
     * @example
     * // Count the number of Stats
     * const count = await prisma.stat.count({
     *   where: {
     *     // ... the filter for the Stats we want to count
     *   }
     * })
    **/
    count<T extends StatCountArgs>(
      args?: Subset<T, StatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatAggregateArgs>(args: Subset<T, StatAggregateArgs>): Prisma.PrismaPromise<GetStatAggregateType<T>>

    /**
     * Group by Stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatGroupByArgs['orderBy'] }
        : { orderBy?: StatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stat model
   */
  readonly fields: StatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Stat$userArgs<ExtArgs> = {}>(args?: Subset<T, Stat$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends Stat$projectArgs<ExtArgs> = {}>(args?: Subset<T, Stat$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organization<T extends Stat$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Stat$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stat model
   */
  interface StatFieldRefs {
    readonly id: FieldRef<"Stat", 'String'>
    readonly type: FieldRef<"Stat", 'StatType'>
    readonly data: FieldRef<"Stat", 'Json'>
    readonly userId: FieldRef<"Stat", 'String'>
    readonly projectId: FieldRef<"Stat", 'String'>
    readonly organizationId: FieldRef<"Stat", 'String'>
    readonly year: FieldRef<"Stat", 'Int'>
    readonly month: FieldRef<"Stat", 'Int'>
    readonly date: FieldRef<"Stat", 'Int'>
    readonly updatedAt: FieldRef<"Stat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stat findUnique
   */
  export type StatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat findUniqueOrThrow
   */
  export type StatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat findFirst
   */
  export type StatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stats.
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stats.
     */
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Stat findFirstOrThrow
   */
  export type StatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stats.
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stats.
     */
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Stat findMany
   */
  export type StatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stats to fetch.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stats.
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Stat create
   */
  export type StatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * The data needed to create a Stat.
     */
    data: XOR<StatCreateInput, StatUncheckedCreateInput>
  }

  /**
   * Stat createMany
   */
  export type StatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stats.
     */
    data: StatCreateManyInput | StatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stat createManyAndReturn
   */
  export type StatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * The data used to create many Stats.
     */
    data: StatCreateManyInput | StatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stat update
   */
  export type StatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * The data needed to update a Stat.
     */
    data: XOR<StatUpdateInput, StatUncheckedUpdateInput>
    /**
     * Choose, which Stat to update.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat updateMany
   */
  export type StatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stats.
     */
    data: XOR<StatUpdateManyMutationInput, StatUncheckedUpdateManyInput>
    /**
     * Filter which Stats to update
     */
    where?: StatWhereInput
    /**
     * Limit how many Stats to update.
     */
    limit?: number
  }

  /**
   * Stat updateManyAndReturn
   */
  export type StatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * The data used to update Stats.
     */
    data: XOR<StatUpdateManyMutationInput, StatUncheckedUpdateManyInput>
    /**
     * Filter which Stats to update
     */
    where?: StatWhereInput
    /**
     * Limit how many Stats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stat upsert
   */
  export type StatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * The filter to search for the Stat to update in case it exists.
     */
    where: StatWhereUniqueInput
    /**
     * In case the Stat found by the `where` argument doesn't exist, create a new Stat with this data.
     */
    create: XOR<StatCreateInput, StatUncheckedCreateInput>
    /**
     * In case the Stat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatUpdateInput, StatUncheckedUpdateInput>
  }

  /**
   * Stat delete
   */
  export type StatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter which Stat to delete.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat deleteMany
   */
  export type StatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stats to delete
     */
    where?: StatWhereInput
    /**
     * Limit how many Stats to delete.
     */
    limit?: number
  }

  /**
   * Stat.user
   */
  export type Stat$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Stat.project
   */
  export type Stat$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Stat.organization
   */
  export type Stat$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Stat without action
   */
  export type StatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
  }


  /**
   * Model Dashboard
   */

  export type AggregateDashboard = {
    _count: DashboardCountAggregateOutputType | null
    _min: DashboardMinAggregateOutputType | null
    _max: DashboardMaxAggregateOutputType | null
  }

  export type DashboardMinAggregateOutputType = {
    id: string | null
    title: string | null
    projectId: string | null
    isDefault: boolean | null
  }

  export type DashboardMaxAggregateOutputType = {
    id: string | null
    title: string | null
    projectId: string | null
    isDefault: boolean | null
  }

  export type DashboardCountAggregateOutputType = {
    id: number
    title: number
    projectId: number
    isDefault: number
    _all: number
  }


  export type DashboardMinAggregateInputType = {
    id?: true
    title?: true
    projectId?: true
    isDefault?: true
  }

  export type DashboardMaxAggregateInputType = {
    id?: true
    title?: true
    projectId?: true
    isDefault?: true
  }

  export type DashboardCountAggregateInputType = {
    id?: true
    title?: true
    projectId?: true
    isDefault?: true
    _all?: true
  }

  export type DashboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboard to aggregate.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dashboards
    **/
    _count?: true | DashboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardMaxAggregateInputType
  }

  export type GetDashboardAggregateType<T extends DashboardAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboard[P]>
      : GetScalarType<T[P], AggregateDashboard[P]>
  }




  export type DashboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardWhereInput
    orderBy?: DashboardOrderByWithAggregationInput | DashboardOrderByWithAggregationInput[]
    by: DashboardScalarFieldEnum[] | DashboardScalarFieldEnum
    having?: DashboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardCountAggregateInputType | true
    _min?: DashboardMinAggregateInputType
    _max?: DashboardMaxAggregateInputType
  }

  export type DashboardGroupByOutputType = {
    id: string
    title: string | null
    projectId: string | null
    isDefault: boolean | null
    _count: DashboardCountAggregateOutputType | null
    _min: DashboardMinAggregateOutputType | null
    _max: DashboardMaxAggregateOutputType | null
  }

  type GetDashboardGroupByPayload<T extends DashboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardGroupByOutputType[P]>
        }
      >
    >


  export type DashboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    projectId?: boolean
    isDefault?: boolean
    dashboardComponents?: boolean | Dashboard$dashboardComponentsArgs<ExtArgs>
    project?: boolean | Dashboard$projectArgs<ExtArgs>
    _count?: boolean | DashboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    projectId?: boolean
    isDefault?: boolean
    project?: boolean | Dashboard$projectArgs<ExtArgs>
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    projectId?: boolean
    isDefault?: boolean
    project?: boolean | Dashboard$projectArgs<ExtArgs>
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectScalar = {
    id?: boolean
    title?: boolean
    projectId?: boolean
    isDefault?: boolean
  }

  export type DashboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "projectId" | "isDefault", ExtArgs["result"]["dashboard"]>
  export type DashboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboardComponents?: boolean | Dashboard$dashboardComponentsArgs<ExtArgs>
    project?: boolean | Dashboard$projectArgs<ExtArgs>
    _count?: boolean | DashboardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DashboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Dashboard$projectArgs<ExtArgs>
  }
  export type DashboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Dashboard$projectArgs<ExtArgs>
  }

  export type $DashboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dashboard"
    objects: {
      dashboardComponents: Prisma.$DashboardComponentPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      projectId: string | null
      isDefault: boolean | null
    }, ExtArgs["result"]["dashboard"]>
    composites: {}
  }

  type DashboardGetPayload<S extends boolean | null | undefined | DashboardDefaultArgs> = $Result.GetResult<Prisma.$DashboardPayload, S>

  type DashboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardCountAggregateInputType | true
    }

  export interface DashboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dashboard'], meta: { name: 'Dashboard' } }
    /**
     * Find zero or one Dashboard that matches the filter.
     * @param {DashboardFindUniqueArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardFindUniqueArgs>(args: SelectSubset<T, DashboardFindUniqueArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dashboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardFindUniqueOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dashboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardFindFirstArgs>(args?: SelectSubset<T, DashboardFindFirstArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dashboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dashboards
     * const dashboards = await prisma.dashboard.findMany()
     * 
     * // Get first 10 Dashboards
     * const dashboards = await prisma.dashboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardFindManyArgs>(args?: SelectSubset<T, DashboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dashboard.
     * @param {DashboardCreateArgs} args - Arguments to create a Dashboard.
     * @example
     * // Create one Dashboard
     * const Dashboard = await prisma.dashboard.create({
     *   data: {
     *     // ... data to create a Dashboard
     *   }
     * })
     * 
     */
    create<T extends DashboardCreateArgs>(args: SelectSubset<T, DashboardCreateArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dashboards.
     * @param {DashboardCreateManyArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardCreateManyArgs>(args?: SelectSubset<T, DashboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dashboards and returns the data saved in the database.
     * @param {DashboardCreateManyAndReturnArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dashboard.
     * @param {DashboardDeleteArgs} args - Arguments to delete one Dashboard.
     * @example
     * // Delete one Dashboard
     * const Dashboard = await prisma.dashboard.delete({
     *   where: {
     *     // ... filter to delete one Dashboard
     *   }
     * })
     * 
     */
    delete<T extends DashboardDeleteArgs>(args: SelectSubset<T, DashboardDeleteArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dashboard.
     * @param {DashboardUpdateArgs} args - Arguments to update one Dashboard.
     * @example
     * // Update one Dashboard
     * const dashboard = await prisma.dashboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardUpdateArgs>(args: SelectSubset<T, DashboardUpdateArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dashboards.
     * @param {DashboardDeleteManyArgs} args - Arguments to filter Dashboards to delete.
     * @example
     * // Delete a few Dashboards
     * const { count } = await prisma.dashboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardDeleteManyArgs>(args?: SelectSubset<T, DashboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardUpdateManyArgs>(args: SelectSubset<T, DashboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboards and returns the data updated in the database.
     * @param {DashboardUpdateManyAndReturnArgs} args - Arguments to update many Dashboards.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dashboard.
     * @param {DashboardUpsertArgs} args - Arguments to update or create a Dashboard.
     * @example
     * // Update or create a Dashboard
     * const dashboard = await prisma.dashboard.upsert({
     *   create: {
     *     // ... data to create a Dashboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dashboard we want to update
     *   }
     * })
     */
    upsert<T extends DashboardUpsertArgs>(args: SelectSubset<T, DashboardUpsertArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardCountArgs} args - Arguments to filter Dashboards to count.
     * @example
     * // Count the number of Dashboards
     * const count = await prisma.dashboard.count({
     *   where: {
     *     // ... the filter for the Dashboards we want to count
     *   }
     * })
    **/
    count<T extends DashboardCountArgs>(
      args?: Subset<T, DashboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardAggregateArgs>(args: Subset<T, DashboardAggregateArgs>): Prisma.PrismaPromise<GetDashboardAggregateType<T>>

    /**
     * Group by Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardGroupByArgs['orderBy'] }
        : { orderBy?: DashboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dashboard model
   */
  readonly fields: DashboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dashboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dashboardComponents<T extends Dashboard$dashboardComponentsArgs<ExtArgs> = {}>(args?: Subset<T, Dashboard$dashboardComponentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends Dashboard$projectArgs<ExtArgs> = {}>(args?: Subset<T, Dashboard$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dashboard model
   */
  interface DashboardFieldRefs {
    readonly id: FieldRef<"Dashboard", 'String'>
    readonly title: FieldRef<"Dashboard", 'String'>
    readonly projectId: FieldRef<"Dashboard", 'String'>
    readonly isDefault: FieldRef<"Dashboard", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Dashboard findUnique
   */
  export type DashboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard findUniqueOrThrow
   */
  export type DashboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard findFirst
   */
  export type DashboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Dashboard findFirstOrThrow
   */
  export type DashboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Dashboard findMany
   */
  export type DashboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboards to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Dashboard create
   */
  export type DashboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Dashboard.
     */
    data?: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>
  }

  /**
   * Dashboard createMany
   */
  export type DashboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dashboard createManyAndReturn
   */
  export type DashboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dashboard update
   */
  export type DashboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Dashboard.
     */
    data: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>
    /**
     * Choose, which Dashboard to update.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard updateMany
   */
  export type DashboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number
  }

  /**
   * Dashboard updateManyAndReturn
   */
  export type DashboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dashboard upsert
   */
  export type DashboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Dashboard to update in case it exists.
     */
    where: DashboardWhereUniqueInput
    /**
     * In case the Dashboard found by the `where` argument doesn't exist, create a new Dashboard with this data.
     */
    create: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>
    /**
     * In case the Dashboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>
  }

  /**
   * Dashboard delete
   */
  export type DashboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter which Dashboard to delete.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard deleteMany
   */
  export type DashboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboards to delete
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to delete.
     */
    limit?: number
  }

  /**
   * Dashboard.dashboardComponents
   */
  export type Dashboard$dashboardComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    where?: DashboardComponentWhereInput
    orderBy?: DashboardComponentOrderByWithRelationInput | DashboardComponentOrderByWithRelationInput[]
    cursor?: DashboardComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DashboardComponentScalarFieldEnum | DashboardComponentScalarFieldEnum[]
  }

  /**
   * Dashboard.project
   */
  export type Dashboard$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Dashboard without action
   */
  export type DashboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
  }


  /**
   * Model DashboardComponent
   */

  export type AggregateDashboardComponent = {
    _count: DashboardComponentCountAggregateOutputType | null
    _avg: DashboardComponentAvgAggregateOutputType | null
    _sum: DashboardComponentSumAggregateOutputType | null
    _min: DashboardComponentMinAggregateOutputType | null
    _max: DashboardComponentMaxAggregateOutputType | null
  }

  export type DashboardComponentAvgAggregateOutputType = {
    x: number | null
    y: number | null
    width: number | null
    height: number | null
  }

  export type DashboardComponentSumAggregateOutputType = {
    x: number | null
    y: number | null
    width: number | null
    height: number | null
  }

  export type DashboardComponentMinAggregateOutputType = {
    id: string | null
    dashboardId: string | null
    title: string | null
    type: $Enums.DashboardComponentType | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    createdAt: Date | null
    createdBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type DashboardComponentMaxAggregateOutputType = {
    id: string | null
    dashboardId: string | null
    title: string | null
    type: $Enums.DashboardComponentType | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    createdAt: Date | null
    createdBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type DashboardComponentCountAggregateOutputType = {
    id: number
    dashboardId: number
    title: number
    type: number
    config: number
    x: number
    y: number
    width: number
    height: number
    createdAt: number
    createdBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type DashboardComponentAvgAggregateInputType = {
    x?: true
    y?: true
    width?: true
    height?: true
  }

  export type DashboardComponentSumAggregateInputType = {
    x?: true
    y?: true
    width?: true
    height?: true
  }

  export type DashboardComponentMinAggregateInputType = {
    id?: true
    dashboardId?: true
    title?: true
    type?: true
    x?: true
    y?: true
    width?: true
    height?: true
    createdAt?: true
    createdBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type DashboardComponentMaxAggregateInputType = {
    id?: true
    dashboardId?: true
    title?: true
    type?: true
    x?: true
    y?: true
    width?: true
    height?: true
    createdAt?: true
    createdBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type DashboardComponentCountAggregateInputType = {
    id?: true
    dashboardId?: true
    title?: true
    type?: true
    config?: true
    x?: true
    y?: true
    width?: true
    height?: true
    createdAt?: true
    createdBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type DashboardComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardComponent to aggregate.
     */
    where?: DashboardComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardComponents to fetch.
     */
    orderBy?: DashboardComponentOrderByWithRelationInput | DashboardComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardComponents
    **/
    _count?: true | DashboardComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardComponentMaxAggregateInputType
  }

  export type GetDashboardComponentAggregateType<T extends DashboardComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardComponent[P]>
      : GetScalarType<T[P], AggregateDashboardComponent[P]>
  }




  export type DashboardComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardComponentWhereInput
    orderBy?: DashboardComponentOrderByWithAggregationInput | DashboardComponentOrderByWithAggregationInput[]
    by: DashboardComponentScalarFieldEnum[] | DashboardComponentScalarFieldEnum
    having?: DashboardComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardComponentCountAggregateInputType | true
    _avg?: DashboardComponentAvgAggregateInputType
    _sum?: DashboardComponentSumAggregateInputType
    _min?: DashboardComponentMinAggregateInputType
    _max?: DashboardComponentMaxAggregateInputType
  }

  export type DashboardComponentGroupByOutputType = {
    id: string
    dashboardId: string | null
    title: string | null
    type: $Enums.DashboardComponentType | null
    config: JsonValue | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    createdAt: Date
    createdBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: DashboardComponentCountAggregateOutputType | null
    _avg: DashboardComponentAvgAggregateOutputType | null
    _sum: DashboardComponentSumAggregateOutputType | null
    _min: DashboardComponentMinAggregateOutputType | null
    _max: DashboardComponentMaxAggregateOutputType | null
  }

  type GetDashboardComponentGroupByPayload<T extends DashboardComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardComponentGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardComponentGroupByOutputType[P]>
        }
      >
    >


  export type DashboardComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dashboardId?: boolean
    title?: boolean
    type?: boolean
    config?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    dashboard?: boolean | DashboardComponent$dashboardArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardComponent"]>

  export type DashboardComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dashboardId?: boolean
    title?: boolean
    type?: boolean
    config?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    dashboard?: boolean | DashboardComponent$dashboardArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardComponent"]>

  export type DashboardComponentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dashboardId?: boolean
    title?: boolean
    type?: boolean
    config?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    dashboard?: boolean | DashboardComponent$dashboardArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardComponent"]>

  export type DashboardComponentSelectScalar = {
    id?: boolean
    dashboardId?: boolean
    title?: boolean
    type?: boolean
    config?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    createdBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type DashboardComponentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dashboardId" | "title" | "type" | "config" | "x" | "y" | "width" | "height" | "createdAt" | "createdBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["dashboardComponent"]>
  export type DashboardComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardComponent$dashboardArgs<ExtArgs>
  }
  export type DashboardComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardComponent$dashboardArgs<ExtArgs>
  }
  export type DashboardComponentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardComponent$dashboardArgs<ExtArgs>
  }

  export type $DashboardComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardComponent"
    objects: {
      dashboard: Prisma.$DashboardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dashboardId: string | null
      title: string | null
      type: $Enums.DashboardComponentType | null
      config: Prisma.JsonValue | null
      x: number | null
      y: number | null
      width: number | null
      height: number | null
      createdAt: Date
      createdBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["dashboardComponent"]>
    composites: {}
  }

  type DashboardComponentGetPayload<S extends boolean | null | undefined | DashboardComponentDefaultArgs> = $Result.GetResult<Prisma.$DashboardComponentPayload, S>

  type DashboardComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardComponentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardComponentCountAggregateInputType | true
    }

  export interface DashboardComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardComponent'], meta: { name: 'DashboardComponent' } }
    /**
     * Find zero or one DashboardComponent that matches the filter.
     * @param {DashboardComponentFindUniqueArgs} args - Arguments to find a DashboardComponent
     * @example
     * // Get one DashboardComponent
     * const dashboardComponent = await prisma.dashboardComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardComponentFindUniqueArgs>(args: SelectSubset<T, DashboardComponentFindUniqueArgs<ExtArgs>>): Prisma__DashboardComponentClient<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DashboardComponent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardComponentFindUniqueOrThrowArgs} args - Arguments to find a DashboardComponent
     * @example
     * // Get one DashboardComponent
     * const dashboardComponent = await prisma.dashboardComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardComponentClient<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardComponentFindFirstArgs} args - Arguments to find a DashboardComponent
     * @example
     * // Get one DashboardComponent
     * const dashboardComponent = await prisma.dashboardComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardComponentFindFirstArgs>(args?: SelectSubset<T, DashboardComponentFindFirstArgs<ExtArgs>>): Prisma__DashboardComponentClient<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardComponentFindFirstOrThrowArgs} args - Arguments to find a DashboardComponent
     * @example
     * // Get one DashboardComponent
     * const dashboardComponent = await prisma.dashboardComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardComponentClient<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DashboardComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardComponents
     * const dashboardComponents = await prisma.dashboardComponent.findMany()
     * 
     * // Get first 10 DashboardComponents
     * const dashboardComponents = await prisma.dashboardComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardComponentWithIdOnly = await prisma.dashboardComponent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardComponentFindManyArgs>(args?: SelectSubset<T, DashboardComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DashboardComponent.
     * @param {DashboardComponentCreateArgs} args - Arguments to create a DashboardComponent.
     * @example
     * // Create one DashboardComponent
     * const DashboardComponent = await prisma.dashboardComponent.create({
     *   data: {
     *     // ... data to create a DashboardComponent
     *   }
     * })
     * 
     */
    create<T extends DashboardComponentCreateArgs>(args: SelectSubset<T, DashboardComponentCreateArgs<ExtArgs>>): Prisma__DashboardComponentClient<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DashboardComponents.
     * @param {DashboardComponentCreateManyArgs} args - Arguments to create many DashboardComponents.
     * @example
     * // Create many DashboardComponents
     * const dashboardComponent = await prisma.dashboardComponent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardComponentCreateManyArgs>(args?: SelectSubset<T, DashboardComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardComponents and returns the data saved in the database.
     * @param {DashboardComponentCreateManyAndReturnArgs} args - Arguments to create many DashboardComponents.
     * @example
     * // Create many DashboardComponents
     * const dashboardComponent = await prisma.dashboardComponent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardComponents and only return the `id`
     * const dashboardComponentWithIdOnly = await prisma.dashboardComponent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DashboardComponent.
     * @param {DashboardComponentDeleteArgs} args - Arguments to delete one DashboardComponent.
     * @example
     * // Delete one DashboardComponent
     * const DashboardComponent = await prisma.dashboardComponent.delete({
     *   where: {
     *     // ... filter to delete one DashboardComponent
     *   }
     * })
     * 
     */
    delete<T extends DashboardComponentDeleteArgs>(args: SelectSubset<T, DashboardComponentDeleteArgs<ExtArgs>>): Prisma__DashboardComponentClient<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DashboardComponent.
     * @param {DashboardComponentUpdateArgs} args - Arguments to update one DashboardComponent.
     * @example
     * // Update one DashboardComponent
     * const dashboardComponent = await prisma.dashboardComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardComponentUpdateArgs>(args: SelectSubset<T, DashboardComponentUpdateArgs<ExtArgs>>): Prisma__DashboardComponentClient<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DashboardComponents.
     * @param {DashboardComponentDeleteManyArgs} args - Arguments to filter DashboardComponents to delete.
     * @example
     * // Delete a few DashboardComponents
     * const { count } = await prisma.dashboardComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardComponentDeleteManyArgs>(args?: SelectSubset<T, DashboardComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardComponents
     * const dashboardComponent = await prisma.dashboardComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardComponentUpdateManyArgs>(args: SelectSubset<T, DashboardComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardComponents and returns the data updated in the database.
     * @param {DashboardComponentUpdateManyAndReturnArgs} args - Arguments to update many DashboardComponents.
     * @example
     * // Update many DashboardComponents
     * const dashboardComponent = await prisma.dashboardComponent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DashboardComponents and only return the `id`
     * const dashboardComponentWithIdOnly = await prisma.dashboardComponent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardComponentUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardComponentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DashboardComponent.
     * @param {DashboardComponentUpsertArgs} args - Arguments to update or create a DashboardComponent.
     * @example
     * // Update or create a DashboardComponent
     * const dashboardComponent = await prisma.dashboardComponent.upsert({
     *   create: {
     *     // ... data to create a DashboardComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardComponent we want to update
     *   }
     * })
     */
    upsert<T extends DashboardComponentUpsertArgs>(args: SelectSubset<T, DashboardComponentUpsertArgs<ExtArgs>>): Prisma__DashboardComponentClient<$Result.GetResult<Prisma.$DashboardComponentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DashboardComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardComponentCountArgs} args - Arguments to filter DashboardComponents to count.
     * @example
     * // Count the number of DashboardComponents
     * const count = await prisma.dashboardComponent.count({
     *   where: {
     *     // ... the filter for the DashboardComponents we want to count
     *   }
     * })
    **/
    count<T extends DashboardComponentCountArgs>(
      args?: Subset<T, DashboardComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardComponentAggregateArgs>(args: Subset<T, DashboardComponentAggregateArgs>): Prisma.PrismaPromise<GetDashboardComponentAggregateType<T>>

    /**
     * Group by DashboardComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardComponentGroupByArgs['orderBy'] }
        : { orderBy?: DashboardComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardComponent model
   */
  readonly fields: DashboardComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dashboard<T extends DashboardComponent$dashboardArgs<ExtArgs> = {}>(args?: Subset<T, DashboardComponent$dashboardArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardComponent model
   */
  interface DashboardComponentFieldRefs {
    readonly id: FieldRef<"DashboardComponent", 'String'>
    readonly dashboardId: FieldRef<"DashboardComponent", 'String'>
    readonly title: FieldRef<"DashboardComponent", 'String'>
    readonly type: FieldRef<"DashboardComponent", 'DashboardComponentType'>
    readonly config: FieldRef<"DashboardComponent", 'Json'>
    readonly x: FieldRef<"DashboardComponent", 'Int'>
    readonly y: FieldRef<"DashboardComponent", 'Int'>
    readonly width: FieldRef<"DashboardComponent", 'Int'>
    readonly height: FieldRef<"DashboardComponent", 'Int'>
    readonly createdAt: FieldRef<"DashboardComponent", 'DateTime'>
    readonly createdBy: FieldRef<"DashboardComponent", 'String'>
    readonly deletedAt: FieldRef<"DashboardComponent", 'DateTime'>
    readonly deletedBy: FieldRef<"DashboardComponent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DashboardComponent findUnique
   */
  export type DashboardComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    /**
     * Filter, which DashboardComponent to fetch.
     */
    where: DashboardComponentWhereUniqueInput
  }

  /**
   * DashboardComponent findUniqueOrThrow
   */
  export type DashboardComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    /**
     * Filter, which DashboardComponent to fetch.
     */
    where: DashboardComponentWhereUniqueInput
  }

  /**
   * DashboardComponent findFirst
   */
  export type DashboardComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    /**
     * Filter, which DashboardComponent to fetch.
     */
    where?: DashboardComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardComponents to fetch.
     */
    orderBy?: DashboardComponentOrderByWithRelationInput | DashboardComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardComponents.
     */
    cursor?: DashboardComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardComponents.
     */
    distinct?: DashboardComponentScalarFieldEnum | DashboardComponentScalarFieldEnum[]
  }

  /**
   * DashboardComponent findFirstOrThrow
   */
  export type DashboardComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    /**
     * Filter, which DashboardComponent to fetch.
     */
    where?: DashboardComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardComponents to fetch.
     */
    orderBy?: DashboardComponentOrderByWithRelationInput | DashboardComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardComponents.
     */
    cursor?: DashboardComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardComponents.
     */
    distinct?: DashboardComponentScalarFieldEnum | DashboardComponentScalarFieldEnum[]
  }

  /**
   * DashboardComponent findMany
   */
  export type DashboardComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    /**
     * Filter, which DashboardComponents to fetch.
     */
    where?: DashboardComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardComponents to fetch.
     */
    orderBy?: DashboardComponentOrderByWithRelationInput | DashboardComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardComponents.
     */
    cursor?: DashboardComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardComponents.
     */
    skip?: number
    distinct?: DashboardComponentScalarFieldEnum | DashboardComponentScalarFieldEnum[]
  }

  /**
   * DashboardComponent create
   */
  export type DashboardComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a DashboardComponent.
     */
    data?: XOR<DashboardComponentCreateInput, DashboardComponentUncheckedCreateInput>
  }

  /**
   * DashboardComponent createMany
   */
  export type DashboardComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardComponents.
     */
    data: DashboardComponentCreateManyInput | DashboardComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardComponent createManyAndReturn
   */
  export type DashboardComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * The data used to create many DashboardComponents.
     */
    data: DashboardComponentCreateManyInput | DashboardComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardComponent update
   */
  export type DashboardComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a DashboardComponent.
     */
    data: XOR<DashboardComponentUpdateInput, DashboardComponentUncheckedUpdateInput>
    /**
     * Choose, which DashboardComponent to update.
     */
    where: DashboardComponentWhereUniqueInput
  }

  /**
   * DashboardComponent updateMany
   */
  export type DashboardComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardComponents.
     */
    data: XOR<DashboardComponentUpdateManyMutationInput, DashboardComponentUncheckedUpdateManyInput>
    /**
     * Filter which DashboardComponents to update
     */
    where?: DashboardComponentWhereInput
    /**
     * Limit how many DashboardComponents to update.
     */
    limit?: number
  }

  /**
   * DashboardComponent updateManyAndReturn
   */
  export type DashboardComponentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * The data used to update DashboardComponents.
     */
    data: XOR<DashboardComponentUpdateManyMutationInput, DashboardComponentUncheckedUpdateManyInput>
    /**
     * Filter which DashboardComponents to update
     */
    where?: DashboardComponentWhereInput
    /**
     * Limit how many DashboardComponents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardComponent upsert
   */
  export type DashboardComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the DashboardComponent to update in case it exists.
     */
    where: DashboardComponentWhereUniqueInput
    /**
     * In case the DashboardComponent found by the `where` argument doesn't exist, create a new DashboardComponent with this data.
     */
    create: XOR<DashboardComponentCreateInput, DashboardComponentUncheckedCreateInput>
    /**
     * In case the DashboardComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardComponentUpdateInput, DashboardComponentUncheckedUpdateInput>
  }

  /**
   * DashboardComponent delete
   */
  export type DashboardComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
    /**
     * Filter which DashboardComponent to delete.
     */
    where: DashboardComponentWhereUniqueInput
  }

  /**
   * DashboardComponent deleteMany
   */
  export type DashboardComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardComponents to delete
     */
    where?: DashboardComponentWhereInput
    /**
     * Limit how many DashboardComponents to delete.
     */
    limit?: number
  }

  /**
   * DashboardComponent.dashboard
   */
  export type DashboardComponent$dashboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    where?: DashboardWhereInput
  }

  /**
   * DashboardComponent without action
   */
  export type DashboardComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardComponent
     */
    select?: DashboardComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardComponent
     */
    omit?: DashboardComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardComponentInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    targetId: string | null
    targetType: $Enums.ActivityTargetType | null
    type: $Enums.ActivityType | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    targetId: string | null
    targetType: $Enums.ActivityTargetType | null
    type: $Enums.ActivityType | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    targetId: number
    targetType: number
    type: number
    data: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    targetId?: true
    targetType?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    targetId?: true
    targetType?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    targetId?: true
    targetType?: true
    type?: true
    data?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    targetId: string
    targetType: $Enums.ActivityTargetType
    type: $Enums.ActivityType
    data: JsonValue | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetId?: boolean
    targetType?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetId?: boolean
    targetType?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetId?: boolean
    targetType?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    targetId?: boolean
    targetType?: boolean
    type?: boolean
    data?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "targetId" | "targetType" | "type" | "data" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["activity"]>

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      targetId: string
      targetType: $Enums.ActivityTargetType
      type: $Enums.ActivityType
      data: Prisma.JsonValue | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly targetId: FieldRef<"Activity", 'String'>
    readonly targetType: FieldRef<"Activity", 'ActivityTargetType'>
    readonly type: FieldRef<"Activity", 'ActivityType'>
    readonly data: FieldRef<"Activity", 'Json'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly createdBy: FieldRef<"Activity", 'String'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedBy: FieldRef<"Activity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    projectId: string | null
    content: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    projectId: string | null
    content: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    taskId: number
    projectId: number
    content: number
    createdAt: number
    createdBy: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    taskId?: true
    projectId?: true
    content?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    taskId?: true
    projectId?: true
    content?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    taskId?: true
    projectId?: true
    content?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    taskId: string
    projectId: string
    content: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    projectId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    projectId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    projectId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    taskId?: boolean
    projectId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "projectId" | "content" | "createdAt" | "createdBy" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      projectId: string
      content: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly taskId: FieldRef<"Comment", 'String'>
    readonly projectId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly createdBy: FieldRef<"Comment", 'String'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    clientId: string | null
    clientSecret: string | null
    organizationId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ApplicationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    clientId: string | null
    clientSecret: string | null
    organizationId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ApplicationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    clientId: number
    clientSecret: number
    organizationId: number
    scopes: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ApplicationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    clientId?: true
    clientSecret?: true
    organizationId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ApplicationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    clientId?: true
    clientSecret?: true
    organizationId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ApplicationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    clientId?: true
    clientSecret?: true
    organizationId?: true
    scopes?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    clientId: string
    clientSecret: string
    organizationId: string
    scopes: string[]
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    clientSecret?: boolean
    organizationId?: boolean
    scopes?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    clientSecret?: boolean
    organizationId?: boolean
    scopes?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    clientSecret?: boolean
    organizationId?: boolean
    scopes?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    clientSecret?: boolean
    organizationId?: boolean
    scopes?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "clientId" | "clientSecret" | "organizationId" | "scopes" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["application"]>
  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      clientId: string
      clientSecret: string
      organizationId: string
      scopes: string[]
      createdAt: Date | null
      createdBy: string | null
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {ApplicationCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications and returns the data updated in the database.
     * @param {ApplicationUpdateManyAndReturnArgs} args - Arguments to update many Applications.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */
  interface ApplicationFieldRefs {
    readonly id: FieldRef<"Application", 'String'>
    readonly name: FieldRef<"Application", 'String'>
    readonly description: FieldRef<"Application", 'String'>
    readonly clientId: FieldRef<"Application", 'String'>
    readonly clientSecret: FieldRef<"Application", 'String'>
    readonly organizationId: FieldRef<"Application", 'String'>
    readonly scopes: FieldRef<"Application", 'String[]'>
    readonly createdAt: FieldRef<"Application", 'DateTime'>
    readonly createdBy: FieldRef<"Application", 'String'>
    readonly updatedAt: FieldRef<"Application", 'DateTime'>
    readonly updatedBy: FieldRef<"Application", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application createManyAndReturn
   */
  export type ApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to update.
     */
    limit?: number
  }

  /**
   * Application updateManyAndReturn
   */
  export type ApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to delete.
     */
    limit?: number
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model Timer
   */

  export type AggregateTimer = {
    _count: TimerCountAggregateOutputType | null
    _avg: TimerAvgAggregateOutputType | null
    _sum: TimerSumAggregateOutputType | null
    _min: TimerMinAggregateOutputType | null
    _max: TimerMaxAggregateOutputType | null
  }

  export type TimerAvgAggregateOutputType = {
    duration: number | null
  }

  export type TimerSumAggregateOutputType = {
    duration: number | null
  }

  export type TimerMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimerMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimerCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    startTime: number
    endTime: number
    duration: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimerAvgAggregateInputType = {
    duration?: true
  }

  export type TimerSumAggregateInputType = {
    duration?: true
  }

  export type TimerMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    startTime?: true
    endTime?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimerMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    startTime?: true
    endTime?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimerCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    startTime?: true
    endTime?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timer to aggregate.
     */
    where?: TimerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timers to fetch.
     */
    orderBy?: TimerOrderByWithRelationInput | TimerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Timers
    **/
    _count?: true | TimerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimerMaxAggregateInputType
  }

  export type GetTimerAggregateType<T extends TimerAggregateArgs> = {
        [P in keyof T & keyof AggregateTimer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimer[P]>
      : GetScalarType<T[P], AggregateTimer[P]>
  }




  export type TimerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimerWhereInput
    orderBy?: TimerOrderByWithAggregationInput | TimerOrderByWithAggregationInput[]
    by: TimerScalarFieldEnum[] | TimerScalarFieldEnum
    having?: TimerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimerCountAggregateInputType | true
    _avg?: TimerAvgAggregateInputType
    _sum?: TimerSumAggregateInputType
    _min?: TimerMinAggregateInputType
    _max?: TimerMaxAggregateInputType
  }

  export type TimerGroupByOutputType = {
    id: string
    taskId: string
    userId: string
    startTime: Date
    endTime: Date | null
    duration: number
    createdAt: Date
    updatedAt: Date
    _count: TimerCountAggregateOutputType | null
    _avg: TimerAvgAggregateOutputType | null
    _sum: TimerSumAggregateOutputType | null
    _min: TimerMinAggregateOutputType | null
    _max: TimerMaxAggregateOutputType | null
  }

  type GetTimerGroupByPayload<T extends TimerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimerGroupByOutputType[P]>
            : GetScalarType<T[P], TimerGroupByOutputType[P]>
        }
      >
    >


  export type TimerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timer"]>

  export type TimerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timer"]>

  export type TimerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timer"]>

  export type TimerSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "startTime" | "endTime" | "duration" | "createdAt" | "updatedAt", ExtArgs["result"]["timer"]>
  export type TimerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TimerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Timer"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      userId: string
      startTime: Date
      endTime: Date | null
      duration: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timer"]>
    composites: {}
  }

  type TimerGetPayload<S extends boolean | null | undefined | TimerDefaultArgs> = $Result.GetResult<Prisma.$TimerPayload, S>

  type TimerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimerCountAggregateInputType | true
    }

  export interface TimerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Timer'], meta: { name: 'Timer' } }
    /**
     * Find zero or one Timer that matches the filter.
     * @param {TimerFindUniqueArgs} args - Arguments to find a Timer
     * @example
     * // Get one Timer
     * const timer = await prisma.timer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimerFindUniqueArgs>(args: SelectSubset<T, TimerFindUniqueArgs<ExtArgs>>): Prisma__TimerClient<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Timer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimerFindUniqueOrThrowArgs} args - Arguments to find a Timer
     * @example
     * // Get one Timer
     * const timer = await prisma.timer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimerFindUniqueOrThrowArgs>(args: SelectSubset<T, TimerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimerClient<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimerFindFirstArgs} args - Arguments to find a Timer
     * @example
     * // Get one Timer
     * const timer = await prisma.timer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimerFindFirstArgs>(args?: SelectSubset<T, TimerFindFirstArgs<ExtArgs>>): Prisma__TimerClient<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimerFindFirstOrThrowArgs} args - Arguments to find a Timer
     * @example
     * // Get one Timer
     * const timer = await prisma.timer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimerFindFirstOrThrowArgs>(args?: SelectSubset<T, TimerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimerClient<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Timers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timers
     * const timers = await prisma.timer.findMany()
     * 
     * // Get first 10 Timers
     * const timers = await prisma.timer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timerWithIdOnly = await prisma.timer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimerFindManyArgs>(args?: SelectSubset<T, TimerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Timer.
     * @param {TimerCreateArgs} args - Arguments to create a Timer.
     * @example
     * // Create one Timer
     * const Timer = await prisma.timer.create({
     *   data: {
     *     // ... data to create a Timer
     *   }
     * })
     * 
     */
    create<T extends TimerCreateArgs>(args: SelectSubset<T, TimerCreateArgs<ExtArgs>>): Prisma__TimerClient<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Timers.
     * @param {TimerCreateManyArgs} args - Arguments to create many Timers.
     * @example
     * // Create many Timers
     * const timer = await prisma.timer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimerCreateManyArgs>(args?: SelectSubset<T, TimerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Timers and returns the data saved in the database.
     * @param {TimerCreateManyAndReturnArgs} args - Arguments to create many Timers.
     * @example
     * // Create many Timers
     * const timer = await prisma.timer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Timers and only return the `id`
     * const timerWithIdOnly = await prisma.timer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimerCreateManyAndReturnArgs>(args?: SelectSubset<T, TimerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Timer.
     * @param {TimerDeleteArgs} args - Arguments to delete one Timer.
     * @example
     * // Delete one Timer
     * const Timer = await prisma.timer.delete({
     *   where: {
     *     // ... filter to delete one Timer
     *   }
     * })
     * 
     */
    delete<T extends TimerDeleteArgs>(args: SelectSubset<T, TimerDeleteArgs<ExtArgs>>): Prisma__TimerClient<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Timer.
     * @param {TimerUpdateArgs} args - Arguments to update one Timer.
     * @example
     * // Update one Timer
     * const timer = await prisma.timer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimerUpdateArgs>(args: SelectSubset<T, TimerUpdateArgs<ExtArgs>>): Prisma__TimerClient<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Timers.
     * @param {TimerDeleteManyArgs} args - Arguments to filter Timers to delete.
     * @example
     * // Delete a few Timers
     * const { count } = await prisma.timer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimerDeleteManyArgs>(args?: SelectSubset<T, TimerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timers
     * const timer = await prisma.timer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimerUpdateManyArgs>(args: SelectSubset<T, TimerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timers and returns the data updated in the database.
     * @param {TimerUpdateManyAndReturnArgs} args - Arguments to update many Timers.
     * @example
     * // Update many Timers
     * const timer = await prisma.timer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Timers and only return the `id`
     * const timerWithIdOnly = await prisma.timer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimerUpdateManyAndReturnArgs>(args: SelectSubset<T, TimerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Timer.
     * @param {TimerUpsertArgs} args - Arguments to update or create a Timer.
     * @example
     * // Update or create a Timer
     * const timer = await prisma.timer.upsert({
     *   create: {
     *     // ... data to create a Timer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timer we want to update
     *   }
     * })
     */
    upsert<T extends TimerUpsertArgs>(args: SelectSubset<T, TimerUpsertArgs<ExtArgs>>): Prisma__TimerClient<$Result.GetResult<Prisma.$TimerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Timers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimerCountArgs} args - Arguments to filter Timers to count.
     * @example
     * // Count the number of Timers
     * const count = await prisma.timer.count({
     *   where: {
     *     // ... the filter for the Timers we want to count
     *   }
     * })
    **/
    count<T extends TimerCountArgs>(
      args?: Subset<T, TimerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimerAggregateArgs>(args: Subset<T, TimerAggregateArgs>): Prisma.PrismaPromise<GetTimerAggregateType<T>>

    /**
     * Group by Timer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimerGroupByArgs['orderBy'] }
        : { orderBy?: TimerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Timer model
   */
  readonly fields: TimerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Timer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Timer model
   */
  interface TimerFieldRefs {
    readonly id: FieldRef<"Timer", 'String'>
    readonly taskId: FieldRef<"Timer", 'String'>
    readonly userId: FieldRef<"Timer", 'String'>
    readonly startTime: FieldRef<"Timer", 'DateTime'>
    readonly endTime: FieldRef<"Timer", 'DateTime'>
    readonly duration: FieldRef<"Timer", 'Int'>
    readonly createdAt: FieldRef<"Timer", 'DateTime'>
    readonly updatedAt: FieldRef<"Timer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Timer findUnique
   */
  export type TimerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    /**
     * Filter, which Timer to fetch.
     */
    where: TimerWhereUniqueInput
  }

  /**
   * Timer findUniqueOrThrow
   */
  export type TimerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    /**
     * Filter, which Timer to fetch.
     */
    where: TimerWhereUniqueInput
  }

  /**
   * Timer findFirst
   */
  export type TimerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    /**
     * Filter, which Timer to fetch.
     */
    where?: TimerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timers to fetch.
     */
    orderBy?: TimerOrderByWithRelationInput | TimerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timers.
     */
    cursor?: TimerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timers.
     */
    distinct?: TimerScalarFieldEnum | TimerScalarFieldEnum[]
  }

  /**
   * Timer findFirstOrThrow
   */
  export type TimerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    /**
     * Filter, which Timer to fetch.
     */
    where?: TimerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timers to fetch.
     */
    orderBy?: TimerOrderByWithRelationInput | TimerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timers.
     */
    cursor?: TimerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timers.
     */
    distinct?: TimerScalarFieldEnum | TimerScalarFieldEnum[]
  }

  /**
   * Timer findMany
   */
  export type TimerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    /**
     * Filter, which Timers to fetch.
     */
    where?: TimerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timers to fetch.
     */
    orderBy?: TimerOrderByWithRelationInput | TimerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Timers.
     */
    cursor?: TimerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timers.
     */
    skip?: number
    distinct?: TimerScalarFieldEnum | TimerScalarFieldEnum[]
  }

  /**
   * Timer create
   */
  export type TimerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    /**
     * The data needed to create a Timer.
     */
    data: XOR<TimerCreateInput, TimerUncheckedCreateInput>
  }

  /**
   * Timer createMany
   */
  export type TimerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Timers.
     */
    data: TimerCreateManyInput | TimerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Timer createManyAndReturn
   */
  export type TimerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * The data used to create many Timers.
     */
    data: TimerCreateManyInput | TimerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Timer update
   */
  export type TimerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    /**
     * The data needed to update a Timer.
     */
    data: XOR<TimerUpdateInput, TimerUncheckedUpdateInput>
    /**
     * Choose, which Timer to update.
     */
    where: TimerWhereUniqueInput
  }

  /**
   * Timer updateMany
   */
  export type TimerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Timers.
     */
    data: XOR<TimerUpdateManyMutationInput, TimerUncheckedUpdateManyInput>
    /**
     * Filter which Timers to update
     */
    where?: TimerWhereInput
    /**
     * Limit how many Timers to update.
     */
    limit?: number
  }

  /**
   * Timer updateManyAndReturn
   */
  export type TimerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * The data used to update Timers.
     */
    data: XOR<TimerUpdateManyMutationInput, TimerUncheckedUpdateManyInput>
    /**
     * Filter which Timers to update
     */
    where?: TimerWhereInput
    /**
     * Limit how many Timers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Timer upsert
   */
  export type TimerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    /**
     * The filter to search for the Timer to update in case it exists.
     */
    where: TimerWhereUniqueInput
    /**
     * In case the Timer found by the `where` argument doesn't exist, create a new Timer with this data.
     */
    create: XOR<TimerCreateInput, TimerUncheckedCreateInput>
    /**
     * In case the Timer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimerUpdateInput, TimerUncheckedUpdateInput>
  }

  /**
   * Timer delete
   */
  export type TimerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
    /**
     * Filter which Timer to delete.
     */
    where: TimerWhereUniqueInput
  }

  /**
   * Timer deleteMany
   */
  export type TimerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timers to delete
     */
    where?: TimerWhereInput
    /**
     * Limit how many Timers to delete.
     */
    limit?: number
  }

  /**
   * Timer without action
   */
  export type TimerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timer
     */
    select?: TimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timer
     */
    omit?: TimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimerInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    link: string | null
    userId: string | null
    organizationId: string | null
    type: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    link: string | null
    userId: string | null
    organizationId: string | null
    type: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    link: number
    userId: number
    organizationId: number
    type: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type FavoriteMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    link?: true
    userId?: true
    organizationId?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    link?: true
    userId?: true
    organizationId?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    link?: true
    userId?: true
    organizationId?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: string
    name: string
    icon: string
    link: string
    userId: string
    organizationId: string
    type: string
    createdAt: Date
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    link?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    link?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    link?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    link?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type FavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon" | "link" | "userId" | "organizationId" | "type" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["favorite"]>
  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string
      link: string
      userId: string
      organizationId: string
      type: string
      createdAt: Date
      createdBy: string | null
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites and returns the data updated in the database.
     * @param {FavoriteUpdateManyAndReturnArgs} args - Arguments to update many Favorites.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'String'>
    readonly name: FieldRef<"Favorite", 'String'>
    readonly icon: FieldRef<"Favorite", 'String'>
    readonly link: FieldRef<"Favorite", 'String'>
    readonly userId: FieldRef<"Favorite", 'String'>
    readonly organizationId: FieldRef<"Favorite", 'String'>
    readonly type: FieldRef<"Favorite", 'String'>
    readonly createdAt: FieldRef<"Favorite", 'DateTime'>
    readonly createdBy: FieldRef<"Favorite", 'String'>
    readonly updatedAt: FieldRef<"Favorite", 'DateTime'>
    readonly updatedBy: FieldRef<"Favorite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
  }

  /**
   * Favorite updateManyAndReturn
   */
  export type FavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to delete.
     */
    limit?: number
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    status: 'status',
    country: 'country',
    bio: 'bio',
    photo: 'photo',
    dob: 'dob',
    resetToken: 'resetToken',
    settings: 'settings',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    cover: 'cover',
    avatar: 'avatar',
    maxStorageSize: 'maxStorageSize',
    desc: 'desc',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const OrganizationMemberScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    status: 'status',
    role: 'role',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type OrganizationMemberScalarFieldEnum = (typeof OrganizationMemberScalarFieldEnum)[keyof typeof OrganizationMemberScalarFieldEnum]


  export const OrganizationStorageScalarFieldEnum: {
    id: 'id',
    type: 'type',
    config: 'config',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type OrganizationStorageScalarFieldEnum = (typeof OrganizationStorageScalarFieldEnum)[keyof typeof OrganizationStorageScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    role: 'role',
    userId: 'userId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    organizationId: 'organizationId',
    desc: 'desc',
    cover: 'cover',
    icon: 'icon',
    isArchived: 'isArchived',
    countMemberTask: 'countMemberTask',
    countProjectTask: 'countProjectTask',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectViewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    onlyMe: 'onlyMe',
    icon: 'icon',
    projectId: 'projectId',
    order: 'order',
    data: 'data',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ProjectViewScalarFieldEnum = (typeof ProjectViewScalarFieldEnum)[keyof typeof ProjectViewScalarFieldEnum]


  export const ProjectSettingNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    projectId: 'projectId',
    taskChanges: 'taskChanges',
    remind: 'remind',
    overdue: 'overdue',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type ProjectSettingNotificationScalarFieldEnum = (typeof ProjectSettingNotificationScalarFieldEnum)[keyof typeof ProjectSettingNotificationScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    desc: 'desc',
    dueDate: 'dueDate',
    order: 'order',
    type: 'type',
    checklistDone: 'checklistDone',
    checklistTodos: 'checklistTodos',
    cover: 'cover',
    plannedStartDate: 'plannedStartDate',
    plannedDueDate: 'plannedDueDate',
    startDate: 'startDate',
    projectId: 'projectId',
    priority: 'priority',
    taskStatusId: 'taskStatusId',
    parentTaskId: 'parentTaskId',
    progress: 'progress',
    done: 'done',
    taskPoint: 'taskPoint',
    customFields: 'customFields',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    order: 'order',
    projectId: 'projectId',
    type: 'type'
  };

  export type TaskStatusScalarFieldEnum = (typeof TaskStatusScalarFieldEnum)[keyof typeof TaskStatusScalarFieldEnum]


  export const TaskAssigneeScalarFieldEnum: {
    taskId: 'taskId',
    userId: 'userId',
    assignedAt: 'assignedAt'
  };

  export type TaskAssigneeScalarFieldEnum = (typeof TaskAssigneeScalarFieldEnum)[keyof typeof TaskAssigneeScalarFieldEnum]


  export const TaskChecklistScalarFieldEnum: {
    id: 'id',
    title: 'title',
    order: 'order',
    taskId: 'taskId',
    done: 'done',
    doneAt: 'doneAt'
  };

  export type TaskChecklistScalarFieldEnum = (typeof TaskChecklistScalarFieldEnum)[keyof typeof TaskChecklistScalarFieldEnum]


  export const TaskPointScalarFieldEnum: {
    id: 'id',
    point: 'point',
    projectId: 'projectId',
    icon: 'icon'
  };

  export type TaskPointScalarFieldEnum = (typeof TaskPointScalarFieldEnum)[keyof typeof TaskPointScalarFieldEnum]


  export const TaskAutomationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    projectId: 'projectId',
    when: 'when',
    then: 'then',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type TaskAutomationScalarFieldEnum = (typeof TaskAutomationScalarFieldEnum)[keyof typeof TaskAutomationScalarFieldEnum]


  export const VisionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    dueDate: 'dueDate',
    progress: 'progress',
    projectId: 'projectId',
    organizationId: 'organizationId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type VisionScalarFieldEnum = (typeof VisionScalarFieldEnum)[keyof typeof VisionScalarFieldEnum]


  export const FieldScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    type: 'type',
    icon: 'icon',
    hidden: 'hidden',
    width: 'width',
    order: 'order',
    desc: 'desc',
    data: 'data',
    config: 'config'
  };

  export type FieldScalarFieldEnum = (typeof FieldScalarFieldEnum)[keyof typeof FieldScalarFieldEnum]


  export const GridScalarFieldEnum: {
    id: 'id',
    title: 'title',
    cover: 'cover',
    projectId: 'projectId',
    customFields: 'customFields',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type GridScalarFieldEnum = (typeof GridScalarFieldEnum)[keyof typeof GridScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    projectId: 'projectId'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TaskTagScalarFieldEnum: {
    taskId: 'taskId',
    tagId: 'tagId'
  };

  export type TaskTagScalarFieldEnum = (typeof TaskTagScalarFieldEnum)[keyof typeof TaskTagScalarFieldEnum]


  export const SchedulerScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    projectId: 'projectId',
    cronId: 'cronId',
    trigger: 'trigger',
    action: 'action',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SchedulerScalarFieldEnum = (typeof SchedulerScalarFieldEnum)[keyof typeof SchedulerScalarFieldEnum]


  export const FileStorageScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    projectId: 'projectId',
    taskId: 'taskId',
    name: 'name',
    keyName: 'keyName',
    type: 'type',
    url: 'url',
    size: 'size',
    mimeType: 'mimeType',
    parentId: 'parentId',
    owner: 'owner',
    ownerType: 'ownerType',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type FileStorageScalarFieldEnum = (typeof FileStorageScalarFieldEnum)[keyof typeof FileStorageScalarFieldEnum]


  export const StatScalarFieldEnum: {
    id: 'id',
    type: 'type',
    data: 'data',
    userId: 'userId',
    projectId: 'projectId',
    organizationId: 'organizationId',
    year: 'year',
    month: 'month',
    date: 'date',
    updatedAt: 'updatedAt'
  };

  export type StatScalarFieldEnum = (typeof StatScalarFieldEnum)[keyof typeof StatScalarFieldEnum]


  export const DashboardScalarFieldEnum: {
    id: 'id',
    title: 'title',
    projectId: 'projectId',
    isDefault: 'isDefault'
  };

  export type DashboardScalarFieldEnum = (typeof DashboardScalarFieldEnum)[keyof typeof DashboardScalarFieldEnum]


  export const DashboardComponentScalarFieldEnum: {
    id: 'id',
    dashboardId: 'dashboardId',
    title: 'title',
    type: 'type',
    config: 'config',
    x: 'x',
    y: 'y',
    width: 'width',
    height: 'height',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type DashboardComponentScalarFieldEnum = (typeof DashboardComponentScalarFieldEnum)[keyof typeof DashboardComponentScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    targetId: 'targetId',
    targetType: 'targetType',
    type: 'type',
    data: 'data',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    projectId: 'projectId',
    content: 'content',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    organizationId: 'organizationId',
    scopes: 'scopes',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const TimerScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimerScalarFieldEnum = (typeof TimerScalarFieldEnum)[keyof typeof TimerScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    link: 'link',
    userId: 'userId',
    organizationId: 'organizationId',
    type: 'type',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'OrganizationRole'
   */
  export type EnumOrganizationRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationRole'>
    


  /**
   * Reference to a field of type 'OrganizationRole[]'
   */
  export type ListEnumOrganizationRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationRole[]'>
    


  /**
   * Reference to a field of type 'OrgStorageType'
   */
  export type EnumOrgStorageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgStorageType'>
    


  /**
   * Reference to a field of type 'OrgStorageType[]'
   */
  export type ListEnumOrgStorageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgStorageType[]'>
    


  /**
   * Reference to a field of type 'MemberRole'
   */
  export type EnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole'>
    


  /**
   * Reference to a field of type 'MemberRole[]'
   */
  export type ListEnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ProjectViewType'
   */
  export type EnumProjectViewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectViewType'>
    


  /**
   * Reference to a field of type 'ProjectViewType[]'
   */
  export type ListEnumProjectViewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectViewType[]'>
    


  /**
   * Reference to a field of type 'TaskType'
   */
  export type EnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType'>
    


  /**
   * Reference to a field of type 'TaskType[]'
   */
  export type ListEnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType[]'>
    


  /**
   * Reference to a field of type 'TaskPriority'
   */
  export type EnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority'>
    


  /**
   * Reference to a field of type 'TaskPriority[]'
   */
  export type ListEnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority[]'>
    


  /**
   * Reference to a field of type 'StatusType'
   */
  export type EnumStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusType'>
    


  /**
   * Reference to a field of type 'StatusType[]'
   */
  export type ListEnumStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusType[]'>
    


  /**
   * Reference to a field of type 'FieldType'
   */
  export type EnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType'>
    


  /**
   * Reference to a field of type 'FieldType[]'
   */
  export type ListEnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType[]'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'FileOwnerType'
   */
  export type EnumFileOwnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileOwnerType'>
    


  /**
   * Reference to a field of type 'FileOwnerType[]'
   */
  export type ListEnumFileOwnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileOwnerType[]'>
    


  /**
   * Reference to a field of type 'StatType'
   */
  export type EnumStatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatType'>
    


  /**
   * Reference to a field of type 'StatType[]'
   */
  export type ListEnumStatTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatType[]'>
    


  /**
   * Reference to a field of type 'DashboardComponentType'
   */
  export type EnumDashboardComponentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DashboardComponentType'>
    


  /**
   * Reference to a field of type 'DashboardComponentType[]'
   */
  export type ListEnumDashboardComponentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DashboardComponentType[]'>
    


  /**
   * Reference to a field of type 'ActivityTargetType'
   */
  export type EnumActivityTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityTargetType'>
    


  /**
   * Reference to a field of type 'ActivityTargetType[]'
   */
  export type ListEnumActivityTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityTargetType[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusNullableFilter<"User"> | $Enums.UserStatus | null
    country?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    settings?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: UuidNullableFilter<"User"> | string | null
    updatedAt?: DateTimeFilter<"User"> | Date | string
    updatedBy?: UuidNullableFilter<"User"> | string | null
    members?: MemberListRelationFilter
    organizationMembers?: OrganizationMemberListRelationFilter
    taskAssignees?: TaskAssigneeListRelationFilter
    projectSettingNotifications?: ProjectSettingNotificationListRelationFilter
    stats?: StatListRelationFilter
    timers?: TimerListRelationFilter
    favorites?: FavoriteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
    organizationMembers?: OrganizationMemberOrderByRelationAggregateInput
    taskAssignees?: TaskAssigneeOrderByRelationAggregateInput
    projectSettingNotifications?: ProjectSettingNotificationOrderByRelationAggregateInput
    stats?: StatOrderByRelationAggregateInput
    timers?: TimerOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusNullableFilter<"User"> | $Enums.UserStatus | null
    country?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    settings?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: UuidNullableFilter<"User"> | string | null
    updatedAt?: DateTimeFilter<"User"> | Date | string
    updatedBy?: UuidNullableFilter<"User"> | string | null
    members?: MemberListRelationFilter
    organizationMembers?: OrganizationMemberListRelationFilter
    taskAssignees?: TaskAssigneeListRelationFilter
    projectSettingNotifications?: ProjectSettingNotificationListRelationFilter
    stats?: StatListRelationFilter
    timers?: TimerListRelationFilter
    favorites?: FavoriteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: EnumUserStatusNullableWithAggregatesFilter<"User"> | $Enums.UserStatus | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    settings?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"User"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"User"> | string | null
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: UuidFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    cover?: StringNullableFilter<"Organization"> | string | null
    avatar?: StringNullableFilter<"Organization"> | string | null
    maxStorageSize?: IntNullableFilter<"Organization"> | number | null
    desc?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    createdBy?: UuidFilter<"Organization"> | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    updatedBy?: UuidNullableFilter<"Organization"> | string | null
    projects?: ProjectListRelationFilter
    visions?: VisionListRelationFilter
    organizationMembers?: OrganizationMemberListRelationFilter
    taskAutomations?: TaskAutomationListRelationFilter
    schedulers?: SchedulerListRelationFilter
    fileStorages?: FileStorageListRelationFilter
    stats?: StatListRelationFilter
    applications?: ApplicationListRelationFilter
    favorites?: FavoriteListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    cover?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    maxStorageSize?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    visions?: VisionOrderByRelationAggregateInput
    organizationMembers?: OrganizationMemberOrderByRelationAggregateInput
    taskAutomations?: TaskAutomationOrderByRelationAggregateInput
    schedulers?: SchedulerOrderByRelationAggregateInput
    fileStorages?: FileStorageOrderByRelationAggregateInput
    stats?: StatOrderByRelationAggregateInput
    applications?: ApplicationOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    cover?: StringNullableFilter<"Organization"> | string | null
    avatar?: StringNullableFilter<"Organization"> | string | null
    maxStorageSize?: IntNullableFilter<"Organization"> | number | null
    desc?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    createdBy?: UuidFilter<"Organization"> | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    updatedBy?: UuidNullableFilter<"Organization"> | string | null
    projects?: ProjectListRelationFilter
    visions?: VisionListRelationFilter
    organizationMembers?: OrganizationMemberListRelationFilter
    taskAutomations?: TaskAutomationListRelationFilter
    schedulers?: SchedulerListRelationFilter
    fileStorages?: FileStorageListRelationFilter
    stats?: StatListRelationFilter
    applications?: ApplicationListRelationFilter
    favorites?: FavoriteListRelationFilter
  }, "id" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    cover?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    maxStorageSize?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    cover?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    maxStorageSize?: IntNullableWithAggregatesFilter<"Organization"> | number | null
    desc?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    createdBy?: UuidWithAggregatesFilter<"Organization"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"Organization"> | string | null
  }

  export type OrganizationMemberWhereInput = {
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    id?: UuidFilter<"OrganizationMember"> | string
    organizationId?: UuidFilter<"OrganizationMember"> | string
    userId?: UuidFilter<"OrganizationMember"> | string
    status?: EnumInvitationStatusFilter<"OrganizationMember"> | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFilter<"OrganizationMember"> | $Enums.OrganizationRole
    createdAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    createdBy?: UuidNullableFilter<"OrganizationMember"> | string | null
    updatedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    updatedBy?: UuidNullableFilter<"OrganizationMember"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrganizationMemberOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrganizationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_userId?: OrganizationMemberOrganizationIdUserIdCompoundUniqueInput
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    organizationId?: UuidFilter<"OrganizationMember"> | string
    userId?: UuidFilter<"OrganizationMember"> | string
    status?: EnumInvitationStatusFilter<"OrganizationMember"> | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFilter<"OrganizationMember"> | $Enums.OrganizationRole
    createdAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    createdBy?: UuidNullableFilter<"OrganizationMember"> | string | null
    updatedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    updatedBy?: UuidNullableFilter<"OrganizationMember"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "organizationId_userId">

  export type OrganizationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: OrganizationMemberCountOrderByAggregateInput
    _max?: OrganizationMemberMaxOrderByAggregateInput
    _min?: OrganizationMemberMinOrderByAggregateInput
  }

  export type OrganizationMemberScalarWhereWithAggregatesInput = {
    AND?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    OR?: OrganizationMemberScalarWhereWithAggregatesInput[]
    NOT?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OrganizationMember"> | string
    organizationId?: UuidWithAggregatesFilter<"OrganizationMember"> | string
    userId?: UuidWithAggregatesFilter<"OrganizationMember"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"OrganizationMember"> | $Enums.InvitationStatus
    role?: EnumOrganizationRoleWithAggregatesFilter<"OrganizationMember"> | $Enums.OrganizationRole
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationMember"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"OrganizationMember"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationMember"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"OrganizationMember"> | string | null
  }

  export type OrganizationStorageWhereInput = {
    AND?: OrganizationStorageWhereInput | OrganizationStorageWhereInput[]
    OR?: OrganizationStorageWhereInput[]
    NOT?: OrganizationStorageWhereInput | OrganizationStorageWhereInput[]
    id?: UuidFilter<"OrganizationStorage"> | string
    type?: EnumOrgStorageTypeFilter<"OrganizationStorage"> | $Enums.OrgStorageType
    config?: JsonFilter<"OrganizationStorage">
    organizationId?: UuidFilter<"OrganizationStorage"> | string
    createdAt?: DateTimeFilter<"OrganizationStorage"> | Date | string
    createdBy?: UuidNullableFilter<"OrganizationStorage"> | string | null
    updatedAt?: DateTimeFilter<"OrganizationStorage"> | Date | string
    updatedBy?: UuidNullableFilter<"OrganizationStorage"> | string | null
  }

  export type OrganizationStorageOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    config?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type OrganizationStorageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationStorageWhereInput | OrganizationStorageWhereInput[]
    OR?: OrganizationStorageWhereInput[]
    NOT?: OrganizationStorageWhereInput | OrganizationStorageWhereInput[]
    type?: EnumOrgStorageTypeFilter<"OrganizationStorage"> | $Enums.OrgStorageType
    config?: JsonFilter<"OrganizationStorage">
    organizationId?: UuidFilter<"OrganizationStorage"> | string
    createdAt?: DateTimeFilter<"OrganizationStorage"> | Date | string
    createdBy?: UuidNullableFilter<"OrganizationStorage"> | string | null
    updatedAt?: DateTimeFilter<"OrganizationStorage"> | Date | string
    updatedBy?: UuidNullableFilter<"OrganizationStorage"> | string | null
  }, "id">

  export type OrganizationStorageOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    config?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: OrganizationStorageCountOrderByAggregateInput
    _max?: OrganizationStorageMaxOrderByAggregateInput
    _min?: OrganizationStorageMinOrderByAggregateInput
  }

  export type OrganizationStorageScalarWhereWithAggregatesInput = {
    AND?: OrganizationStorageScalarWhereWithAggregatesInput | OrganizationStorageScalarWhereWithAggregatesInput[]
    OR?: OrganizationStorageScalarWhereWithAggregatesInput[]
    NOT?: OrganizationStorageScalarWhereWithAggregatesInput | OrganizationStorageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OrganizationStorage"> | string
    type?: EnumOrgStorageTypeWithAggregatesFilter<"OrganizationStorage"> | $Enums.OrgStorageType
    config?: JsonWithAggregatesFilter<"OrganizationStorage">
    organizationId?: UuidWithAggregatesFilter<"OrganizationStorage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationStorage"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"OrganizationStorage"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationStorage"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"OrganizationStorage"> | string | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: UuidFilter<"Member"> | string
    role?: EnumMemberRoleFilter<"Member"> | $Enums.MemberRole
    userId?: UuidFilter<"Member"> | string
    projectId?: UuidFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    createdBy?: UuidNullableFilter<"Member"> | string | null
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    updatedBy?: UuidNullableFilter<"Member"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    role?: EnumMemberRoleFilter<"Member"> | $Enums.MemberRole
    userId?: UuidFilter<"Member"> | string
    projectId?: UuidFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    createdBy?: UuidNullableFilter<"Member"> | string | null
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    updatedBy?: UuidNullableFilter<"Member"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Member"> | string
    role?: EnumMemberRoleWithAggregatesFilter<"Member"> | $Enums.MemberRole
    userId?: UuidWithAggregatesFilter<"Member"> | string
    projectId?: UuidWithAggregatesFilter<"Member"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Member"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"Member"> | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: UuidFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    organizationId?: UuidFilter<"Project"> | string
    desc?: StringNullableFilter<"Project"> | string | null
    cover?: StringNullableFilter<"Project"> | string | null
    icon?: StringNullableFilter<"Project"> | string | null
    isArchived?: BoolFilter<"Project"> | boolean
    countMemberTask?: BoolFilter<"Project"> | boolean
    countProjectTask?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: UuidNullableFilter<"Project"> | string | null
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    updatedBy?: UuidNullableFilter<"Project"> | string | null
    projectView?: XOR<ProjectViewNullableScalarRelationFilter, ProjectViewWhereInput> | null
    field?: FieldListRelationFilter
    vision?: VisionListRelationFilter
    projectSettingNotifications?: ProjectSettingNotificationListRelationFilter
    members?: MemberListRelationFilter
    grid?: GridListRelationFilter
    taskStatuses?: TaskStatusListRelationFilter
    taskPoints?: TaskPointListRelationFilter
    tasks?: TaskListRelationFilter
    tags?: TagListRelationFilter
    taskAutomations?: TaskAutomationListRelationFilter
    schedulers?: SchedulerListRelationFilter
    fileStorages?: FileStorageListRelationFilter
    stats?: StatListRelationFilter
    comments?: CommentListRelationFilter
    dashboard?: DashboardListRelationFilter
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    desc?: SortOrderInput | SortOrder
    cover?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    countMemberTask?: SortOrder
    countProjectTask?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    projectView?: ProjectViewOrderByWithRelationInput
    field?: FieldOrderByRelationAggregateInput
    vision?: VisionOrderByRelationAggregateInput
    projectSettingNotifications?: ProjectSettingNotificationOrderByRelationAggregateInput
    members?: MemberOrderByRelationAggregateInput
    grid?: GridOrderByRelationAggregateInput
    taskStatuses?: TaskStatusOrderByRelationAggregateInput
    taskPoints?: TaskPointOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    taskAutomations?: TaskAutomationOrderByRelationAggregateInput
    schedulers?: SchedulerOrderByRelationAggregateInput
    fileStorages?: FileStorageOrderByRelationAggregateInput
    stats?: StatOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    dashboard?: DashboardOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    organizationId?: UuidFilter<"Project"> | string
    desc?: StringNullableFilter<"Project"> | string | null
    cover?: StringNullableFilter<"Project"> | string | null
    icon?: StringNullableFilter<"Project"> | string | null
    isArchived?: BoolFilter<"Project"> | boolean
    countMemberTask?: BoolFilter<"Project"> | boolean
    countProjectTask?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: UuidNullableFilter<"Project"> | string | null
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    updatedBy?: UuidNullableFilter<"Project"> | string | null
    projectView?: XOR<ProjectViewNullableScalarRelationFilter, ProjectViewWhereInput> | null
    field?: FieldListRelationFilter
    vision?: VisionListRelationFilter
    projectSettingNotifications?: ProjectSettingNotificationListRelationFilter
    members?: MemberListRelationFilter
    grid?: GridListRelationFilter
    taskStatuses?: TaskStatusListRelationFilter
    taskPoints?: TaskPointListRelationFilter
    tasks?: TaskListRelationFilter
    tags?: TagListRelationFilter
    taskAutomations?: TaskAutomationListRelationFilter
    schedulers?: SchedulerListRelationFilter
    fileStorages?: FileStorageListRelationFilter
    stats?: StatListRelationFilter
    comments?: CommentListRelationFilter
    dashboard?: DashboardListRelationFilter
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    desc?: SortOrderInput | SortOrder
    cover?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    countMemberTask?: SortOrder
    countProjectTask?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    organizationId?: UuidWithAggregatesFilter<"Project"> | string
    desc?: StringNullableWithAggregatesFilter<"Project"> | string | null
    cover?: StringNullableWithAggregatesFilter<"Project"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Project"> | string | null
    isArchived?: BoolWithAggregatesFilter<"Project"> | boolean
    countMemberTask?: BoolWithAggregatesFilter<"Project"> | boolean
    countProjectTask?: BoolWithAggregatesFilter<"Project"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Project"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type ProjectViewWhereInput = {
    AND?: ProjectViewWhereInput | ProjectViewWhereInput[]
    OR?: ProjectViewWhereInput[]
    NOT?: ProjectViewWhereInput | ProjectViewWhereInput[]
    id?: UuidFilter<"ProjectView"> | string
    name?: StringNullableFilter<"ProjectView"> | string | null
    type?: EnumProjectViewTypeFilter<"ProjectView"> | $Enums.ProjectViewType
    onlyMe?: BoolFilter<"ProjectView"> | boolean
    icon?: StringNullableFilter<"ProjectView"> | string | null
    projectId?: UuidNullableFilter<"ProjectView"> | string | null
    order?: IntNullableFilter<"ProjectView"> | number | null
    data?: JsonNullableFilter<"ProjectView">
    createdAt?: DateTimeFilter<"ProjectView"> | Date | string
    createdBy?: UuidNullableFilter<"ProjectView"> | string | null
    updatedAt?: DateTimeFilter<"ProjectView"> | Date | string
    updatedBy?: UuidNullableFilter<"ProjectView"> | string | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type ProjectViewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    onlyMe?: SortOrder
    icon?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: ProjectViewWhereInput | ProjectViewWhereInput[]
    OR?: ProjectViewWhereInput[]
    NOT?: ProjectViewWhereInput | ProjectViewWhereInput[]
    name?: StringNullableFilter<"ProjectView"> | string | null
    type?: EnumProjectViewTypeFilter<"ProjectView"> | $Enums.ProjectViewType
    onlyMe?: BoolFilter<"ProjectView"> | boolean
    icon?: StringNullableFilter<"ProjectView"> | string | null
    order?: IntNullableFilter<"ProjectView"> | number | null
    data?: JsonNullableFilter<"ProjectView">
    createdAt?: DateTimeFilter<"ProjectView"> | Date | string
    createdBy?: UuidNullableFilter<"ProjectView"> | string | null
    updatedAt?: DateTimeFilter<"ProjectView"> | Date | string
    updatedBy?: UuidNullableFilter<"ProjectView"> | string | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id" | "projectId">

  export type ProjectViewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    onlyMe?: SortOrder
    icon?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ProjectViewCountOrderByAggregateInput
    _avg?: ProjectViewAvgOrderByAggregateInput
    _max?: ProjectViewMaxOrderByAggregateInput
    _min?: ProjectViewMinOrderByAggregateInput
    _sum?: ProjectViewSumOrderByAggregateInput
  }

  export type ProjectViewScalarWhereWithAggregatesInput = {
    AND?: ProjectViewScalarWhereWithAggregatesInput | ProjectViewScalarWhereWithAggregatesInput[]
    OR?: ProjectViewScalarWhereWithAggregatesInput[]
    NOT?: ProjectViewScalarWhereWithAggregatesInput | ProjectViewScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProjectView"> | string
    name?: StringNullableWithAggregatesFilter<"ProjectView"> | string | null
    type?: EnumProjectViewTypeWithAggregatesFilter<"ProjectView"> | $Enums.ProjectViewType
    onlyMe?: BoolWithAggregatesFilter<"ProjectView"> | boolean
    icon?: StringNullableWithAggregatesFilter<"ProjectView"> | string | null
    projectId?: UuidNullableWithAggregatesFilter<"ProjectView"> | string | null
    order?: IntNullableWithAggregatesFilter<"ProjectView"> | number | null
    data?: JsonNullableWithAggregatesFilter<"ProjectView">
    createdAt?: DateTimeWithAggregatesFilter<"ProjectView"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"ProjectView"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectView"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"ProjectView"> | string | null
  }

  export type ProjectSettingNotificationWhereInput = {
    AND?: ProjectSettingNotificationWhereInput | ProjectSettingNotificationWhereInput[]
    OR?: ProjectSettingNotificationWhereInput[]
    NOT?: ProjectSettingNotificationWhereInput | ProjectSettingNotificationWhereInput[]
    id?: UuidFilter<"ProjectSettingNotification"> | string
    userId?: UuidFilter<"ProjectSettingNotification"> | string
    projectId?: UuidFilter<"ProjectSettingNotification"> | string
    taskChanges?: BoolFilter<"ProjectSettingNotification"> | boolean
    remind?: BoolFilter<"ProjectSettingNotification"> | boolean
    overdue?: BoolFilter<"ProjectSettingNotification"> | boolean
    createdAt?: DateTimeFilter<"ProjectSettingNotification"> | Date | string
    createdBy?: UuidNullableFilter<"ProjectSettingNotification"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectSettingNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    taskChanges?: SortOrder
    remind?: SortOrder
    overdue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectSettingNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectSettingNotificationWhereInput | ProjectSettingNotificationWhereInput[]
    OR?: ProjectSettingNotificationWhereInput[]
    NOT?: ProjectSettingNotificationWhereInput | ProjectSettingNotificationWhereInput[]
    userId?: UuidFilter<"ProjectSettingNotification"> | string
    projectId?: UuidFilter<"ProjectSettingNotification"> | string
    taskChanges?: BoolFilter<"ProjectSettingNotification"> | boolean
    remind?: BoolFilter<"ProjectSettingNotification"> | boolean
    overdue?: BoolFilter<"ProjectSettingNotification"> | boolean
    createdAt?: DateTimeFilter<"ProjectSettingNotification"> | Date | string
    createdBy?: UuidNullableFilter<"ProjectSettingNotification"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectSettingNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    taskChanges?: SortOrder
    remind?: SortOrder
    overdue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: ProjectSettingNotificationCountOrderByAggregateInput
    _max?: ProjectSettingNotificationMaxOrderByAggregateInput
    _min?: ProjectSettingNotificationMinOrderByAggregateInput
  }

  export type ProjectSettingNotificationScalarWhereWithAggregatesInput = {
    AND?: ProjectSettingNotificationScalarWhereWithAggregatesInput | ProjectSettingNotificationScalarWhereWithAggregatesInput[]
    OR?: ProjectSettingNotificationScalarWhereWithAggregatesInput[]
    NOT?: ProjectSettingNotificationScalarWhereWithAggregatesInput | ProjectSettingNotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProjectSettingNotification"> | string
    userId?: UuidWithAggregatesFilter<"ProjectSettingNotification"> | string
    projectId?: UuidWithAggregatesFilter<"ProjectSettingNotification"> | string
    taskChanges?: BoolWithAggregatesFilter<"ProjectSettingNotification"> | boolean
    remind?: BoolWithAggregatesFilter<"ProjectSettingNotification"> | boolean
    overdue?: BoolWithAggregatesFilter<"ProjectSettingNotification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProjectSettingNotification"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"ProjectSettingNotification"> | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: UuidFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    desc?: StringNullableFilter<"Task"> | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    order?: IntFilter<"Task"> | number
    type?: EnumTaskTypeNullableFilter<"Task"> | $Enums.TaskType | null
    checklistDone?: IntNullableFilter<"Task"> | number | null
    checklistTodos?: IntNullableFilter<"Task"> | number | null
    cover?: StringNullableFilter<"Task"> | string | null
    plannedStartDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    plannedDueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    projectId?: UuidFilter<"Task"> | string
    priority?: EnumTaskPriorityNullableFilter<"Task"> | $Enums.TaskPriority | null
    taskStatusId?: UuidNullableFilter<"Task"> | string | null
    parentTaskId?: UuidNullableFilter<"Task"> | string | null
    progress?: IntNullableFilter<"Task"> | number | null
    done?: BoolFilter<"Task"> | boolean
    taskPoint?: IntNullableFilter<"Task"> | number | null
    customFields?: JsonNullableFilter<"Task">
    createdAt?: DateTimeFilter<"Task"> | Date | string
    createdBy?: UuidNullableFilter<"Task"> | string | null
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    updatedBy?: UuidNullableFilter<"Task"> | string | null
    taskChecklists?: TaskChecklistListRelationFilter
    comments?: CommentListRelationFilter
    timers?: TimerListRelationFilter
    taskTags?: TaskTagListRelationFilter
    taskAssignees?: TaskAssigneeListRelationFilter
    fileStorages?: FileStorageListRelationFilter
    parentTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    subTasks?: TaskListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    taskStatus?: XOR<TaskStatusNullableScalarRelationFilter, TaskStatusWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    order?: SortOrder
    type?: SortOrderInput | SortOrder
    checklistDone?: SortOrderInput | SortOrder
    checklistTodos?: SortOrderInput | SortOrder
    cover?: SortOrderInput | SortOrder
    plannedStartDate?: SortOrderInput | SortOrder
    plannedDueDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    projectId?: SortOrder
    priority?: SortOrderInput | SortOrder
    taskStatusId?: SortOrderInput | SortOrder
    parentTaskId?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    done?: SortOrder
    taskPoint?: SortOrderInput | SortOrder
    customFields?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    taskChecklists?: TaskChecklistOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    timers?: TimerOrderByRelationAggregateInput
    taskTags?: TaskTagOrderByRelationAggregateInput
    taskAssignees?: TaskAssigneeOrderByRelationAggregateInput
    fileStorages?: FileStorageOrderByRelationAggregateInput
    parentTask?: TaskOrderByWithRelationInput
    subTasks?: TaskOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
    taskStatus?: TaskStatusOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    desc?: StringNullableFilter<"Task"> | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    order?: IntFilter<"Task"> | number
    type?: EnumTaskTypeNullableFilter<"Task"> | $Enums.TaskType | null
    checklistDone?: IntNullableFilter<"Task"> | number | null
    checklistTodos?: IntNullableFilter<"Task"> | number | null
    cover?: StringNullableFilter<"Task"> | string | null
    plannedStartDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    plannedDueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    projectId?: UuidFilter<"Task"> | string
    priority?: EnumTaskPriorityNullableFilter<"Task"> | $Enums.TaskPriority | null
    taskStatusId?: UuidNullableFilter<"Task"> | string | null
    parentTaskId?: UuidNullableFilter<"Task"> | string | null
    progress?: IntNullableFilter<"Task"> | number | null
    done?: BoolFilter<"Task"> | boolean
    taskPoint?: IntNullableFilter<"Task"> | number | null
    customFields?: JsonNullableFilter<"Task">
    createdAt?: DateTimeFilter<"Task"> | Date | string
    createdBy?: UuidNullableFilter<"Task"> | string | null
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    updatedBy?: UuidNullableFilter<"Task"> | string | null
    taskChecklists?: TaskChecklistListRelationFilter
    comments?: CommentListRelationFilter
    timers?: TimerListRelationFilter
    taskTags?: TaskTagListRelationFilter
    taskAssignees?: TaskAssigneeListRelationFilter
    fileStorages?: FileStorageListRelationFilter
    parentTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    subTasks?: TaskListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    taskStatus?: XOR<TaskStatusNullableScalarRelationFilter, TaskStatusWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    order?: SortOrder
    type?: SortOrderInput | SortOrder
    checklistDone?: SortOrderInput | SortOrder
    checklistTodos?: SortOrderInput | SortOrder
    cover?: SortOrderInput | SortOrder
    plannedStartDate?: SortOrderInput | SortOrder
    plannedDueDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    projectId?: SortOrder
    priority?: SortOrderInput | SortOrder
    taskStatusId?: SortOrderInput | SortOrder
    parentTaskId?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    done?: SortOrder
    taskPoint?: SortOrderInput | SortOrder
    customFields?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    desc?: StringNullableWithAggregatesFilter<"Task"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    order?: IntWithAggregatesFilter<"Task"> | number
    type?: EnumTaskTypeNullableWithAggregatesFilter<"Task"> | $Enums.TaskType | null
    checklistDone?: IntNullableWithAggregatesFilter<"Task"> | number | null
    checklistTodos?: IntNullableWithAggregatesFilter<"Task"> | number | null
    cover?: StringNullableWithAggregatesFilter<"Task"> | string | null
    plannedStartDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    plannedDueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    projectId?: UuidWithAggregatesFilter<"Task"> | string
    priority?: EnumTaskPriorityNullableWithAggregatesFilter<"Task"> | $Enums.TaskPriority | null
    taskStatusId?: UuidNullableWithAggregatesFilter<"Task"> | string | null
    parentTaskId?: UuidNullableWithAggregatesFilter<"Task"> | string | null
    progress?: IntNullableWithAggregatesFilter<"Task"> | number | null
    done?: BoolWithAggregatesFilter<"Task"> | boolean
    taskPoint?: IntNullableWithAggregatesFilter<"Task"> | number | null
    customFields?: JsonNullableWithAggregatesFilter<"Task">
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Task"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type TaskStatusWhereInput = {
    AND?: TaskStatusWhereInput | TaskStatusWhereInput[]
    OR?: TaskStatusWhereInput[]
    NOT?: TaskStatusWhereInput | TaskStatusWhereInput[]
    id?: UuidFilter<"TaskStatus"> | string
    name?: StringFilter<"TaskStatus"> | string
    color?: StringFilter<"TaskStatus"> | string
    order?: IntFilter<"TaskStatus"> | number
    projectId?: UuidFilter<"TaskStatus"> | string
    type?: EnumStatusTypeFilter<"TaskStatus"> | $Enums.StatusType
    tasks?: TaskListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type TaskStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    order?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
  }

  export type TaskStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskStatusWhereInput | TaskStatusWhereInput[]
    OR?: TaskStatusWhereInput[]
    NOT?: TaskStatusWhereInput | TaskStatusWhereInput[]
    name?: StringFilter<"TaskStatus"> | string
    color?: StringFilter<"TaskStatus"> | string
    order?: IntFilter<"TaskStatus"> | number
    projectId?: UuidFilter<"TaskStatus"> | string
    type?: EnumStatusTypeFilter<"TaskStatus"> | $Enums.StatusType
    tasks?: TaskListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type TaskStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    order?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    _count?: TaskStatusCountOrderByAggregateInput
    _avg?: TaskStatusAvgOrderByAggregateInput
    _max?: TaskStatusMaxOrderByAggregateInput
    _min?: TaskStatusMinOrderByAggregateInput
    _sum?: TaskStatusSumOrderByAggregateInput
  }

  export type TaskStatusScalarWhereWithAggregatesInput = {
    AND?: TaskStatusScalarWhereWithAggregatesInput | TaskStatusScalarWhereWithAggregatesInput[]
    OR?: TaskStatusScalarWhereWithAggregatesInput[]
    NOT?: TaskStatusScalarWhereWithAggregatesInput | TaskStatusScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TaskStatus"> | string
    name?: StringWithAggregatesFilter<"TaskStatus"> | string
    color?: StringWithAggregatesFilter<"TaskStatus"> | string
    order?: IntWithAggregatesFilter<"TaskStatus"> | number
    projectId?: UuidWithAggregatesFilter<"TaskStatus"> | string
    type?: EnumStatusTypeWithAggregatesFilter<"TaskStatus"> | $Enums.StatusType
  }

  export type TaskAssigneeWhereInput = {
    AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    OR?: TaskAssigneeWhereInput[]
    NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    taskId?: UuidFilter<"TaskAssignee"> | string
    userId?: UuidFilter<"TaskAssignee"> | string
    assignedAt?: DateTimeFilter<"TaskAssignee"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskAssigneeOrderByWithRelationInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskAssigneeWhereUniqueInput = Prisma.AtLeast<{
    taskId_userId?: TaskAssigneeTaskIdUserIdCompoundUniqueInput
    AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    OR?: TaskAssigneeWhereInput[]
    NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    taskId?: UuidFilter<"TaskAssignee"> | string
    userId?: UuidFilter<"TaskAssignee"> | string
    assignedAt?: DateTimeFilter<"TaskAssignee"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "taskId_userId">

  export type TaskAssigneeOrderByWithAggregationInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    _count?: TaskAssigneeCountOrderByAggregateInput
    _max?: TaskAssigneeMaxOrderByAggregateInput
    _min?: TaskAssigneeMinOrderByAggregateInput
  }

  export type TaskAssigneeScalarWhereWithAggregatesInput = {
    AND?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[]
    OR?: TaskAssigneeScalarWhereWithAggregatesInput[]
    NOT?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[]
    taskId?: UuidWithAggregatesFilter<"TaskAssignee"> | string
    userId?: UuidWithAggregatesFilter<"TaskAssignee"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TaskAssignee"> | Date | string
  }

  export type TaskChecklistWhereInput = {
    AND?: TaskChecklistWhereInput | TaskChecklistWhereInput[]
    OR?: TaskChecklistWhereInput[]
    NOT?: TaskChecklistWhereInput | TaskChecklistWhereInput[]
    id?: UuidFilter<"TaskChecklist"> | string
    title?: StringFilter<"TaskChecklist"> | string
    order?: IntFilter<"TaskChecklist"> | number
    taskId?: UuidFilter<"TaskChecklist"> | string
    done?: BoolNullableFilter<"TaskChecklist"> | boolean | null
    doneAt?: DateTimeNullableFilter<"TaskChecklist"> | Date | string | null
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskChecklistOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    taskId?: SortOrder
    done?: SortOrderInput | SortOrder
    doneAt?: SortOrderInput | SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type TaskChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskChecklistWhereInput | TaskChecklistWhereInput[]
    OR?: TaskChecklistWhereInput[]
    NOT?: TaskChecklistWhereInput | TaskChecklistWhereInput[]
    title?: StringFilter<"TaskChecklist"> | string
    order?: IntFilter<"TaskChecklist"> | number
    taskId?: UuidFilter<"TaskChecklist"> | string
    done?: BoolNullableFilter<"TaskChecklist"> | boolean | null
    doneAt?: DateTimeNullableFilter<"TaskChecklist"> | Date | string | null
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id">

  export type TaskChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    taskId?: SortOrder
    done?: SortOrderInput | SortOrder
    doneAt?: SortOrderInput | SortOrder
    _count?: TaskChecklistCountOrderByAggregateInput
    _avg?: TaskChecklistAvgOrderByAggregateInput
    _max?: TaskChecklistMaxOrderByAggregateInput
    _min?: TaskChecklistMinOrderByAggregateInput
    _sum?: TaskChecklistSumOrderByAggregateInput
  }

  export type TaskChecklistScalarWhereWithAggregatesInput = {
    AND?: TaskChecklistScalarWhereWithAggregatesInput | TaskChecklistScalarWhereWithAggregatesInput[]
    OR?: TaskChecklistScalarWhereWithAggregatesInput[]
    NOT?: TaskChecklistScalarWhereWithAggregatesInput | TaskChecklistScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TaskChecklist"> | string
    title?: StringWithAggregatesFilter<"TaskChecklist"> | string
    order?: IntWithAggregatesFilter<"TaskChecklist"> | number
    taskId?: UuidWithAggregatesFilter<"TaskChecklist"> | string
    done?: BoolNullableWithAggregatesFilter<"TaskChecklist"> | boolean | null
    doneAt?: DateTimeNullableWithAggregatesFilter<"TaskChecklist"> | Date | string | null
  }

  export type TaskPointWhereInput = {
    AND?: TaskPointWhereInput | TaskPointWhereInput[]
    OR?: TaskPointWhereInput[]
    NOT?: TaskPointWhereInput | TaskPointWhereInput[]
    id?: UuidFilter<"TaskPoint"> | string
    point?: IntFilter<"TaskPoint"> | number
    projectId?: UuidFilter<"TaskPoint"> | string
    icon?: StringNullableFilter<"TaskPoint"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type TaskPointOrderByWithRelationInput = {
    id?: SortOrder
    point?: SortOrder
    projectId?: SortOrder
    icon?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type TaskPointWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskPointWhereInput | TaskPointWhereInput[]
    OR?: TaskPointWhereInput[]
    NOT?: TaskPointWhereInput | TaskPointWhereInput[]
    point?: IntFilter<"TaskPoint"> | number
    projectId?: UuidFilter<"TaskPoint"> | string
    icon?: StringNullableFilter<"TaskPoint"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type TaskPointOrderByWithAggregationInput = {
    id?: SortOrder
    point?: SortOrder
    projectId?: SortOrder
    icon?: SortOrderInput | SortOrder
    _count?: TaskPointCountOrderByAggregateInput
    _avg?: TaskPointAvgOrderByAggregateInput
    _max?: TaskPointMaxOrderByAggregateInput
    _min?: TaskPointMinOrderByAggregateInput
    _sum?: TaskPointSumOrderByAggregateInput
  }

  export type TaskPointScalarWhereWithAggregatesInput = {
    AND?: TaskPointScalarWhereWithAggregatesInput | TaskPointScalarWhereWithAggregatesInput[]
    OR?: TaskPointScalarWhereWithAggregatesInput[]
    NOT?: TaskPointScalarWhereWithAggregatesInput | TaskPointScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TaskPoint"> | string
    point?: IntWithAggregatesFilter<"TaskPoint"> | number
    projectId?: UuidWithAggregatesFilter<"TaskPoint"> | string
    icon?: StringNullableWithAggregatesFilter<"TaskPoint"> | string | null
  }

  export type TaskAutomationWhereInput = {
    AND?: TaskAutomationWhereInput | TaskAutomationWhereInput[]
    OR?: TaskAutomationWhereInput[]
    NOT?: TaskAutomationWhereInput | TaskAutomationWhereInput[]
    id?: UuidFilter<"TaskAutomation"> | string
    organizationId?: UuidFilter<"TaskAutomation"> | string
    projectId?: UuidFilter<"TaskAutomation"> | string
    when?: JsonFilter<"TaskAutomation">
    then?: JsonFilter<"TaskAutomation">
    createdAt?: DateTimeFilter<"TaskAutomation"> | Date | string
    createdBy?: UuidNullableFilter<"TaskAutomation"> | string | null
    updatedAt?: DateTimeFilter<"TaskAutomation"> | Date | string
    updatedBy?: UuidNullableFilter<"TaskAutomation"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type TaskAutomationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    when?: SortOrder
    then?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type TaskAutomationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskAutomationWhereInput | TaskAutomationWhereInput[]
    OR?: TaskAutomationWhereInput[]
    NOT?: TaskAutomationWhereInput | TaskAutomationWhereInput[]
    organizationId?: UuidFilter<"TaskAutomation"> | string
    projectId?: UuidFilter<"TaskAutomation"> | string
    when?: JsonFilter<"TaskAutomation">
    then?: JsonFilter<"TaskAutomation">
    createdAt?: DateTimeFilter<"TaskAutomation"> | Date | string
    createdBy?: UuidNullableFilter<"TaskAutomation"> | string | null
    updatedAt?: DateTimeFilter<"TaskAutomation"> | Date | string
    updatedBy?: UuidNullableFilter<"TaskAutomation"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type TaskAutomationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    when?: SortOrder
    then?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: TaskAutomationCountOrderByAggregateInput
    _max?: TaskAutomationMaxOrderByAggregateInput
    _min?: TaskAutomationMinOrderByAggregateInput
  }

  export type TaskAutomationScalarWhereWithAggregatesInput = {
    AND?: TaskAutomationScalarWhereWithAggregatesInput | TaskAutomationScalarWhereWithAggregatesInput[]
    OR?: TaskAutomationScalarWhereWithAggregatesInput[]
    NOT?: TaskAutomationScalarWhereWithAggregatesInput | TaskAutomationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TaskAutomation"> | string
    organizationId?: UuidWithAggregatesFilter<"TaskAutomation"> | string
    projectId?: UuidWithAggregatesFilter<"TaskAutomation"> | string
    when?: JsonWithAggregatesFilter<"TaskAutomation">
    then?: JsonWithAggregatesFilter<"TaskAutomation">
    createdAt?: DateTimeWithAggregatesFilter<"TaskAutomation"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"TaskAutomation"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"TaskAutomation"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"TaskAutomation"> | string | null
  }

  export type VisionWhereInput = {
    AND?: VisionWhereInput | VisionWhereInput[]
    OR?: VisionWhereInput[]
    NOT?: VisionWhereInput | VisionWhereInput[]
    id?: UuidFilter<"Vision"> | string
    name?: StringFilter<"Vision"> | string
    startDate?: DateTimeNullableFilter<"Vision"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Vision"> | Date | string | null
    progress?: IntNullableFilter<"Vision"> | number | null
    projectId?: UuidNullableFilter<"Vision"> | string | null
    organizationId?: UuidNullableFilter<"Vision"> | string | null
    parentId?: UuidNullableFilter<"Vision"> | string | null
    createdAt?: DateTimeFilter<"Vision"> | Date | string
    createdBy?: StringNullableFilter<"Vision"> | string | null
    updatedAt?: DateTimeFilter<"Vision"> | Date | string
    updatedBy?: StringNullableFilter<"Vision"> | string | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    parent?: XOR<VisionNullableScalarRelationFilter, VisionWhereInput> | null
    children?: VisionListRelationFilter
  }

  export type VisionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    parent?: VisionOrderByWithRelationInput
    children?: VisionOrderByRelationAggregateInput
  }

  export type VisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisionWhereInput | VisionWhereInput[]
    OR?: VisionWhereInput[]
    NOT?: VisionWhereInput | VisionWhereInput[]
    name?: StringFilter<"Vision"> | string
    startDate?: DateTimeNullableFilter<"Vision"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Vision"> | Date | string | null
    progress?: IntNullableFilter<"Vision"> | number | null
    projectId?: UuidNullableFilter<"Vision"> | string | null
    organizationId?: UuidNullableFilter<"Vision"> | string | null
    parentId?: UuidNullableFilter<"Vision"> | string | null
    createdAt?: DateTimeFilter<"Vision"> | Date | string
    createdBy?: StringNullableFilter<"Vision"> | string | null
    updatedAt?: DateTimeFilter<"Vision"> | Date | string
    updatedBy?: StringNullableFilter<"Vision"> | string | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    parent?: XOR<VisionNullableScalarRelationFilter, VisionWhereInput> | null
    children?: VisionListRelationFilter
  }, "id">

  export type VisionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: VisionCountOrderByAggregateInput
    _avg?: VisionAvgOrderByAggregateInput
    _max?: VisionMaxOrderByAggregateInput
    _min?: VisionMinOrderByAggregateInput
    _sum?: VisionSumOrderByAggregateInput
  }

  export type VisionScalarWhereWithAggregatesInput = {
    AND?: VisionScalarWhereWithAggregatesInput | VisionScalarWhereWithAggregatesInput[]
    OR?: VisionScalarWhereWithAggregatesInput[]
    NOT?: VisionScalarWhereWithAggregatesInput | VisionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Vision"> | string
    name?: StringWithAggregatesFilter<"Vision"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Vision"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Vision"> | Date | string | null
    progress?: IntNullableWithAggregatesFilter<"Vision"> | number | null
    projectId?: UuidNullableWithAggregatesFilter<"Vision"> | string | null
    organizationId?: UuidNullableWithAggregatesFilter<"Vision"> | string | null
    parentId?: UuidNullableWithAggregatesFilter<"Vision"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vision"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Vision"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Vision"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Vision"> | string | null
  }

  export type FieldWhereInput = {
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    id?: UuidFilter<"Field"> | string
    projectId?: UuidFilter<"Field"> | string
    name?: StringFilter<"Field"> | string
    type?: EnumFieldTypeFilter<"Field"> | $Enums.FieldType
    icon?: StringNullableFilter<"Field"> | string | null
    hidden?: BoolFilter<"Field"> | boolean
    width?: IntFilter<"Field"> | number
    order?: IntFilter<"Field"> | number
    desc?: StringNullableFilter<"Field"> | string | null
    data?: JsonNullableFilter<"Field">
    config?: JsonNullableFilter<"Field">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type FieldOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    icon?: SortOrderInput | SortOrder
    hidden?: SortOrder
    width?: SortOrder
    order?: SortOrder
    desc?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type FieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    projectId?: UuidFilter<"Field"> | string
    name?: StringFilter<"Field"> | string
    type?: EnumFieldTypeFilter<"Field"> | $Enums.FieldType
    icon?: StringNullableFilter<"Field"> | string | null
    hidden?: BoolFilter<"Field"> | boolean
    width?: IntFilter<"Field"> | number
    order?: IntFilter<"Field"> | number
    desc?: StringNullableFilter<"Field"> | string | null
    data?: JsonNullableFilter<"Field">
    config?: JsonNullableFilter<"Field">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type FieldOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    icon?: SortOrderInput | SortOrder
    hidden?: SortOrder
    width?: SortOrder
    order?: SortOrder
    desc?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    _count?: FieldCountOrderByAggregateInput
    _avg?: FieldAvgOrderByAggregateInput
    _max?: FieldMaxOrderByAggregateInput
    _min?: FieldMinOrderByAggregateInput
    _sum?: FieldSumOrderByAggregateInput
  }

  export type FieldScalarWhereWithAggregatesInput = {
    AND?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    OR?: FieldScalarWhereWithAggregatesInput[]
    NOT?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Field"> | string
    projectId?: UuidWithAggregatesFilter<"Field"> | string
    name?: StringWithAggregatesFilter<"Field"> | string
    type?: EnumFieldTypeWithAggregatesFilter<"Field"> | $Enums.FieldType
    icon?: StringNullableWithAggregatesFilter<"Field"> | string | null
    hidden?: BoolWithAggregatesFilter<"Field"> | boolean
    width?: IntWithAggregatesFilter<"Field"> | number
    order?: IntWithAggregatesFilter<"Field"> | number
    desc?: StringNullableWithAggregatesFilter<"Field"> | string | null
    data?: JsonNullableWithAggregatesFilter<"Field">
    config?: JsonNullableWithAggregatesFilter<"Field">
  }

  export type GridWhereInput = {
    AND?: GridWhereInput | GridWhereInput[]
    OR?: GridWhereInput[]
    NOT?: GridWhereInput | GridWhereInput[]
    id?: UuidFilter<"Grid"> | string
    title?: StringFilter<"Grid"> | string
    cover?: StringNullableFilter<"Grid"> | string | null
    projectId?: UuidFilter<"Grid"> | string
    customFields?: JsonNullableFilter<"Grid">
    isDeleted?: BoolNullableFilter<"Grid"> | boolean | null
    createdAt?: DateTimeFilter<"Grid"> | Date | string
    createdBy?: UuidNullableFilter<"Grid"> | string | null
    updatedAt?: DateTimeFilter<"Grid"> | Date | string
    updatedBy?: UuidNullableFilter<"Grid"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type GridOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    cover?: SortOrderInput | SortOrder
    projectId?: SortOrder
    customFields?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type GridWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GridWhereInput | GridWhereInput[]
    OR?: GridWhereInput[]
    NOT?: GridWhereInput | GridWhereInput[]
    title?: StringFilter<"Grid"> | string
    cover?: StringNullableFilter<"Grid"> | string | null
    projectId?: UuidFilter<"Grid"> | string
    customFields?: JsonNullableFilter<"Grid">
    isDeleted?: BoolNullableFilter<"Grid"> | boolean | null
    createdAt?: DateTimeFilter<"Grid"> | Date | string
    createdBy?: UuidNullableFilter<"Grid"> | string | null
    updatedAt?: DateTimeFilter<"Grid"> | Date | string
    updatedBy?: UuidNullableFilter<"Grid"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type GridOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    cover?: SortOrderInput | SortOrder
    projectId?: SortOrder
    customFields?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: GridCountOrderByAggregateInput
    _max?: GridMaxOrderByAggregateInput
    _min?: GridMinOrderByAggregateInput
  }

  export type GridScalarWhereWithAggregatesInput = {
    AND?: GridScalarWhereWithAggregatesInput | GridScalarWhereWithAggregatesInput[]
    OR?: GridScalarWhereWithAggregatesInput[]
    NOT?: GridScalarWhereWithAggregatesInput | GridScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Grid"> | string
    title?: StringWithAggregatesFilter<"Grid"> | string
    cover?: StringNullableWithAggregatesFilter<"Grid"> | string | null
    projectId?: UuidWithAggregatesFilter<"Grid"> | string
    customFields?: JsonNullableWithAggregatesFilter<"Grid">
    isDeleted?: BoolNullableWithAggregatesFilter<"Grid"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Grid"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Grid"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Grid"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"Grid"> | string | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: UuidFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    projectId?: UuidFilter<"Tag"> | string
    taskTags?: TaskTagListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    projectId?: SortOrder
    taskTags?: TaskTagOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    projectId?: UuidFilter<"Tag"> | string
    taskTags?: TaskTagListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    projectId?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    projectId?: UuidWithAggregatesFilter<"Tag"> | string
  }

  export type TaskTagWhereInput = {
    AND?: TaskTagWhereInput | TaskTagWhereInput[]
    OR?: TaskTagWhereInput[]
    NOT?: TaskTagWhereInput | TaskTagWhereInput[]
    taskId?: UuidFilter<"TaskTag"> | string
    tagId?: UuidFilter<"TaskTag"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type TaskTagOrderByWithRelationInput = {
    taskId?: SortOrder
    tagId?: SortOrder
    task?: TaskOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type TaskTagWhereUniqueInput = Prisma.AtLeast<{
    taskId_tagId?: TaskTagTaskIdTagIdCompoundUniqueInput
    AND?: TaskTagWhereInput | TaskTagWhereInput[]
    OR?: TaskTagWhereInput[]
    NOT?: TaskTagWhereInput | TaskTagWhereInput[]
    taskId?: UuidFilter<"TaskTag"> | string
    tagId?: UuidFilter<"TaskTag"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "taskId_tagId">

  export type TaskTagOrderByWithAggregationInput = {
    taskId?: SortOrder
    tagId?: SortOrder
    _count?: TaskTagCountOrderByAggregateInput
    _max?: TaskTagMaxOrderByAggregateInput
    _min?: TaskTagMinOrderByAggregateInput
  }

  export type TaskTagScalarWhereWithAggregatesInput = {
    AND?: TaskTagScalarWhereWithAggregatesInput | TaskTagScalarWhereWithAggregatesInput[]
    OR?: TaskTagScalarWhereWithAggregatesInput[]
    NOT?: TaskTagScalarWhereWithAggregatesInput | TaskTagScalarWhereWithAggregatesInput[]
    taskId?: UuidWithAggregatesFilter<"TaskTag"> | string
    tagId?: UuidWithAggregatesFilter<"TaskTag"> | string
  }

  export type SchedulerWhereInput = {
    AND?: SchedulerWhereInput | SchedulerWhereInput[]
    OR?: SchedulerWhereInput[]
    NOT?: SchedulerWhereInput | SchedulerWhereInput[]
    id?: UuidFilter<"Scheduler"> | string
    organizationId?: UuidFilter<"Scheduler"> | string
    projectId?: UuidFilter<"Scheduler"> | string
    cronId?: StringNullableFilter<"Scheduler"> | string | null
    trigger?: JsonFilter<"Scheduler">
    action?: JsonFilter<"Scheduler">
    createdAt?: DateTimeFilter<"Scheduler"> | Date | string
    createdBy?: UuidNullableFilter<"Scheduler"> | string | null
    updatedAt?: DateTimeFilter<"Scheduler"> | Date | string
    updatedBy?: UuidNullableFilter<"Scheduler"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type SchedulerOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    cronId?: SortOrderInput | SortOrder
    trigger?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type SchedulerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchedulerWhereInput | SchedulerWhereInput[]
    OR?: SchedulerWhereInput[]
    NOT?: SchedulerWhereInput | SchedulerWhereInput[]
    organizationId?: UuidFilter<"Scheduler"> | string
    projectId?: UuidFilter<"Scheduler"> | string
    cronId?: StringNullableFilter<"Scheduler"> | string | null
    trigger?: JsonFilter<"Scheduler">
    action?: JsonFilter<"Scheduler">
    createdAt?: DateTimeFilter<"Scheduler"> | Date | string
    createdBy?: UuidNullableFilter<"Scheduler"> | string | null
    updatedAt?: DateTimeFilter<"Scheduler"> | Date | string
    updatedBy?: UuidNullableFilter<"Scheduler"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type SchedulerOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    cronId?: SortOrderInput | SortOrder
    trigger?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SchedulerCountOrderByAggregateInput
    _max?: SchedulerMaxOrderByAggregateInput
    _min?: SchedulerMinOrderByAggregateInput
  }

  export type SchedulerScalarWhereWithAggregatesInput = {
    AND?: SchedulerScalarWhereWithAggregatesInput | SchedulerScalarWhereWithAggregatesInput[]
    OR?: SchedulerScalarWhereWithAggregatesInput[]
    NOT?: SchedulerScalarWhereWithAggregatesInput | SchedulerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Scheduler"> | string
    organizationId?: UuidWithAggregatesFilter<"Scheduler"> | string
    projectId?: UuidWithAggregatesFilter<"Scheduler"> | string
    cronId?: StringNullableWithAggregatesFilter<"Scheduler"> | string | null
    trigger?: JsonWithAggregatesFilter<"Scheduler">
    action?: JsonWithAggregatesFilter<"Scheduler">
    createdAt?: DateTimeWithAggregatesFilter<"Scheduler"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Scheduler"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Scheduler"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"Scheduler"> | string | null
  }

  export type FileStorageWhereInput = {
    AND?: FileStorageWhereInput | FileStorageWhereInput[]
    OR?: FileStorageWhereInput[]
    NOT?: FileStorageWhereInput | FileStorageWhereInput[]
    id?: UuidFilter<"FileStorage"> | string
    organizationId?: UuidNullableFilter<"FileStorage"> | string | null
    projectId?: UuidNullableFilter<"FileStorage"> | string | null
    taskId?: UuidNullableFilter<"FileStorage"> | string | null
    name?: StringFilter<"FileStorage"> | string
    keyName?: StringFilter<"FileStorage"> | string
    type?: EnumFileTypeFilter<"FileStorage"> | $Enums.FileType
    url?: StringNullableFilter<"FileStorage"> | string | null
    size?: FloatNullableFilter<"FileStorage"> | number | null
    mimeType?: StringNullableFilter<"FileStorage"> | string | null
    parentId?: StringNullableFilter<"FileStorage"> | string | null
    owner?: UuidNullableFilter<"FileStorage"> | string | null
    ownerType?: EnumFileOwnerTypeNullableFilter<"FileStorage"> | $Enums.FileOwnerType | null
    isDeleted?: BoolNullableFilter<"FileStorage"> | boolean | null
    createdAt?: DateTimeFilter<"FileStorage"> | Date | string
    createdBy?: UuidNullableFilter<"FileStorage"> | string | null
    deletedAt?: DateTimeNullableFilter<"FileStorage"> | Date | string | null
    deletedBy?: UuidNullableFilter<"FileStorage"> | string | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }

  export type FileStorageOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    name?: SortOrder
    keyName?: SortOrder
    type?: SortOrder
    url?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    ownerType?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type FileStorageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileStorageWhereInput | FileStorageWhereInput[]
    OR?: FileStorageWhereInput[]
    NOT?: FileStorageWhereInput | FileStorageWhereInput[]
    organizationId?: UuidNullableFilter<"FileStorage"> | string | null
    projectId?: UuidNullableFilter<"FileStorage"> | string | null
    taskId?: UuidNullableFilter<"FileStorage"> | string | null
    name?: StringFilter<"FileStorage"> | string
    keyName?: StringFilter<"FileStorage"> | string
    type?: EnumFileTypeFilter<"FileStorage"> | $Enums.FileType
    url?: StringNullableFilter<"FileStorage"> | string | null
    size?: FloatNullableFilter<"FileStorage"> | number | null
    mimeType?: StringNullableFilter<"FileStorage"> | string | null
    parentId?: StringNullableFilter<"FileStorage"> | string | null
    owner?: UuidNullableFilter<"FileStorage"> | string | null
    ownerType?: EnumFileOwnerTypeNullableFilter<"FileStorage"> | $Enums.FileOwnerType | null
    isDeleted?: BoolNullableFilter<"FileStorage"> | boolean | null
    createdAt?: DateTimeFilter<"FileStorage"> | Date | string
    createdBy?: UuidNullableFilter<"FileStorage"> | string | null
    deletedAt?: DateTimeNullableFilter<"FileStorage"> | Date | string | null
    deletedBy?: UuidNullableFilter<"FileStorage"> | string | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }, "id">

  export type FileStorageOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    name?: SortOrder
    keyName?: SortOrder
    type?: SortOrder
    url?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    ownerType?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: FileStorageCountOrderByAggregateInput
    _avg?: FileStorageAvgOrderByAggregateInput
    _max?: FileStorageMaxOrderByAggregateInput
    _min?: FileStorageMinOrderByAggregateInput
    _sum?: FileStorageSumOrderByAggregateInput
  }

  export type FileStorageScalarWhereWithAggregatesInput = {
    AND?: FileStorageScalarWhereWithAggregatesInput | FileStorageScalarWhereWithAggregatesInput[]
    OR?: FileStorageScalarWhereWithAggregatesInput[]
    NOT?: FileStorageScalarWhereWithAggregatesInput | FileStorageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FileStorage"> | string
    organizationId?: UuidNullableWithAggregatesFilter<"FileStorage"> | string | null
    projectId?: UuidNullableWithAggregatesFilter<"FileStorage"> | string | null
    taskId?: UuidNullableWithAggregatesFilter<"FileStorage"> | string | null
    name?: StringWithAggregatesFilter<"FileStorage"> | string
    keyName?: StringWithAggregatesFilter<"FileStorage"> | string
    type?: EnumFileTypeWithAggregatesFilter<"FileStorage"> | $Enums.FileType
    url?: StringNullableWithAggregatesFilter<"FileStorage"> | string | null
    size?: FloatNullableWithAggregatesFilter<"FileStorage"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"FileStorage"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"FileStorage"> | string | null
    owner?: UuidNullableWithAggregatesFilter<"FileStorage"> | string | null
    ownerType?: EnumFileOwnerTypeNullableWithAggregatesFilter<"FileStorage"> | $Enums.FileOwnerType | null
    isDeleted?: BoolNullableWithAggregatesFilter<"FileStorage"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"FileStorage"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"FileStorage"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"FileStorage"> | Date | string | null
    deletedBy?: UuidNullableWithAggregatesFilter<"FileStorage"> | string | null
  }

  export type StatWhereInput = {
    AND?: StatWhereInput | StatWhereInput[]
    OR?: StatWhereInput[]
    NOT?: StatWhereInput | StatWhereInput[]
    id?: UuidFilter<"Stat"> | string
    type?: EnumStatTypeFilter<"Stat"> | $Enums.StatType
    data?: JsonNullableFilter<"Stat">
    userId?: UuidNullableFilter<"Stat"> | string | null
    projectId?: UuidNullableFilter<"Stat"> | string | null
    organizationId?: UuidNullableFilter<"Stat"> | string | null
    year?: IntFilter<"Stat"> | number
    month?: IntFilter<"Stat"> | number
    date?: IntFilter<"Stat"> | number
    updatedAt?: DateTimeNullableFilter<"Stat"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }

  export type StatOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    year?: SortOrder
    month?: SortOrder
    date?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type StatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StatWhereInput | StatWhereInput[]
    OR?: StatWhereInput[]
    NOT?: StatWhereInput | StatWhereInput[]
    type?: EnumStatTypeFilter<"Stat"> | $Enums.StatType
    data?: JsonNullableFilter<"Stat">
    userId?: UuidNullableFilter<"Stat"> | string | null
    projectId?: UuidNullableFilter<"Stat"> | string | null
    organizationId?: UuidNullableFilter<"Stat"> | string | null
    year?: IntFilter<"Stat"> | number
    month?: IntFilter<"Stat"> | number
    date?: IntFilter<"Stat"> | number
    updatedAt?: DateTimeNullableFilter<"Stat"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }, "id">

  export type StatOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    year?: SortOrder
    month?: SortOrder
    date?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StatCountOrderByAggregateInput
    _avg?: StatAvgOrderByAggregateInput
    _max?: StatMaxOrderByAggregateInput
    _min?: StatMinOrderByAggregateInput
    _sum?: StatSumOrderByAggregateInput
  }

  export type StatScalarWhereWithAggregatesInput = {
    AND?: StatScalarWhereWithAggregatesInput | StatScalarWhereWithAggregatesInput[]
    OR?: StatScalarWhereWithAggregatesInput[]
    NOT?: StatScalarWhereWithAggregatesInput | StatScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Stat"> | string
    type?: EnumStatTypeWithAggregatesFilter<"Stat"> | $Enums.StatType
    data?: JsonNullableWithAggregatesFilter<"Stat">
    userId?: UuidNullableWithAggregatesFilter<"Stat"> | string | null
    projectId?: UuidNullableWithAggregatesFilter<"Stat"> | string | null
    organizationId?: UuidNullableWithAggregatesFilter<"Stat"> | string | null
    year?: IntWithAggregatesFilter<"Stat"> | number
    month?: IntWithAggregatesFilter<"Stat"> | number
    date?: IntWithAggregatesFilter<"Stat"> | number
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Stat"> | Date | string | null
  }

  export type DashboardWhereInput = {
    AND?: DashboardWhereInput | DashboardWhereInput[]
    OR?: DashboardWhereInput[]
    NOT?: DashboardWhereInput | DashboardWhereInput[]
    id?: UuidFilter<"Dashboard"> | string
    title?: StringNullableFilter<"Dashboard"> | string | null
    projectId?: UuidNullableFilter<"Dashboard"> | string | null
    isDefault?: BoolNullableFilter<"Dashboard"> | boolean | null
    dashboardComponents?: DashboardComponentListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type DashboardOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    isDefault?: SortOrderInput | SortOrder
    dashboardComponents?: DashboardComponentOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
  }

  export type DashboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DashboardWhereInput | DashboardWhereInput[]
    OR?: DashboardWhereInput[]
    NOT?: DashboardWhereInput | DashboardWhereInput[]
    title?: StringNullableFilter<"Dashboard"> | string | null
    projectId?: UuidNullableFilter<"Dashboard"> | string | null
    isDefault?: BoolNullableFilter<"Dashboard"> | boolean | null
    dashboardComponents?: DashboardComponentListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type DashboardOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    isDefault?: SortOrderInput | SortOrder
    _count?: DashboardCountOrderByAggregateInput
    _max?: DashboardMaxOrderByAggregateInput
    _min?: DashboardMinOrderByAggregateInput
  }

  export type DashboardScalarWhereWithAggregatesInput = {
    AND?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[]
    OR?: DashboardScalarWhereWithAggregatesInput[]
    NOT?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Dashboard"> | string
    title?: StringNullableWithAggregatesFilter<"Dashboard"> | string | null
    projectId?: UuidNullableWithAggregatesFilter<"Dashboard"> | string | null
    isDefault?: BoolNullableWithAggregatesFilter<"Dashboard"> | boolean | null
  }

  export type DashboardComponentWhereInput = {
    AND?: DashboardComponentWhereInput | DashboardComponentWhereInput[]
    OR?: DashboardComponentWhereInput[]
    NOT?: DashboardComponentWhereInput | DashboardComponentWhereInput[]
    id?: UuidFilter<"DashboardComponent"> | string
    dashboardId?: UuidNullableFilter<"DashboardComponent"> | string | null
    title?: StringNullableFilter<"DashboardComponent"> | string | null
    type?: EnumDashboardComponentTypeNullableFilter<"DashboardComponent"> | $Enums.DashboardComponentType | null
    config?: JsonNullableFilter<"DashboardComponent">
    x?: IntNullableFilter<"DashboardComponent"> | number | null
    y?: IntNullableFilter<"DashboardComponent"> | number | null
    width?: IntNullableFilter<"DashboardComponent"> | number | null
    height?: IntNullableFilter<"DashboardComponent"> | number | null
    createdAt?: DateTimeFilter<"DashboardComponent"> | Date | string
    createdBy?: StringNullableFilter<"DashboardComponent"> | string | null
    deletedAt?: DateTimeNullableFilter<"DashboardComponent"> | Date | string | null
    deletedBy?: StringNullableFilter<"DashboardComponent"> | string | null
    dashboard?: XOR<DashboardNullableScalarRelationFilter, DashboardWhereInput> | null
  }

  export type DashboardComponentOrderByWithRelationInput = {
    id?: SortOrder
    dashboardId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    dashboard?: DashboardOrderByWithRelationInput
  }

  export type DashboardComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DashboardComponentWhereInput | DashboardComponentWhereInput[]
    OR?: DashboardComponentWhereInput[]
    NOT?: DashboardComponentWhereInput | DashboardComponentWhereInput[]
    dashboardId?: UuidNullableFilter<"DashboardComponent"> | string | null
    title?: StringNullableFilter<"DashboardComponent"> | string | null
    type?: EnumDashboardComponentTypeNullableFilter<"DashboardComponent"> | $Enums.DashboardComponentType | null
    config?: JsonNullableFilter<"DashboardComponent">
    x?: IntNullableFilter<"DashboardComponent"> | number | null
    y?: IntNullableFilter<"DashboardComponent"> | number | null
    width?: IntNullableFilter<"DashboardComponent"> | number | null
    height?: IntNullableFilter<"DashboardComponent"> | number | null
    createdAt?: DateTimeFilter<"DashboardComponent"> | Date | string
    createdBy?: StringNullableFilter<"DashboardComponent"> | string | null
    deletedAt?: DateTimeNullableFilter<"DashboardComponent"> | Date | string | null
    deletedBy?: StringNullableFilter<"DashboardComponent"> | string | null
    dashboard?: XOR<DashboardNullableScalarRelationFilter, DashboardWhereInput> | null
  }, "id">

  export type DashboardComponentOrderByWithAggregationInput = {
    id?: SortOrder
    dashboardId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: DashboardComponentCountOrderByAggregateInput
    _avg?: DashboardComponentAvgOrderByAggregateInput
    _max?: DashboardComponentMaxOrderByAggregateInput
    _min?: DashboardComponentMinOrderByAggregateInput
    _sum?: DashboardComponentSumOrderByAggregateInput
  }

  export type DashboardComponentScalarWhereWithAggregatesInput = {
    AND?: DashboardComponentScalarWhereWithAggregatesInput | DashboardComponentScalarWhereWithAggregatesInput[]
    OR?: DashboardComponentScalarWhereWithAggregatesInput[]
    NOT?: DashboardComponentScalarWhereWithAggregatesInput | DashboardComponentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DashboardComponent"> | string
    dashboardId?: UuidNullableWithAggregatesFilter<"DashboardComponent"> | string | null
    title?: StringNullableWithAggregatesFilter<"DashboardComponent"> | string | null
    type?: EnumDashboardComponentTypeNullableWithAggregatesFilter<"DashboardComponent"> | $Enums.DashboardComponentType | null
    config?: JsonNullableWithAggregatesFilter<"DashboardComponent">
    x?: IntNullableWithAggregatesFilter<"DashboardComponent"> | number | null
    y?: IntNullableWithAggregatesFilter<"DashboardComponent"> | number | null
    width?: IntNullableWithAggregatesFilter<"DashboardComponent"> | number | null
    height?: IntNullableWithAggregatesFilter<"DashboardComponent"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DashboardComponent"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"DashboardComponent"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"DashboardComponent"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"DashboardComponent"> | string | null
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: UuidFilter<"Activity"> | string
    targetId?: UuidFilter<"Activity"> | string
    targetType?: EnumActivityTargetTypeFilter<"Activity"> | $Enums.ActivityTargetType
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    data?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    createdBy?: UuidFilter<"Activity"> | string
    updatedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    updatedBy?: UuidNullableFilter<"Activity"> | string | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    targetId?: UuidFilter<"Activity"> | string
    targetType?: EnumActivityTargetTypeFilter<"Activity"> | $Enums.ActivityTargetType
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    data?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    createdBy?: UuidFilter<"Activity"> | string
    updatedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    updatedBy?: UuidNullableFilter<"Activity"> | string | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Activity"> | string
    targetId?: UuidWithAggregatesFilter<"Activity"> | string
    targetType?: EnumActivityTargetTypeWithAggregatesFilter<"Activity"> | $Enums.ActivityTargetType
    type?: EnumActivityTypeWithAggregatesFilter<"Activity"> | $Enums.ActivityType
    data?: JsonNullableWithAggregatesFilter<"Activity">
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    createdBy?: UuidWithAggregatesFilter<"Activity"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Activity"> | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: UuidFilter<"Comment"> | string
    taskId?: UuidFilter<"Comment"> | string
    projectId?: UuidFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    createdBy?: UuidFilter<"Comment"> | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    taskId?: UuidFilter<"Comment"> | string
    projectId?: UuidFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    createdBy?: UuidFilter<"Comment"> | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Comment"> | string
    taskId?: UuidWithAggregatesFilter<"Comment"> | string
    projectId?: UuidWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    createdBy?: UuidWithAggregatesFilter<"Comment"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    id?: UuidFilter<"Application"> | string
    name?: StringFilter<"Application"> | string
    description?: StringNullableFilter<"Application"> | string | null
    clientId?: StringFilter<"Application"> | string
    clientSecret?: StringFilter<"Application"> | string
    organizationId?: UuidFilter<"Application"> | string
    scopes?: StringNullableListFilter<"Application">
    createdAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    createdBy?: UuidNullableFilter<"Application"> | string | null
    updatedAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    updatedBy?: UuidNullableFilter<"Application"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    organizationId?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId?: string
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    name?: StringFilter<"Application"> | string
    description?: StringNullableFilter<"Application"> | string | null
    clientSecret?: StringFilter<"Application"> | string
    organizationId?: UuidFilter<"Application"> | string
    scopes?: StringNullableListFilter<"Application">
    createdAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    createdBy?: UuidNullableFilter<"Application"> | string | null
    updatedAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    updatedBy?: UuidNullableFilter<"Application"> | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "clientId">

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    organizationId?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Application"> | string
    name?: StringWithAggregatesFilter<"Application"> | string
    description?: StringNullableWithAggregatesFilter<"Application"> | string | null
    clientId?: StringWithAggregatesFilter<"Application"> | string
    clientSecret?: StringWithAggregatesFilter<"Application"> | string
    organizationId?: UuidWithAggregatesFilter<"Application"> | string
    scopes?: StringNullableListFilter<"Application">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    createdBy?: UuidNullableWithAggregatesFilter<"Application"> | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Application"> | string | null
  }

  export type TimerWhereInput = {
    AND?: TimerWhereInput | TimerWhereInput[]
    OR?: TimerWhereInput[]
    NOT?: TimerWhereInput | TimerWhereInput[]
    id?: UuidFilter<"Timer"> | string
    taskId?: UuidFilter<"Timer"> | string
    userId?: UuidFilter<"Timer"> | string
    startTime?: DateTimeFilter<"Timer"> | Date | string
    endTime?: DateTimeNullableFilter<"Timer"> | Date | string | null
    duration?: IntFilter<"Timer"> | number
    createdAt?: DateTimeFilter<"Timer"> | Date | string
    updatedAt?: DateTimeFilter<"Timer"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TimerOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TimerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimerWhereInput | TimerWhereInput[]
    OR?: TimerWhereInput[]
    NOT?: TimerWhereInput | TimerWhereInput[]
    taskId?: UuidFilter<"Timer"> | string
    userId?: UuidFilter<"Timer"> | string
    startTime?: DateTimeFilter<"Timer"> | Date | string
    endTime?: DateTimeNullableFilter<"Timer"> | Date | string | null
    duration?: IntFilter<"Timer"> | number
    createdAt?: DateTimeFilter<"Timer"> | Date | string
    updatedAt?: DateTimeFilter<"Timer"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TimerOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimerCountOrderByAggregateInput
    _avg?: TimerAvgOrderByAggregateInput
    _max?: TimerMaxOrderByAggregateInput
    _min?: TimerMinOrderByAggregateInput
    _sum?: TimerSumOrderByAggregateInput
  }

  export type TimerScalarWhereWithAggregatesInput = {
    AND?: TimerScalarWhereWithAggregatesInput | TimerScalarWhereWithAggregatesInput[]
    OR?: TimerScalarWhereWithAggregatesInput[]
    NOT?: TimerScalarWhereWithAggregatesInput | TimerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Timer"> | string
    taskId?: UuidWithAggregatesFilter<"Timer"> | string
    userId?: UuidWithAggregatesFilter<"Timer"> | string
    startTime?: DateTimeWithAggregatesFilter<"Timer"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Timer"> | Date | string | null
    duration?: IntWithAggregatesFilter<"Timer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Timer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Timer"> | Date | string
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: UuidFilter<"Favorite"> | string
    name?: StringFilter<"Favorite"> | string
    icon?: StringFilter<"Favorite"> | string
    link?: StringFilter<"Favorite"> | string
    userId?: UuidFilter<"Favorite"> | string
    organizationId?: UuidFilter<"Favorite"> | string
    type?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    createdBy?: UuidNullableFilter<"Favorite"> | string | null
    updatedAt?: DateTimeNullableFilter<"Favorite"> | Date | string | null
    updatedBy?: UuidNullableFilter<"Favorite"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    link?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    name?: StringFilter<"Favorite"> | string
    icon?: StringFilter<"Favorite"> | string
    link?: StringFilter<"Favorite"> | string
    userId?: UuidFilter<"Favorite"> | string
    organizationId?: UuidFilter<"Favorite"> | string
    type?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    createdBy?: UuidNullableFilter<"Favorite"> | string | null
    updatedAt?: DateTimeNullableFilter<"Favorite"> | Date | string | null
    updatedBy?: UuidNullableFilter<"Favorite"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    link?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Favorite"> | string
    name?: StringWithAggregatesFilter<"Favorite"> | string
    icon?: StringWithAggregatesFilter<"Favorite"> | string
    link?: StringWithAggregatesFilter<"Favorite"> | string
    userId?: UuidWithAggregatesFilter<"Favorite"> | string
    organizationId?: UuidWithAggregatesFilter<"Favorite"> | string
    type?: StringWithAggregatesFilter<"Favorite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
    createdBy?: UuidNullableWithAggregatesFilter<"Favorite"> | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Favorite"> | Date | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"Favorite"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutUserInput
    stats?: StatCreateNestedManyWithoutUserInput
    timers?: TimerCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutUserInput
    stats?: StatUncheckedCreateNestedManyWithoutUserInput
    timers?: TimerUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutUserNestedInput
    stats?: StatUpdateManyWithoutUserNestedInput
    timers?: TimerUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutUserNestedInput
    stats?: StatUncheckedUpdateManyWithoutUserNestedInput
    timers?: TimerUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    visions?: VisionCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageCreateNestedManyWithoutOrganizationInput
    stats?: StatCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    visions?: VisionUncheckedCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutOrganizationInput
    stats?: StatUncheckedCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUpdateManyWithoutOrganizationNestedInput
    stats?: StatUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput
    stats?: StatUncheckedUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationMemberCreateInput = {
    id?: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organization: OrganizationCreateNestedOneWithoutOrganizationMembersInput
    user: UserCreateNestedOneWithoutOrganizationMembersInput
  }

  export type OrganizationMemberUncheckedCreateInput = {
    id?: string
    organizationId: string
    userId: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationMembersNestedInput
    user?: UserUpdateOneRequiredWithoutOrganizationMembersNestedInput
  }

  export type OrganizationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationMemberCreateManyInput = {
    id?: string
    organizationId: string
    userId: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationStorageCreateInput = {
    id?: string
    type: $Enums.OrgStorageType
    config: JsonNullValueInput | InputJsonValue
    organizationId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationStorageUncheckedCreateInput = {
    id?: string
    type: $Enums.OrgStorageType
    config: JsonNullValueInput | InputJsonValue
    organizationId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationStorageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrgStorageTypeFieldUpdateOperationsInput | $Enums.OrgStorageType
    config?: JsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationStorageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrgStorageTypeFieldUpdateOperationsInput | $Enums.OrgStorageType
    config?: JsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationStorageCreateManyInput = {
    id?: string
    type: $Enums.OrgStorageType
    config: JsonNullValueInput | InputJsonValue
    organizationId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationStorageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrgStorageTypeFieldUpdateOperationsInput | $Enums.OrgStorageType
    config?: JsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationStorageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrgStorageTypeFieldUpdateOperationsInput | $Enums.OrgStorageType
    config?: JsonNullValueInput | InputJsonValue
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateInput = {
    id?: string
    role: $Enums.MemberRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    role: $Enums.MemberRole
    userId: string
    projectId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateManyInput = {
    id?: string
    role: $Enums.MemberRole
    userId: string
    projectId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectViewCreateInput = {
    id?: string
    name?: string | null
    type: $Enums.ProjectViewType
    onlyMe?: boolean
    icon?: string | null
    order?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project?: ProjectCreateNestedOneWithoutProjectViewInput
  }

  export type ProjectViewUncheckedCreateInput = {
    id?: string
    name?: string | null
    type: $Enums.ProjectViewType
    onlyMe?: boolean
    icon?: string | null
    projectId?: string | null
    order?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProjectViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectViewTypeFieldUpdateOperationsInput | $Enums.ProjectViewType
    onlyMe?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutProjectViewNestedInput
  }

  export type ProjectViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectViewTypeFieldUpdateOperationsInput | $Enums.ProjectViewType
    onlyMe?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectViewCreateManyInput = {
    id?: string
    name?: string | null
    type: $Enums.ProjectViewType
    onlyMe?: boolean
    icon?: string | null
    projectId?: string | null
    order?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProjectViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectViewTypeFieldUpdateOperationsInput | $Enums.ProjectViewType
    onlyMe?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectViewTypeFieldUpdateOperationsInput | $Enums.ProjectViewType
    onlyMe?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectSettingNotificationCreateInput = {
    id?: string
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    user: UserCreateNestedOneWithoutProjectSettingNotificationsInput
    project: ProjectCreateNestedOneWithoutProjectSettingNotificationsInput
  }

  export type ProjectSettingNotificationUncheckedCreateInput = {
    id?: string
    userId: string
    projectId: string
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type ProjectSettingNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProjectSettingNotificationsNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectSettingNotificationsNestedInput
  }

  export type ProjectSettingNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectSettingNotificationCreateManyInput = {
    id?: string
    userId: string
    projectId: string
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type ProjectSettingNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectSettingNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskStatusCreateInput = {
    id?: string
    name: string
    color: string
    order: number
    type?: $Enums.StatusType
    tasks?: TaskCreateNestedManyWithoutTaskStatusInput
    project: ProjectCreateNestedOneWithoutTaskStatusesInput
  }

  export type TaskStatusUncheckedCreateInput = {
    id?: string
    name: string
    color: string
    order: number
    projectId: string
    type?: $Enums.StatusType
    tasks?: TaskUncheckedCreateNestedManyWithoutTaskStatusInput
  }

  export type TaskStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    tasks?: TaskUpdateManyWithoutTaskStatusNestedInput
    project?: ProjectUpdateOneRequiredWithoutTaskStatusesNestedInput
  }

  export type TaskStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    tasks?: TaskUncheckedUpdateManyWithoutTaskStatusNestedInput
  }

  export type TaskStatusCreateManyInput = {
    id?: string
    name: string
    color: string
    order: number
    projectId: string
    type?: $Enums.StatusType
  }

  export type TaskStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type TaskStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type TaskAssigneeCreateInput = {
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutTaskAssigneesInput
    user: UserCreateNestedOneWithoutTaskAssigneesInput
  }

  export type TaskAssigneeUncheckedCreateInput = {
    taskId: string
    userId: string
    assignedAt?: Date | string
  }

  export type TaskAssigneeUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTaskAssigneesNestedInput
    user?: UserUpdateOneRequiredWithoutTaskAssigneesNestedInput
  }

  export type TaskAssigneeUncheckedUpdateInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeCreateManyInput = {
    taskId: string
    userId: string
    assignedAt?: Date | string
  }

  export type TaskAssigneeUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUncheckedUpdateManyInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskChecklistCreateInput = {
    id?: string
    title: string
    order: number
    done?: boolean | null
    doneAt?: Date | string | null
    task: TaskCreateNestedOneWithoutTaskChecklistsInput
  }

  export type TaskChecklistUncheckedCreateInput = {
    id?: string
    title: string
    order: number
    taskId: string
    done?: boolean | null
    doneAt?: Date | string | null
  }

  export type TaskChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    done?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task?: TaskUpdateOneRequiredWithoutTaskChecklistsNestedInput
  }

  export type TaskChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    taskId?: StringFieldUpdateOperationsInput | string
    done?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskChecklistCreateManyInput = {
    id?: string
    title: string
    order: number
    taskId: string
    done?: boolean | null
    doneAt?: Date | string | null
  }

  export type TaskChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    done?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    taskId?: StringFieldUpdateOperationsInput | string
    done?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskPointCreateInput = {
    id?: string
    point: number
    icon?: string | null
    project: ProjectCreateNestedOneWithoutTaskPointsInput
  }

  export type TaskPointUncheckedCreateInput = {
    id?: string
    point: number
    projectId: string
    icon?: string | null
  }

  export type TaskPointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutTaskPointsNestedInput
  }

  export type TaskPointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskPointCreateManyInput = {
    id?: string
    point: number
    projectId: string
    icon?: string | null
  }

  export type TaskPointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskPointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAutomationCreateInput = {
    id?: string
    when: JsonNullValueInput | InputJsonValue
    then: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organization: OrganizationCreateNestedOneWithoutTaskAutomationsInput
    project: ProjectCreateNestedOneWithoutTaskAutomationsInput
  }

  export type TaskAutomationUncheckedCreateInput = {
    id?: string
    organizationId: string
    projectId: string
    when: JsonNullValueInput | InputJsonValue
    then: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskAutomationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneRequiredWithoutTaskAutomationsNestedInput
    project?: ProjectUpdateOneRequiredWithoutTaskAutomationsNestedInput
  }

  export type TaskAutomationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAutomationCreateManyInput = {
    id?: string
    organizationId: string
    projectId: string
    when: JsonNullValueInput | InputJsonValue
    then: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskAutomationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAutomationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisionCreateInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project?: ProjectCreateNestedOneWithoutVisionInput
    organization?: OrganizationCreateNestedOneWithoutVisionsInput
    parent?: VisionCreateNestedOneWithoutChildrenInput
    children?: VisionCreateNestedManyWithoutParentInput
  }

  export type VisionUncheckedCreateInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    projectId?: string | null
    organizationId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    children?: VisionUncheckedCreateNestedManyWithoutParentInput
  }

  export type VisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutVisionNestedInput
    organization?: OrganizationUpdateOneWithoutVisionsNestedInput
    parent?: VisionUpdateOneWithoutChildrenNestedInput
    children?: VisionUpdateManyWithoutParentNestedInput
  }

  export type VisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    children?: VisionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type VisionCreateManyInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    projectId?: string | null
    organizationId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type VisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldCreateInput = {
    id?: string
    name: string
    type: $Enums.FieldType
    icon?: string | null
    hidden?: boolean
    width: number
    order: number
    desc?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutFieldInput
  }

  export type FieldUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    type: $Enums.FieldType
    icon?: string | null
    hidden?: boolean
    width: number
    order: number
    desc?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    width?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    width?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FieldCreateManyInput = {
    id?: string
    projectId: string
    name: string
    type: $Enums.FieldType
    icon?: string | null
    hidden?: boolean
    width: number
    order: number
    desc?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    width?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    width?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GridCreateInput = {
    id?: string
    title: string
    cover?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project: ProjectCreateNestedOneWithoutGridInput
  }

  export type GridUncheckedCreateInput = {
    id?: string
    title: string
    cover?: string | null
    projectId: string
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type GridUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutGridNestedInput
  }

  export type GridUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GridCreateManyInput = {
    id?: string
    title: string
    cover?: string | null
    projectId: string
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type GridUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GridUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color: string
    taskTags?: TaskTagCreateNestedManyWithoutTagInput
    project: ProjectCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color: string
    projectId: string
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    taskTags?: TaskTagUpdateManyWithoutTagNestedInput
    project?: ProjectUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    taskTags?: TaskTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color: string
    projectId: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskTagCreateInput = {
    task: TaskCreateNestedOneWithoutTaskTagsInput
    tag: TagCreateNestedOneWithoutTaskTagsInput
  }

  export type TaskTagUncheckedCreateInput = {
    taskId: string
    tagId: string
  }

  export type TaskTagUpdateInput = {
    task?: TaskUpdateOneRequiredWithoutTaskTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutTaskTagsNestedInput
  }

  export type TaskTagUncheckedUpdateInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskTagCreateManyInput = {
    taskId: string
    tagId: string
  }

  export type TaskTagUpdateManyMutationInput = {

  }

  export type TaskTagUncheckedUpdateManyInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type SchedulerCreateInput = {
    id?: string
    cronId?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project: ProjectCreateNestedOneWithoutSchedulersInput
    organization: OrganizationCreateNestedOneWithoutSchedulersInput
  }

  export type SchedulerUncheckedCreateInput = {
    id?: string
    organizationId: string
    projectId: string
    cronId?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SchedulerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutSchedulersNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutSchedulersNestedInput
  }

  export type SchedulerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchedulerCreateManyInput = {
    id?: string
    organizationId: string
    projectId: string
    cronId?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SchedulerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchedulerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileStorageCreateInput = {
    id?: string
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    organization?: OrganizationCreateNestedOneWithoutFileStoragesInput
    project?: ProjectCreateNestedOneWithoutFileStoragesInput
    task?: TaskCreateNestedOneWithoutFileStoragesInput
  }

  export type FileStorageUncheckedCreateInput = {
    id?: string
    organizationId?: string | null
    projectId?: string | null
    taskId?: string | null
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type FileStorageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutFileStoragesNestedInput
    project?: ProjectUpdateOneWithoutFileStoragesNestedInput
    task?: TaskUpdateOneWithoutFileStoragesNestedInput
  }

  export type FileStorageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileStorageCreateManyInput = {
    id?: string
    organizationId?: string | null
    projectId?: string | null
    taskId?: string | null
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type FileStorageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileStorageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StatCreateInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutStatsInput
    project?: ProjectCreateNestedOneWithoutStatsInput
    organization?: OrganizationCreateNestedOneWithoutStatsInput
  }

  export type StatUncheckedCreateInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    projectId?: string | null
    organizationId?: string | null
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
  }

  export type StatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutStatsNestedInput
    project?: ProjectUpdateOneWithoutStatsNestedInput
    organization?: OrganizationUpdateOneWithoutStatsNestedInput
  }

  export type StatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StatCreateManyInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    projectId?: string | null
    organizationId?: string | null
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
  }

  export type StatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DashboardCreateInput = {
    id?: string
    title?: string | null
    isDefault?: boolean | null
    dashboardComponents?: DashboardComponentCreateNestedManyWithoutDashboardInput
    project?: ProjectCreateNestedOneWithoutDashboardInput
  }

  export type DashboardUncheckedCreateInput = {
    id?: string
    title?: string | null
    projectId?: string | null
    isDefault?: boolean | null
    dashboardComponents?: DashboardComponentUncheckedCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dashboardComponents?: DashboardComponentUpdateManyWithoutDashboardNestedInput
    project?: ProjectUpdateOneWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dashboardComponents?: DashboardComponentUncheckedUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardCreateManyInput = {
    id?: string
    title?: string | null
    projectId?: string | null
    isDefault?: boolean | null
  }

  export type DashboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DashboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DashboardComponentCreateInput = {
    id?: string
    title?: string | null
    type?: $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    dashboard?: DashboardCreateNestedOneWithoutDashboardComponentsInput
  }

  export type DashboardComponentUncheckedCreateInput = {
    id?: string
    dashboardId?: string | null
    title?: string | null
    type?: $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type DashboardComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDashboardComponentTypeFieldUpdateOperationsInput | $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dashboard?: DashboardUpdateOneWithoutDashboardComponentsNestedInput
  }

  export type DashboardComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dashboardId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDashboardComponentTypeFieldUpdateOperationsInput | $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardComponentCreateManyInput = {
    id?: string
    dashboardId?: string | null
    title?: string | null
    type?: $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type DashboardComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDashboardComponentTypeFieldUpdateOperationsInput | $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dashboardId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDashboardComponentTypeFieldUpdateOperationsInput | $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityCreateInput = {
    id?: string
    targetId: string
    targetType: $Enums.ActivityTargetType
    type: $Enums.ActivityType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    targetId: string
    targetType: $Enums.ActivityTargetType
    type: $Enums.ActivityType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityCreateManyInput = {
    id?: string
    targetId: string
    targetType: $Enums.ActivityTargetType
    type: $Enums.ActivityType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumActivityTargetTypeFieldUpdateOperationsInput | $Enums.ActivityTargetType
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
    project: ProjectCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    taskId: string
    projectId: string
    content: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    taskId: string
    projectId: string
    content: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    clientSecret: string
    scopes?: ApplicationCreatescopesInput | string[]
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    organization: OrganizationCreateNestedOneWithoutApplicationsInput
  }

  export type ApplicationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    clientSecret: string
    organizationId: string
    scopes?: ApplicationCreatescopesInput | string[]
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    scopes?: ApplicationUpdatescopesInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    scopes?: ApplicationUpdatescopesInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    clientSecret: string
    organizationId: string
    scopes?: ApplicationCreatescopesInput | string[]
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    scopes?: ApplicationUpdatescopesInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    scopes?: ApplicationUpdatescopesInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimerCreateInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutTimersInput
    user: UserCreateNestedOneWithoutTimersInput
  }

  export type TimerUncheckedCreateInput = {
    id?: string
    taskId: string
    userId: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTimersNestedInput
    user?: UserUpdateOneRequiredWithoutTimersNestedInput
  }

  export type TimerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimerCreateManyInput = {
    id?: string
    taskId: string
    userId: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateInput = {
    id?: string
    name: string
    icon: string
    link: string
    type: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    user: UserCreateNestedOneWithoutFavoritesInput
    organization: OrganizationCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: string
    name: string
    icon: string
    link: string
    userId: string
    organizationId: string
    type: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type FavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FavoriteCreateManyInput = {
    id?: string
    name: string
    icon: string
    link: string
    userId: string
    organizationId: string
    type: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type FavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableFilter<$PrismaModel> | $Enums.UserStatus | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type OrganizationMemberListRelationFilter = {
    every?: OrganizationMemberWhereInput
    some?: OrganizationMemberWhereInput
    none?: OrganizationMemberWhereInput
  }

  export type TaskAssigneeListRelationFilter = {
    every?: TaskAssigneeWhereInput
    some?: TaskAssigneeWhereInput
    none?: TaskAssigneeWhereInput
  }

  export type ProjectSettingNotificationListRelationFilter = {
    every?: ProjectSettingNotificationWhereInput
    some?: ProjectSettingNotificationWhereInput
    none?: ProjectSettingNotificationWhereInput
  }

  export type StatListRelationFilter = {
    every?: StatWhereInput
    some?: StatWhereInput
    none?: StatWhereInput
  }

  export type TimerListRelationFilter = {
    every?: TimerWhereInput
    some?: TimerWhereInput
    none?: TimerWhereInput
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAssigneeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectSettingNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    status?: SortOrder
    country?: SortOrder
    bio?: SortOrder
    photo?: SortOrder
    dob?: SortOrder
    resetToken?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    status?: SortOrder
    country?: SortOrder
    bio?: SortOrder
    photo?: SortOrder
    dob?: SortOrder
    resetToken?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    status?: SortOrder
    country?: SortOrder
    bio?: SortOrder
    photo?: SortOrder
    dob?: SortOrder
    resetToken?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserStatusNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type VisionListRelationFilter = {
    every?: VisionWhereInput
    some?: VisionWhereInput
    none?: VisionWhereInput
  }

  export type TaskAutomationListRelationFilter = {
    every?: TaskAutomationWhereInput
    some?: TaskAutomationWhereInput
    none?: TaskAutomationWhereInput
  }

  export type SchedulerListRelationFilter = {
    every?: SchedulerWhereInput
    some?: SchedulerWhereInput
    none?: SchedulerWhereInput
  }

  export type FileStorageListRelationFilter = {
    every?: FileStorageWhereInput
    some?: FileStorageWhereInput
    none?: FileStorageWhereInput
  }

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput
    some?: ApplicationWhereInput
    none?: ApplicationWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAutomationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchedulerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    maxStorageSize?: SortOrder
    desc?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    maxStorageSize?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    maxStorageSize?: SortOrder
    desc?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    maxStorageSize?: SortOrder
    desc?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    maxStorageSize?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type EnumOrganizationRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationRole | EnumOrganizationRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationRoleFilter<$PrismaModel> | $Enums.OrganizationRole
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrganizationMemberOrganizationIdUserIdCompoundUniqueInput = {
    organizationId: string
    userId: string
  }

  export type OrganizationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrganizationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrganizationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type EnumOrganizationRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationRole | EnumOrganizationRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrganizationRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrganizationRoleFilter<$PrismaModel>
    _max?: NestedEnumOrganizationRoleFilter<$PrismaModel>
  }

  export type EnumOrgStorageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStorageType | EnumOrgStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStorageType[] | ListEnumOrgStorageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStorageType[] | ListEnumOrgStorageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStorageTypeFilter<$PrismaModel> | $Enums.OrgStorageType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OrganizationStorageCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    config?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrganizationStorageMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrganizationStorageMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumOrgStorageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStorageType | EnumOrgStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStorageType[] | ListEnumOrgStorageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStorageType[] | ListEnumOrgStorageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStorageTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrgStorageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgStorageTypeFilter<$PrismaModel>
    _max?: NestedEnumOrgStorageTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProjectViewNullableScalarRelationFilter = {
    is?: ProjectViewWhereInput | null
    isNot?: ProjectViewWhereInput | null
  }

  export type FieldListRelationFilter = {
    every?: FieldWhereInput
    some?: FieldWhereInput
    none?: FieldWhereInput
  }

  export type GridListRelationFilter = {
    every?: GridWhereInput
    some?: GridWhereInput
    none?: GridWhereInput
  }

  export type TaskStatusListRelationFilter = {
    every?: TaskStatusWhereInput
    some?: TaskStatusWhereInput
    none?: TaskStatusWhereInput
  }

  export type TaskPointListRelationFilter = {
    every?: TaskPointWhereInput
    some?: TaskPointWhereInput
    none?: TaskPointWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type DashboardListRelationFilter = {
    every?: DashboardWhereInput
    some?: DashboardWhereInput
    none?: DashboardWhereInput
  }

  export type FieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GridOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskPointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DashboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    desc?: SortOrder
    cover?: SortOrder
    icon?: SortOrder
    isArchived?: SortOrder
    countMemberTask?: SortOrder
    countProjectTask?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    desc?: SortOrder
    cover?: SortOrder
    icon?: SortOrder
    isArchived?: SortOrder
    countMemberTask?: SortOrder
    countProjectTask?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organizationId?: SortOrder
    desc?: SortOrder
    cover?: SortOrder
    icon?: SortOrder
    isArchived?: SortOrder
    countMemberTask?: SortOrder
    countProjectTask?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumProjectViewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectViewType | EnumProjectViewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectViewType[] | ListEnumProjectViewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectViewType[] | ListEnumProjectViewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectViewTypeFilter<$PrismaModel> | $Enums.ProjectViewType
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type ProjectViewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    onlyMe?: SortOrder
    icon?: SortOrder
    projectId?: SortOrder
    order?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectViewAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProjectViewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    onlyMe?: SortOrder
    icon?: SortOrder
    projectId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectViewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    onlyMe?: SortOrder
    icon?: SortOrder
    projectId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectViewSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumProjectViewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectViewType | EnumProjectViewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectViewType[] | ListEnumProjectViewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectViewType[] | ListEnumProjectViewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectViewTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProjectViewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectViewTypeFilter<$PrismaModel>
    _max?: NestedEnumProjectViewTypeFilter<$PrismaModel>
  }

  export type ProjectSettingNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    taskChanges?: SortOrder
    remind?: SortOrder
    overdue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ProjectSettingNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    taskChanges?: SortOrder
    remind?: SortOrder
    overdue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ProjectSettingNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    taskChanges?: SortOrder
    remind?: SortOrder
    overdue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumTaskTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskTypeNullableFilter<$PrismaModel> | $Enums.TaskType | null
  }

  export type EnumTaskPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskPriorityNullableFilter<$PrismaModel> | $Enums.TaskPriority | null
  }

  export type TaskChecklistListRelationFilter = {
    every?: TaskChecklistWhereInput
    some?: TaskChecklistWhereInput
    none?: TaskChecklistWhereInput
  }

  export type TaskTagListRelationFilter = {
    every?: TaskTagWhereInput
    some?: TaskTagWhereInput
    none?: TaskTagWhereInput
  }

  export type TaskNullableScalarRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type TaskStatusNullableScalarRelationFilter = {
    is?: TaskStatusWhereInput | null
    isNot?: TaskStatusWhereInput | null
  }

  export type TaskChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    dueDate?: SortOrder
    order?: SortOrder
    type?: SortOrder
    checklistDone?: SortOrder
    checklistTodos?: SortOrder
    cover?: SortOrder
    plannedStartDate?: SortOrder
    plannedDueDate?: SortOrder
    startDate?: SortOrder
    projectId?: SortOrder
    priority?: SortOrder
    taskStatusId?: SortOrder
    parentTaskId?: SortOrder
    progress?: SortOrder
    done?: SortOrder
    taskPoint?: SortOrder
    customFields?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    order?: SortOrder
    checklistDone?: SortOrder
    checklistTodos?: SortOrder
    progress?: SortOrder
    taskPoint?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    dueDate?: SortOrder
    order?: SortOrder
    type?: SortOrder
    checklistDone?: SortOrder
    checklistTodos?: SortOrder
    cover?: SortOrder
    plannedStartDate?: SortOrder
    plannedDueDate?: SortOrder
    startDate?: SortOrder
    projectId?: SortOrder
    priority?: SortOrder
    taskStatusId?: SortOrder
    parentTaskId?: SortOrder
    progress?: SortOrder
    done?: SortOrder
    taskPoint?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    dueDate?: SortOrder
    order?: SortOrder
    type?: SortOrder
    checklistDone?: SortOrder
    checklistTodos?: SortOrder
    cover?: SortOrder
    plannedStartDate?: SortOrder
    plannedDueDate?: SortOrder
    startDate?: SortOrder
    projectId?: SortOrder
    priority?: SortOrder
    taskStatusId?: SortOrder
    parentTaskId?: SortOrder
    progress?: SortOrder
    done?: SortOrder
    taskPoint?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    order?: SortOrder
    checklistDone?: SortOrder
    checklistTodos?: SortOrder
    progress?: SortOrder
    taskPoint?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTaskTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeNullableFilter<$PrismaModel>
  }

  export type EnumTaskPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityNullableFilter<$PrismaModel>
  }

  export type EnumStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeFilter<$PrismaModel> | $Enums.StatusType
  }

  export type TaskStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    order?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
  }

  export type TaskStatusAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TaskStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    order?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
  }

  export type TaskStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    order?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
  }

  export type TaskStatusSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumStatusTypeFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskAssigneeTaskIdUserIdCompoundUniqueInput = {
    taskId: string
    userId: string
  }

  export type TaskAssigneeCountOrderByAggregateInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssigneeMaxOrderByAggregateInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TaskAssigneeMinOrderByAggregateInput = {
    taskId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type TaskChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    taskId?: SortOrder
    done?: SortOrder
    doneAt?: SortOrder
  }

  export type TaskChecklistAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TaskChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    taskId?: SortOrder
    done?: SortOrder
    doneAt?: SortOrder
  }

  export type TaskChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    taskId?: SortOrder
    done?: SortOrder
    doneAt?: SortOrder
  }

  export type TaskChecklistSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type TaskPointCountOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    projectId?: SortOrder
    icon?: SortOrder
  }

  export type TaskPointAvgOrderByAggregateInput = {
    point?: SortOrder
  }

  export type TaskPointMaxOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    projectId?: SortOrder
    icon?: SortOrder
  }

  export type TaskPointMinOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    projectId?: SortOrder
    icon?: SortOrder
  }

  export type TaskPointSumOrderByAggregateInput = {
    point?: SortOrder
  }

  export type TaskAutomationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    when?: SortOrder
    then?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TaskAutomationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TaskAutomationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type VisionNullableScalarRelationFilter = {
    is?: VisionWhereInput | null
    isNot?: VisionWhereInput | null
  }

  export type VisionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    progress?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type VisionAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type VisionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    progress?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type VisionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    progress?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type VisionSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type FieldCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    hidden?: SortOrder
    width?: SortOrder
    order?: SortOrder
    desc?: SortOrder
    data?: SortOrder
    config?: SortOrder
  }

  export type FieldAvgOrderByAggregateInput = {
    width?: SortOrder
    order?: SortOrder
  }

  export type FieldMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    hidden?: SortOrder
    width?: SortOrder
    order?: SortOrder
    desc?: SortOrder
  }

  export type FieldMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    hidden?: SortOrder
    width?: SortOrder
    order?: SortOrder
    desc?: SortOrder
  }

  export type FieldSumOrderByAggregateInput = {
    width?: SortOrder
    order?: SortOrder
  }

  export type EnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type GridCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    cover?: SortOrder
    projectId?: SortOrder
    customFields?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type GridMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    cover?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type GridMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    cover?: SortOrder
    projectId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    projectId?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    projectId?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    projectId?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TaskTagTaskIdTagIdCompoundUniqueInput = {
    taskId: string
    tagId: string
  }

  export type TaskTagCountOrderByAggregateInput = {
    taskId?: SortOrder
    tagId?: SortOrder
  }

  export type TaskTagMaxOrderByAggregateInput = {
    taskId?: SortOrder
    tagId?: SortOrder
  }

  export type TaskTagMinOrderByAggregateInput = {
    taskId?: SortOrder
    tagId?: SortOrder
  }

  export type SchedulerCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    cronId?: SortOrder
    trigger?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SchedulerMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    cronId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SchedulerMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    cronId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumFileOwnerTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FileOwnerType | EnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FileOwnerType[] | ListEnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FileOwnerType[] | ListEnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFileOwnerTypeNullableFilter<$PrismaModel> | $Enums.FileOwnerType | null
  }

  export type FileStorageCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    taskId?: SortOrder
    name?: SortOrder
    keyName?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    parentId?: SortOrder
    owner?: SortOrder
    ownerType?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type FileStorageAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileStorageMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    taskId?: SortOrder
    name?: SortOrder
    keyName?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    parentId?: SortOrder
    owner?: SortOrder
    ownerType?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type FileStorageMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    projectId?: SortOrder
    taskId?: SortOrder
    name?: SortOrder
    keyName?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    parentId?: SortOrder
    owner?: SortOrder
    ownerType?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type FileStorageSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumFileOwnerTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileOwnerType | EnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FileOwnerType[] | ListEnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FileOwnerType[] | ListEnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFileOwnerTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FileOwnerType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFileOwnerTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFileOwnerTypeNullableFilter<$PrismaModel>
  }

  export type EnumStatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatType | EnumStatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatType[] | ListEnumStatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatType[] | ListEnumStatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatTypeFilter<$PrismaModel> | $Enums.StatType
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StatCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    date?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    date?: SortOrder
  }

  export type StatMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    date?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    organizationId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    date?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatSumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    date?: SortOrder
  }

  export type EnumStatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatType | EnumStatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatType[] | ListEnumStatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatType[] | ListEnumStatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatTypeFilter<$PrismaModel>
    _max?: NestedEnumStatTypeFilter<$PrismaModel>
  }

  export type DashboardComponentListRelationFilter = {
    every?: DashboardComponentWhereInput
    some?: DashboardComponentWhereInput
    none?: DashboardComponentWhereInput
  }

  export type DashboardComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DashboardCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    projectId?: SortOrder
    isDefault?: SortOrder
  }

  export type DashboardMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    projectId?: SortOrder
    isDefault?: SortOrder
  }

  export type DashboardMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    projectId?: SortOrder
    isDefault?: SortOrder
  }

  export type EnumDashboardComponentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DashboardComponentType | EnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DashboardComponentType[] | ListEnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DashboardComponentType[] | ListEnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDashboardComponentTypeNullableFilter<$PrismaModel> | $Enums.DashboardComponentType | null
  }

  export type DashboardNullableScalarRelationFilter = {
    is?: DashboardWhereInput | null
    isNot?: DashboardWhereInput | null
  }

  export type DashboardComponentCountOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    config?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DashboardComponentAvgOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type DashboardComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DashboardComponentMinOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DashboardComponentSumOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type EnumDashboardComponentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DashboardComponentType | EnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DashboardComponentType[] | ListEnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DashboardComponentType[] | ListEnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDashboardComponentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DashboardComponentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDashboardComponentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDashboardComponentTypeNullableFilter<$PrismaModel>
  }

  export type EnumActivityTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetType | EnumActivityTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTargetTypeFilter<$PrismaModel> | $Enums.ActivityTargetType
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    type?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumActivityTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetType | EnumActivityTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTargetTypeFilter<$PrismaModel>
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    projectId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    organizationId?: SortOrder
    scopes?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TimerCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimerAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type TimerMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimerMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimerSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    link?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    link?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    link?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type OrganizationMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type TaskAssigneeCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type ProjectSettingNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectSettingNotificationCreateWithoutUserInput, ProjectSettingNotificationUncheckedCreateWithoutUserInput> | ProjectSettingNotificationCreateWithoutUserInput[] | ProjectSettingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectSettingNotificationCreateOrConnectWithoutUserInput | ProjectSettingNotificationCreateOrConnectWithoutUserInput[]
    createMany?: ProjectSettingNotificationCreateManyUserInputEnvelope
    connect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
  }

  export type StatCreateNestedManyWithoutUserInput = {
    create?: XOR<StatCreateWithoutUserInput, StatUncheckedCreateWithoutUserInput> | StatCreateWithoutUserInput[] | StatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StatCreateOrConnectWithoutUserInput | StatCreateOrConnectWithoutUserInput[]
    createMany?: StatCreateManyUserInputEnvelope
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
  }

  export type TimerCreateNestedManyWithoutUserInput = {
    create?: XOR<TimerCreateWithoutUserInput, TimerUncheckedCreateWithoutUserInput> | TimerCreateWithoutUserInput[] | TimerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimerCreateOrConnectWithoutUserInput | TimerCreateOrConnectWithoutUserInput[]
    createMany?: TimerCreateManyUserInputEnvelope
    connect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type TaskAssigneeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type ProjectSettingNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectSettingNotificationCreateWithoutUserInput, ProjectSettingNotificationUncheckedCreateWithoutUserInput> | ProjectSettingNotificationCreateWithoutUserInput[] | ProjectSettingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectSettingNotificationCreateOrConnectWithoutUserInput | ProjectSettingNotificationCreateOrConnectWithoutUserInput[]
    createMany?: ProjectSettingNotificationCreateManyUserInputEnvelope
    connect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
  }

  export type StatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StatCreateWithoutUserInput, StatUncheckedCreateWithoutUserInput> | StatCreateWithoutUserInput[] | StatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StatCreateOrConnectWithoutUserInput | StatCreateOrConnectWithoutUserInput[]
    createMany?: StatCreateManyUserInputEnvelope
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
  }

  export type TimerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimerCreateWithoutUserInput, TimerUncheckedCreateWithoutUserInput> | TimerCreateWithoutUserInput[] | TimerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimerCreateOrConnectWithoutUserInput | TimerCreateOrConnectWithoutUserInput[]
    createMany?: TimerCreateManyUserInputEnvelope
    connect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type OrganizationMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type TaskAssigneeUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutUserInput | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutUserInput | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutUserInput | TaskAssigneeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type ProjectSettingNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectSettingNotificationCreateWithoutUserInput, ProjectSettingNotificationUncheckedCreateWithoutUserInput> | ProjectSettingNotificationCreateWithoutUserInput[] | ProjectSettingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectSettingNotificationCreateOrConnectWithoutUserInput | ProjectSettingNotificationCreateOrConnectWithoutUserInput[]
    upsert?: ProjectSettingNotificationUpsertWithWhereUniqueWithoutUserInput | ProjectSettingNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectSettingNotificationCreateManyUserInputEnvelope
    set?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    disconnect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    delete?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    connect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    update?: ProjectSettingNotificationUpdateWithWhereUniqueWithoutUserInput | ProjectSettingNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectSettingNotificationUpdateManyWithWhereWithoutUserInput | ProjectSettingNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectSettingNotificationScalarWhereInput | ProjectSettingNotificationScalarWhereInput[]
  }

  export type StatUpdateManyWithoutUserNestedInput = {
    create?: XOR<StatCreateWithoutUserInput, StatUncheckedCreateWithoutUserInput> | StatCreateWithoutUserInput[] | StatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StatCreateOrConnectWithoutUserInput | StatCreateOrConnectWithoutUserInput[]
    upsert?: StatUpsertWithWhereUniqueWithoutUserInput | StatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StatCreateManyUserInputEnvelope
    set?: StatWhereUniqueInput | StatWhereUniqueInput[]
    disconnect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    delete?: StatWhereUniqueInput | StatWhereUniqueInput[]
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    update?: StatUpdateWithWhereUniqueWithoutUserInput | StatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StatUpdateManyWithWhereWithoutUserInput | StatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StatScalarWhereInput | StatScalarWhereInput[]
  }

  export type TimerUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimerCreateWithoutUserInput, TimerUncheckedCreateWithoutUserInput> | TimerCreateWithoutUserInput[] | TimerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimerCreateOrConnectWithoutUserInput | TimerCreateOrConnectWithoutUserInput[]
    upsert?: TimerUpsertWithWhereUniqueWithoutUserInput | TimerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimerCreateManyUserInputEnvelope
    set?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    disconnect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    delete?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    connect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    update?: TimerUpdateWithWhereUniqueWithoutUserInput | TimerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimerUpdateManyWithWhereWithoutUserInput | TimerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimerScalarWhereInput | TimerScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutUserInput | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutUserInput | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutUserInput | TaskAssigneeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type ProjectSettingNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectSettingNotificationCreateWithoutUserInput, ProjectSettingNotificationUncheckedCreateWithoutUserInput> | ProjectSettingNotificationCreateWithoutUserInput[] | ProjectSettingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectSettingNotificationCreateOrConnectWithoutUserInput | ProjectSettingNotificationCreateOrConnectWithoutUserInput[]
    upsert?: ProjectSettingNotificationUpsertWithWhereUniqueWithoutUserInput | ProjectSettingNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectSettingNotificationCreateManyUserInputEnvelope
    set?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    disconnect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    delete?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    connect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    update?: ProjectSettingNotificationUpdateWithWhereUniqueWithoutUserInput | ProjectSettingNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectSettingNotificationUpdateManyWithWhereWithoutUserInput | ProjectSettingNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectSettingNotificationScalarWhereInput | ProjectSettingNotificationScalarWhereInput[]
  }

  export type StatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StatCreateWithoutUserInput, StatUncheckedCreateWithoutUserInput> | StatCreateWithoutUserInput[] | StatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StatCreateOrConnectWithoutUserInput | StatCreateOrConnectWithoutUserInput[]
    upsert?: StatUpsertWithWhereUniqueWithoutUserInput | StatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StatCreateManyUserInputEnvelope
    set?: StatWhereUniqueInput | StatWhereUniqueInput[]
    disconnect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    delete?: StatWhereUniqueInput | StatWhereUniqueInput[]
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    update?: StatUpdateWithWhereUniqueWithoutUserInput | StatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StatUpdateManyWithWhereWithoutUserInput | StatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StatScalarWhereInput | StatScalarWhereInput[]
  }

  export type TimerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimerCreateWithoutUserInput, TimerUncheckedCreateWithoutUserInput> | TimerCreateWithoutUserInput[] | TimerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimerCreateOrConnectWithoutUserInput | TimerCreateOrConnectWithoutUserInput[]
    upsert?: TimerUpsertWithWhereUniqueWithoutUserInput | TimerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimerCreateManyUserInputEnvelope
    set?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    disconnect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    delete?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    connect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    update?: TimerUpdateWithWhereUniqueWithoutUserInput | TimerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimerUpdateManyWithWhereWithoutUserInput | TimerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimerScalarWhereInput | TimerScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type VisionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<VisionCreateWithoutOrganizationInput, VisionUncheckedCreateWithoutOrganizationInput> | VisionCreateWithoutOrganizationInput[] | VisionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutOrganizationInput | VisionCreateOrConnectWithoutOrganizationInput[]
    createMany?: VisionCreateManyOrganizationInputEnvelope
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
  }

  export type OrganizationMemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type TaskAutomationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TaskAutomationCreateWithoutOrganizationInput, TaskAutomationUncheckedCreateWithoutOrganizationInput> | TaskAutomationCreateWithoutOrganizationInput[] | TaskAutomationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TaskAutomationCreateOrConnectWithoutOrganizationInput | TaskAutomationCreateOrConnectWithoutOrganizationInput[]
    createMany?: TaskAutomationCreateManyOrganizationInputEnvelope
    connect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
  }

  export type SchedulerCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SchedulerCreateWithoutOrganizationInput, SchedulerUncheckedCreateWithoutOrganizationInput> | SchedulerCreateWithoutOrganizationInput[] | SchedulerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SchedulerCreateOrConnectWithoutOrganizationInput | SchedulerCreateOrConnectWithoutOrganizationInput[]
    createMany?: SchedulerCreateManyOrganizationInputEnvelope
    connect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
  }

  export type FileStorageCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FileStorageCreateWithoutOrganizationInput, FileStorageUncheckedCreateWithoutOrganizationInput> | FileStorageCreateWithoutOrganizationInput[] | FileStorageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutOrganizationInput | FileStorageCreateOrConnectWithoutOrganizationInput[]
    createMany?: FileStorageCreateManyOrganizationInputEnvelope
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
  }

  export type StatCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StatCreateWithoutOrganizationInput, StatUncheckedCreateWithoutOrganizationInput> | StatCreateWithoutOrganizationInput[] | StatUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StatCreateOrConnectWithoutOrganizationInput | StatCreateOrConnectWithoutOrganizationInput[]
    createMany?: StatCreateManyOrganizationInputEnvelope
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
  }

  export type ApplicationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ApplicationCreateWithoutOrganizationInput, ApplicationUncheckedCreateWithoutOrganizationInput> | ApplicationCreateWithoutOrganizationInput[] | ApplicationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutOrganizationInput | ApplicationCreateOrConnectWithoutOrganizationInput[]
    createMany?: ApplicationCreateManyOrganizationInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FavoriteCreateWithoutOrganizationInput, FavoriteUncheckedCreateWithoutOrganizationInput> | FavoriteCreateWithoutOrganizationInput[] | FavoriteUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutOrganizationInput | FavoriteCreateOrConnectWithoutOrganizationInput[]
    createMany?: FavoriteCreateManyOrganizationInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type VisionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<VisionCreateWithoutOrganizationInput, VisionUncheckedCreateWithoutOrganizationInput> | VisionCreateWithoutOrganizationInput[] | VisionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutOrganizationInput | VisionCreateOrConnectWithoutOrganizationInput[]
    createMany?: VisionCreateManyOrganizationInputEnvelope
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TaskAutomationCreateWithoutOrganizationInput, TaskAutomationUncheckedCreateWithoutOrganizationInput> | TaskAutomationCreateWithoutOrganizationInput[] | TaskAutomationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TaskAutomationCreateOrConnectWithoutOrganizationInput | TaskAutomationCreateOrConnectWithoutOrganizationInput[]
    createMany?: TaskAutomationCreateManyOrganizationInputEnvelope
    connect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
  }

  export type SchedulerUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SchedulerCreateWithoutOrganizationInput, SchedulerUncheckedCreateWithoutOrganizationInput> | SchedulerCreateWithoutOrganizationInput[] | SchedulerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SchedulerCreateOrConnectWithoutOrganizationInput | SchedulerCreateOrConnectWithoutOrganizationInput[]
    createMany?: SchedulerCreateManyOrganizationInputEnvelope
    connect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
  }

  export type FileStorageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FileStorageCreateWithoutOrganizationInput, FileStorageUncheckedCreateWithoutOrganizationInput> | FileStorageCreateWithoutOrganizationInput[] | FileStorageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutOrganizationInput | FileStorageCreateOrConnectWithoutOrganizationInput[]
    createMany?: FileStorageCreateManyOrganizationInputEnvelope
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
  }

  export type StatUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StatCreateWithoutOrganizationInput, StatUncheckedCreateWithoutOrganizationInput> | StatCreateWithoutOrganizationInput[] | StatUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StatCreateOrConnectWithoutOrganizationInput | StatCreateOrConnectWithoutOrganizationInput[]
    createMany?: StatCreateManyOrganizationInputEnvelope
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ApplicationCreateWithoutOrganizationInput, ApplicationUncheckedCreateWithoutOrganizationInput> | ApplicationCreateWithoutOrganizationInput[] | ApplicationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutOrganizationInput | ApplicationCreateOrConnectWithoutOrganizationInput[]
    createMany?: ApplicationCreateManyOrganizationInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FavoriteCreateWithoutOrganizationInput, FavoriteUncheckedCreateWithoutOrganizationInput> | FavoriteCreateWithoutOrganizationInput[] | FavoriteUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutOrganizationInput | FavoriteCreateOrConnectWithoutOrganizationInput[]
    createMany?: FavoriteCreateManyOrganizationInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type VisionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<VisionCreateWithoutOrganizationInput, VisionUncheckedCreateWithoutOrganizationInput> | VisionCreateWithoutOrganizationInput[] | VisionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutOrganizationInput | VisionCreateOrConnectWithoutOrganizationInput[]
    upsert?: VisionUpsertWithWhereUniqueWithoutOrganizationInput | VisionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: VisionCreateManyOrganizationInputEnvelope
    set?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    disconnect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    delete?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    update?: VisionUpdateWithWhereUniqueWithoutOrganizationInput | VisionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: VisionUpdateManyWithWhereWithoutOrganizationInput | VisionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: VisionScalarWhereInput | VisionScalarWhereInput[]
  }

  export type OrganizationMemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type TaskAutomationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TaskAutomationCreateWithoutOrganizationInput, TaskAutomationUncheckedCreateWithoutOrganizationInput> | TaskAutomationCreateWithoutOrganizationInput[] | TaskAutomationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TaskAutomationCreateOrConnectWithoutOrganizationInput | TaskAutomationCreateOrConnectWithoutOrganizationInput[]
    upsert?: TaskAutomationUpsertWithWhereUniqueWithoutOrganizationInput | TaskAutomationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TaskAutomationCreateManyOrganizationInputEnvelope
    set?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    disconnect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    delete?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    connect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    update?: TaskAutomationUpdateWithWhereUniqueWithoutOrganizationInput | TaskAutomationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TaskAutomationUpdateManyWithWhereWithoutOrganizationInput | TaskAutomationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TaskAutomationScalarWhereInput | TaskAutomationScalarWhereInput[]
  }

  export type SchedulerUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SchedulerCreateWithoutOrganizationInput, SchedulerUncheckedCreateWithoutOrganizationInput> | SchedulerCreateWithoutOrganizationInput[] | SchedulerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SchedulerCreateOrConnectWithoutOrganizationInput | SchedulerCreateOrConnectWithoutOrganizationInput[]
    upsert?: SchedulerUpsertWithWhereUniqueWithoutOrganizationInput | SchedulerUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SchedulerCreateManyOrganizationInputEnvelope
    set?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    disconnect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    delete?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    connect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    update?: SchedulerUpdateWithWhereUniqueWithoutOrganizationInput | SchedulerUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SchedulerUpdateManyWithWhereWithoutOrganizationInput | SchedulerUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SchedulerScalarWhereInput | SchedulerScalarWhereInput[]
  }

  export type FileStorageUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FileStorageCreateWithoutOrganizationInput, FileStorageUncheckedCreateWithoutOrganizationInput> | FileStorageCreateWithoutOrganizationInput[] | FileStorageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutOrganizationInput | FileStorageCreateOrConnectWithoutOrganizationInput[]
    upsert?: FileStorageUpsertWithWhereUniqueWithoutOrganizationInput | FileStorageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FileStorageCreateManyOrganizationInputEnvelope
    set?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    disconnect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    delete?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    update?: FileStorageUpdateWithWhereUniqueWithoutOrganizationInput | FileStorageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FileStorageUpdateManyWithWhereWithoutOrganizationInput | FileStorageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
  }

  export type StatUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StatCreateWithoutOrganizationInput, StatUncheckedCreateWithoutOrganizationInput> | StatCreateWithoutOrganizationInput[] | StatUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StatCreateOrConnectWithoutOrganizationInput | StatCreateOrConnectWithoutOrganizationInput[]
    upsert?: StatUpsertWithWhereUniqueWithoutOrganizationInput | StatUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StatCreateManyOrganizationInputEnvelope
    set?: StatWhereUniqueInput | StatWhereUniqueInput[]
    disconnect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    delete?: StatWhereUniqueInput | StatWhereUniqueInput[]
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    update?: StatUpdateWithWhereUniqueWithoutOrganizationInput | StatUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StatUpdateManyWithWhereWithoutOrganizationInput | StatUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StatScalarWhereInput | StatScalarWhereInput[]
  }

  export type ApplicationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ApplicationCreateWithoutOrganizationInput, ApplicationUncheckedCreateWithoutOrganizationInput> | ApplicationCreateWithoutOrganizationInput[] | ApplicationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutOrganizationInput | ApplicationCreateOrConnectWithoutOrganizationInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutOrganizationInput | ApplicationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ApplicationCreateManyOrganizationInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutOrganizationInput | ApplicationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutOrganizationInput | ApplicationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FavoriteCreateWithoutOrganizationInput, FavoriteUncheckedCreateWithoutOrganizationInput> | FavoriteCreateWithoutOrganizationInput[] | FavoriteUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutOrganizationInput | FavoriteCreateOrConnectWithoutOrganizationInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutOrganizationInput | FavoriteUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FavoriteCreateManyOrganizationInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutOrganizationInput | FavoriteUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutOrganizationInput | FavoriteUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type VisionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<VisionCreateWithoutOrganizationInput, VisionUncheckedCreateWithoutOrganizationInput> | VisionCreateWithoutOrganizationInput[] | VisionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutOrganizationInput | VisionCreateOrConnectWithoutOrganizationInput[]
    upsert?: VisionUpsertWithWhereUniqueWithoutOrganizationInput | VisionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: VisionCreateManyOrganizationInputEnvelope
    set?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    disconnect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    delete?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    update?: VisionUpdateWithWhereUniqueWithoutOrganizationInput | VisionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: VisionUpdateManyWithWhereWithoutOrganizationInput | VisionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: VisionScalarWhereInput | VisionScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TaskAutomationCreateWithoutOrganizationInput, TaskAutomationUncheckedCreateWithoutOrganizationInput> | TaskAutomationCreateWithoutOrganizationInput[] | TaskAutomationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TaskAutomationCreateOrConnectWithoutOrganizationInput | TaskAutomationCreateOrConnectWithoutOrganizationInput[]
    upsert?: TaskAutomationUpsertWithWhereUniqueWithoutOrganizationInput | TaskAutomationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TaskAutomationCreateManyOrganizationInputEnvelope
    set?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    disconnect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    delete?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    connect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    update?: TaskAutomationUpdateWithWhereUniqueWithoutOrganizationInput | TaskAutomationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TaskAutomationUpdateManyWithWhereWithoutOrganizationInput | TaskAutomationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TaskAutomationScalarWhereInput | TaskAutomationScalarWhereInput[]
  }

  export type SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SchedulerCreateWithoutOrganizationInput, SchedulerUncheckedCreateWithoutOrganizationInput> | SchedulerCreateWithoutOrganizationInput[] | SchedulerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SchedulerCreateOrConnectWithoutOrganizationInput | SchedulerCreateOrConnectWithoutOrganizationInput[]
    upsert?: SchedulerUpsertWithWhereUniqueWithoutOrganizationInput | SchedulerUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SchedulerCreateManyOrganizationInputEnvelope
    set?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    disconnect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    delete?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    connect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    update?: SchedulerUpdateWithWhereUniqueWithoutOrganizationInput | SchedulerUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SchedulerUpdateManyWithWhereWithoutOrganizationInput | SchedulerUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SchedulerScalarWhereInput | SchedulerScalarWhereInput[]
  }

  export type FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FileStorageCreateWithoutOrganizationInput, FileStorageUncheckedCreateWithoutOrganizationInput> | FileStorageCreateWithoutOrganizationInput[] | FileStorageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutOrganizationInput | FileStorageCreateOrConnectWithoutOrganizationInput[]
    upsert?: FileStorageUpsertWithWhereUniqueWithoutOrganizationInput | FileStorageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FileStorageCreateManyOrganizationInputEnvelope
    set?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    disconnect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    delete?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    update?: FileStorageUpdateWithWhereUniqueWithoutOrganizationInput | FileStorageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FileStorageUpdateManyWithWhereWithoutOrganizationInput | FileStorageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
  }

  export type StatUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StatCreateWithoutOrganizationInput, StatUncheckedCreateWithoutOrganizationInput> | StatCreateWithoutOrganizationInput[] | StatUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StatCreateOrConnectWithoutOrganizationInput | StatCreateOrConnectWithoutOrganizationInput[]
    upsert?: StatUpsertWithWhereUniqueWithoutOrganizationInput | StatUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StatCreateManyOrganizationInputEnvelope
    set?: StatWhereUniqueInput | StatWhereUniqueInput[]
    disconnect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    delete?: StatWhereUniqueInput | StatWhereUniqueInput[]
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    update?: StatUpdateWithWhereUniqueWithoutOrganizationInput | StatUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StatUpdateManyWithWhereWithoutOrganizationInput | StatUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StatScalarWhereInput | StatScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ApplicationCreateWithoutOrganizationInput, ApplicationUncheckedCreateWithoutOrganizationInput> | ApplicationCreateWithoutOrganizationInput[] | ApplicationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutOrganizationInput | ApplicationCreateOrConnectWithoutOrganizationInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutOrganizationInput | ApplicationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ApplicationCreateManyOrganizationInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutOrganizationInput | ApplicationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutOrganizationInput | ApplicationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FavoriteCreateWithoutOrganizationInput, FavoriteUncheckedCreateWithoutOrganizationInput> | FavoriteCreateWithoutOrganizationInput[] | FavoriteUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutOrganizationInput | FavoriteCreateOrConnectWithoutOrganizationInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutOrganizationInput | FavoriteUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FavoriteCreateManyOrganizationInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutOrganizationInput | FavoriteUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutOrganizationInput | FavoriteUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutOrganizationMembersInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationMembersInput, OrganizationUncheckedCreateWithoutOrganizationMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrganizationMembersInput = {
    create?: XOR<UserCreateWithoutOrganizationMembersInput, UserUncheckedCreateWithoutOrganizationMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationMembersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type EnumOrganizationRoleFieldUpdateOperationsInput = {
    set?: $Enums.OrganizationRole
  }

  export type OrganizationUpdateOneRequiredWithoutOrganizationMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationMembersInput, OrganizationUncheckedCreateWithoutOrganizationMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationMembersInput
    upsert?: OrganizationUpsertWithoutOrganizationMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrganizationMembersInput, OrganizationUpdateWithoutOrganizationMembersInput>, OrganizationUncheckedUpdateWithoutOrganizationMembersInput>
  }

  export type UserUpdateOneRequiredWithoutOrganizationMembersNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationMembersInput, UserUncheckedCreateWithoutOrganizationMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationMembersInput
    upsert?: UserUpsertWithoutOrganizationMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationMembersInput, UserUpdateWithoutOrganizationMembersInput>, UserUncheckedUpdateWithoutOrganizationMembersInput>
  }

  export type EnumOrgStorageTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrgStorageType
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembersInput = {
    create?: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.MemberRole
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersInput
    upsert?: UserUpsertWithoutMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembersInput, UserUpdateWithoutMembersInput>, UserUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectViewCreateNestedOneWithoutProjectInput = {
    create?: XOR<ProjectViewCreateWithoutProjectInput, ProjectViewUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectViewCreateOrConnectWithoutProjectInput
    connect?: ProjectViewWhereUniqueInput
  }

  export type FieldCreateNestedManyWithoutProjectInput = {
    create?: XOR<FieldCreateWithoutProjectInput, FieldUncheckedCreateWithoutProjectInput> | FieldCreateWithoutProjectInput[] | FieldUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutProjectInput | FieldCreateOrConnectWithoutProjectInput[]
    createMany?: FieldCreateManyProjectInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type VisionCreateNestedManyWithoutProjectInput = {
    create?: XOR<VisionCreateWithoutProjectInput, VisionUncheckedCreateWithoutProjectInput> | VisionCreateWithoutProjectInput[] | VisionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutProjectInput | VisionCreateOrConnectWithoutProjectInput[]
    createMany?: VisionCreateManyProjectInputEnvelope
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
  }

  export type ProjectSettingNotificationCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSettingNotificationCreateWithoutProjectInput, ProjectSettingNotificationUncheckedCreateWithoutProjectInput> | ProjectSettingNotificationCreateWithoutProjectInput[] | ProjectSettingNotificationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingNotificationCreateOrConnectWithoutProjectInput | ProjectSettingNotificationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSettingNotificationCreateManyProjectInputEnvelope
    connect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type GridCreateNestedManyWithoutProjectInput = {
    create?: XOR<GridCreateWithoutProjectInput, GridUncheckedCreateWithoutProjectInput> | GridCreateWithoutProjectInput[] | GridUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: GridCreateOrConnectWithoutProjectInput | GridCreateOrConnectWithoutProjectInput[]
    createMany?: GridCreateManyProjectInputEnvelope
    connect?: GridWhereUniqueInput | GridWhereUniqueInput[]
  }

  export type TaskStatusCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskStatusCreateWithoutProjectInput, TaskStatusUncheckedCreateWithoutProjectInput> | TaskStatusCreateWithoutProjectInput[] | TaskStatusUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskStatusCreateOrConnectWithoutProjectInput | TaskStatusCreateOrConnectWithoutProjectInput[]
    createMany?: TaskStatusCreateManyProjectInputEnvelope
    connect?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
  }

  export type TaskPointCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskPointCreateWithoutProjectInput, TaskPointUncheckedCreateWithoutProjectInput> | TaskPointCreateWithoutProjectInput[] | TaskPointUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskPointCreateOrConnectWithoutProjectInput | TaskPointCreateOrConnectWithoutProjectInput[]
    createMany?: TaskPointCreateManyProjectInputEnvelope
    connect?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutProjectInput = {
    create?: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput> | TagCreateWithoutProjectInput[] | TagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProjectInput | TagCreateOrConnectWithoutProjectInput[]
    createMany?: TagCreateManyProjectInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TaskAutomationCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskAutomationCreateWithoutProjectInput, TaskAutomationUncheckedCreateWithoutProjectInput> | TaskAutomationCreateWithoutProjectInput[] | TaskAutomationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskAutomationCreateOrConnectWithoutProjectInput | TaskAutomationCreateOrConnectWithoutProjectInput[]
    createMany?: TaskAutomationCreateManyProjectInputEnvelope
    connect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
  }

  export type SchedulerCreateNestedManyWithoutProjectInput = {
    create?: XOR<SchedulerCreateWithoutProjectInput, SchedulerUncheckedCreateWithoutProjectInput> | SchedulerCreateWithoutProjectInput[] | SchedulerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SchedulerCreateOrConnectWithoutProjectInput | SchedulerCreateOrConnectWithoutProjectInput[]
    createMany?: SchedulerCreateManyProjectInputEnvelope
    connect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
  }

  export type FileStorageCreateNestedManyWithoutProjectInput = {
    create?: XOR<FileStorageCreateWithoutProjectInput, FileStorageUncheckedCreateWithoutProjectInput> | FileStorageCreateWithoutProjectInput[] | FileStorageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutProjectInput | FileStorageCreateOrConnectWithoutProjectInput[]
    createMany?: FileStorageCreateManyProjectInputEnvelope
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
  }

  export type StatCreateNestedManyWithoutProjectInput = {
    create?: XOR<StatCreateWithoutProjectInput, StatUncheckedCreateWithoutProjectInput> | StatCreateWithoutProjectInput[] | StatUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StatCreateOrConnectWithoutProjectInput | StatCreateOrConnectWithoutProjectInput[]
    createMany?: StatCreateManyProjectInputEnvelope
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutProjectInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type DashboardCreateNestedManyWithoutProjectInput = {
    create?: XOR<DashboardCreateWithoutProjectInput, DashboardUncheckedCreateWithoutProjectInput> | DashboardCreateWithoutProjectInput[] | DashboardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DashboardCreateOrConnectWithoutProjectInput | DashboardCreateOrConnectWithoutProjectInput[]
    createMany?: DashboardCreateManyProjectInputEnvelope
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutProjectsInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectViewUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<ProjectViewCreateWithoutProjectInput, ProjectViewUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectViewCreateOrConnectWithoutProjectInput
    connect?: ProjectViewWhereUniqueInput
  }

  export type FieldUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FieldCreateWithoutProjectInput, FieldUncheckedCreateWithoutProjectInput> | FieldCreateWithoutProjectInput[] | FieldUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutProjectInput | FieldCreateOrConnectWithoutProjectInput[]
    createMany?: FieldCreateManyProjectInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type VisionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<VisionCreateWithoutProjectInput, VisionUncheckedCreateWithoutProjectInput> | VisionCreateWithoutProjectInput[] | VisionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutProjectInput | VisionCreateOrConnectWithoutProjectInput[]
    createMany?: VisionCreateManyProjectInputEnvelope
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
  }

  export type ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSettingNotificationCreateWithoutProjectInput, ProjectSettingNotificationUncheckedCreateWithoutProjectInput> | ProjectSettingNotificationCreateWithoutProjectInput[] | ProjectSettingNotificationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingNotificationCreateOrConnectWithoutProjectInput | ProjectSettingNotificationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSettingNotificationCreateManyProjectInputEnvelope
    connect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type GridUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<GridCreateWithoutProjectInput, GridUncheckedCreateWithoutProjectInput> | GridCreateWithoutProjectInput[] | GridUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: GridCreateOrConnectWithoutProjectInput | GridCreateOrConnectWithoutProjectInput[]
    createMany?: GridCreateManyProjectInputEnvelope
    connect?: GridWhereUniqueInput | GridWhereUniqueInput[]
  }

  export type TaskStatusUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskStatusCreateWithoutProjectInput, TaskStatusUncheckedCreateWithoutProjectInput> | TaskStatusCreateWithoutProjectInput[] | TaskStatusUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskStatusCreateOrConnectWithoutProjectInput | TaskStatusCreateOrConnectWithoutProjectInput[]
    createMany?: TaskStatusCreateManyProjectInputEnvelope
    connect?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
  }

  export type TaskPointUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskPointCreateWithoutProjectInput, TaskPointUncheckedCreateWithoutProjectInput> | TaskPointCreateWithoutProjectInput[] | TaskPointUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskPointCreateOrConnectWithoutProjectInput | TaskPointCreateOrConnectWithoutProjectInput[]
    createMany?: TaskPointCreateManyProjectInputEnvelope
    connect?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput> | TagCreateWithoutProjectInput[] | TagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProjectInput | TagCreateOrConnectWithoutProjectInput[]
    createMany?: TagCreateManyProjectInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TaskAutomationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskAutomationCreateWithoutProjectInput, TaskAutomationUncheckedCreateWithoutProjectInput> | TaskAutomationCreateWithoutProjectInput[] | TaskAutomationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskAutomationCreateOrConnectWithoutProjectInput | TaskAutomationCreateOrConnectWithoutProjectInput[]
    createMany?: TaskAutomationCreateManyProjectInputEnvelope
    connect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
  }

  export type SchedulerUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SchedulerCreateWithoutProjectInput, SchedulerUncheckedCreateWithoutProjectInput> | SchedulerCreateWithoutProjectInput[] | SchedulerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SchedulerCreateOrConnectWithoutProjectInput | SchedulerCreateOrConnectWithoutProjectInput[]
    createMany?: SchedulerCreateManyProjectInputEnvelope
    connect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
  }

  export type FileStorageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FileStorageCreateWithoutProjectInput, FileStorageUncheckedCreateWithoutProjectInput> | FileStorageCreateWithoutProjectInput[] | FileStorageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutProjectInput | FileStorageCreateOrConnectWithoutProjectInput[]
    createMany?: FileStorageCreateManyProjectInputEnvelope
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
  }

  export type StatUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<StatCreateWithoutProjectInput, StatUncheckedCreateWithoutProjectInput> | StatCreateWithoutProjectInput[] | StatUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StatCreateOrConnectWithoutProjectInput | StatCreateOrConnectWithoutProjectInput[]
    createMany?: StatCreateManyProjectInputEnvelope
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type DashboardUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DashboardCreateWithoutProjectInput, DashboardUncheckedCreateWithoutProjectInput> | DashboardCreateWithoutProjectInput[] | DashboardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DashboardCreateOrConnectWithoutProjectInput | DashboardCreateOrConnectWithoutProjectInput[]
    createMany?: DashboardCreateManyProjectInputEnvelope
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProjectViewUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ProjectViewCreateWithoutProjectInput, ProjectViewUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectViewCreateOrConnectWithoutProjectInput
    upsert?: ProjectViewUpsertWithoutProjectInput
    disconnect?: ProjectViewWhereInput | boolean
    delete?: ProjectViewWhereInput | boolean
    connect?: ProjectViewWhereUniqueInput
    update?: XOR<XOR<ProjectViewUpdateToOneWithWhereWithoutProjectInput, ProjectViewUpdateWithoutProjectInput>, ProjectViewUncheckedUpdateWithoutProjectInput>
  }

  export type FieldUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FieldCreateWithoutProjectInput, FieldUncheckedCreateWithoutProjectInput> | FieldCreateWithoutProjectInput[] | FieldUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutProjectInput | FieldCreateOrConnectWithoutProjectInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutProjectInput | FieldUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FieldCreateManyProjectInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutProjectInput | FieldUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutProjectInput | FieldUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type VisionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<VisionCreateWithoutProjectInput, VisionUncheckedCreateWithoutProjectInput> | VisionCreateWithoutProjectInput[] | VisionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutProjectInput | VisionCreateOrConnectWithoutProjectInput[]
    upsert?: VisionUpsertWithWhereUniqueWithoutProjectInput | VisionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: VisionCreateManyProjectInputEnvelope
    set?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    disconnect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    delete?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    update?: VisionUpdateWithWhereUniqueWithoutProjectInput | VisionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: VisionUpdateManyWithWhereWithoutProjectInput | VisionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: VisionScalarWhereInput | VisionScalarWhereInput[]
  }

  export type ProjectSettingNotificationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSettingNotificationCreateWithoutProjectInput, ProjectSettingNotificationUncheckedCreateWithoutProjectInput> | ProjectSettingNotificationCreateWithoutProjectInput[] | ProjectSettingNotificationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingNotificationCreateOrConnectWithoutProjectInput | ProjectSettingNotificationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSettingNotificationUpsertWithWhereUniqueWithoutProjectInput | ProjectSettingNotificationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSettingNotificationCreateManyProjectInputEnvelope
    set?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    disconnect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    delete?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    connect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    update?: ProjectSettingNotificationUpdateWithWhereUniqueWithoutProjectInput | ProjectSettingNotificationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSettingNotificationUpdateManyWithWhereWithoutProjectInput | ProjectSettingNotificationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSettingNotificationScalarWhereInput | ProjectSettingNotificationScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutProjectInput | MemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutProjectInput | MemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutProjectInput | MemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type GridUpdateManyWithoutProjectNestedInput = {
    create?: XOR<GridCreateWithoutProjectInput, GridUncheckedCreateWithoutProjectInput> | GridCreateWithoutProjectInput[] | GridUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: GridCreateOrConnectWithoutProjectInput | GridCreateOrConnectWithoutProjectInput[]
    upsert?: GridUpsertWithWhereUniqueWithoutProjectInput | GridUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: GridCreateManyProjectInputEnvelope
    set?: GridWhereUniqueInput | GridWhereUniqueInput[]
    disconnect?: GridWhereUniqueInput | GridWhereUniqueInput[]
    delete?: GridWhereUniqueInput | GridWhereUniqueInput[]
    connect?: GridWhereUniqueInput | GridWhereUniqueInput[]
    update?: GridUpdateWithWhereUniqueWithoutProjectInput | GridUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: GridUpdateManyWithWhereWithoutProjectInput | GridUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: GridScalarWhereInput | GridScalarWhereInput[]
  }

  export type TaskStatusUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskStatusCreateWithoutProjectInput, TaskStatusUncheckedCreateWithoutProjectInput> | TaskStatusCreateWithoutProjectInput[] | TaskStatusUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskStatusCreateOrConnectWithoutProjectInput | TaskStatusCreateOrConnectWithoutProjectInput[]
    upsert?: TaskStatusUpsertWithWhereUniqueWithoutProjectInput | TaskStatusUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskStatusCreateManyProjectInputEnvelope
    set?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
    disconnect?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
    delete?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
    connect?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
    update?: TaskStatusUpdateWithWhereUniqueWithoutProjectInput | TaskStatusUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskStatusUpdateManyWithWhereWithoutProjectInput | TaskStatusUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskStatusScalarWhereInput | TaskStatusScalarWhereInput[]
  }

  export type TaskPointUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskPointCreateWithoutProjectInput, TaskPointUncheckedCreateWithoutProjectInput> | TaskPointCreateWithoutProjectInput[] | TaskPointUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskPointCreateOrConnectWithoutProjectInput | TaskPointCreateOrConnectWithoutProjectInput[]
    upsert?: TaskPointUpsertWithWhereUniqueWithoutProjectInput | TaskPointUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskPointCreateManyProjectInputEnvelope
    set?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
    disconnect?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
    delete?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
    connect?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
    update?: TaskPointUpdateWithWhereUniqueWithoutProjectInput | TaskPointUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskPointUpdateManyWithWhereWithoutProjectInput | TaskPointUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskPointScalarWhereInput | TaskPointScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TagUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput> | TagCreateWithoutProjectInput[] | TagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProjectInput | TagCreateOrConnectWithoutProjectInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutProjectInput | TagUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TagCreateManyProjectInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutProjectInput | TagUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TagUpdateManyWithWhereWithoutProjectInput | TagUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TaskAutomationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskAutomationCreateWithoutProjectInput, TaskAutomationUncheckedCreateWithoutProjectInput> | TaskAutomationCreateWithoutProjectInput[] | TaskAutomationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskAutomationCreateOrConnectWithoutProjectInput | TaskAutomationCreateOrConnectWithoutProjectInput[]
    upsert?: TaskAutomationUpsertWithWhereUniqueWithoutProjectInput | TaskAutomationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskAutomationCreateManyProjectInputEnvelope
    set?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    disconnect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    delete?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    connect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    update?: TaskAutomationUpdateWithWhereUniqueWithoutProjectInput | TaskAutomationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskAutomationUpdateManyWithWhereWithoutProjectInput | TaskAutomationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskAutomationScalarWhereInput | TaskAutomationScalarWhereInput[]
  }

  export type SchedulerUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SchedulerCreateWithoutProjectInput, SchedulerUncheckedCreateWithoutProjectInput> | SchedulerCreateWithoutProjectInput[] | SchedulerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SchedulerCreateOrConnectWithoutProjectInput | SchedulerCreateOrConnectWithoutProjectInput[]
    upsert?: SchedulerUpsertWithWhereUniqueWithoutProjectInput | SchedulerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SchedulerCreateManyProjectInputEnvelope
    set?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    disconnect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    delete?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    connect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    update?: SchedulerUpdateWithWhereUniqueWithoutProjectInput | SchedulerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SchedulerUpdateManyWithWhereWithoutProjectInput | SchedulerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SchedulerScalarWhereInput | SchedulerScalarWhereInput[]
  }

  export type FileStorageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FileStorageCreateWithoutProjectInput, FileStorageUncheckedCreateWithoutProjectInput> | FileStorageCreateWithoutProjectInput[] | FileStorageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutProjectInput | FileStorageCreateOrConnectWithoutProjectInput[]
    upsert?: FileStorageUpsertWithWhereUniqueWithoutProjectInput | FileStorageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FileStorageCreateManyProjectInputEnvelope
    set?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    disconnect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    delete?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    update?: FileStorageUpdateWithWhereUniqueWithoutProjectInput | FileStorageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FileStorageUpdateManyWithWhereWithoutProjectInput | FileStorageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
  }

  export type StatUpdateManyWithoutProjectNestedInput = {
    create?: XOR<StatCreateWithoutProjectInput, StatUncheckedCreateWithoutProjectInput> | StatCreateWithoutProjectInput[] | StatUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StatCreateOrConnectWithoutProjectInput | StatCreateOrConnectWithoutProjectInput[]
    upsert?: StatUpsertWithWhereUniqueWithoutProjectInput | StatUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: StatCreateManyProjectInputEnvelope
    set?: StatWhereUniqueInput | StatWhereUniqueInput[]
    disconnect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    delete?: StatWhereUniqueInput | StatWhereUniqueInput[]
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    update?: StatUpdateWithWhereUniqueWithoutProjectInput | StatUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: StatUpdateManyWithWhereWithoutProjectInput | StatUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: StatScalarWhereInput | StatScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProjectInput | CommentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProjectInput | CommentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProjectInput | CommentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type DashboardUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DashboardCreateWithoutProjectInput, DashboardUncheckedCreateWithoutProjectInput> | DashboardCreateWithoutProjectInput[] | DashboardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DashboardCreateOrConnectWithoutProjectInput | DashboardCreateOrConnectWithoutProjectInput[]
    upsert?: DashboardUpsertWithWhereUniqueWithoutProjectInput | DashboardUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DashboardCreateManyProjectInputEnvelope
    set?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    disconnect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    delete?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    update?: DashboardUpdateWithWhereUniqueWithoutProjectInput | DashboardUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DashboardUpdateManyWithWhereWithoutProjectInput | DashboardUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DashboardScalarWhereInput | DashboardScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    upsert?: OrganizationUpsertWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProjectsInput, OrganizationUpdateWithoutProjectsInput>, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectViewUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ProjectViewCreateWithoutProjectInput, ProjectViewUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectViewCreateOrConnectWithoutProjectInput
    upsert?: ProjectViewUpsertWithoutProjectInput
    disconnect?: ProjectViewWhereInput | boolean
    delete?: ProjectViewWhereInput | boolean
    connect?: ProjectViewWhereUniqueInput
    update?: XOR<XOR<ProjectViewUpdateToOneWithWhereWithoutProjectInput, ProjectViewUpdateWithoutProjectInput>, ProjectViewUncheckedUpdateWithoutProjectInput>
  }

  export type FieldUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FieldCreateWithoutProjectInput, FieldUncheckedCreateWithoutProjectInput> | FieldCreateWithoutProjectInput[] | FieldUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutProjectInput | FieldCreateOrConnectWithoutProjectInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutProjectInput | FieldUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FieldCreateManyProjectInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutProjectInput | FieldUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutProjectInput | FieldUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type VisionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<VisionCreateWithoutProjectInput, VisionUncheckedCreateWithoutProjectInput> | VisionCreateWithoutProjectInput[] | VisionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutProjectInput | VisionCreateOrConnectWithoutProjectInput[]
    upsert?: VisionUpsertWithWhereUniqueWithoutProjectInput | VisionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: VisionCreateManyProjectInputEnvelope
    set?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    disconnect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    delete?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    update?: VisionUpdateWithWhereUniqueWithoutProjectInput | VisionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: VisionUpdateManyWithWhereWithoutProjectInput | VisionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: VisionScalarWhereInput | VisionScalarWhereInput[]
  }

  export type ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSettingNotificationCreateWithoutProjectInput, ProjectSettingNotificationUncheckedCreateWithoutProjectInput> | ProjectSettingNotificationCreateWithoutProjectInput[] | ProjectSettingNotificationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingNotificationCreateOrConnectWithoutProjectInput | ProjectSettingNotificationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSettingNotificationUpsertWithWhereUniqueWithoutProjectInput | ProjectSettingNotificationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSettingNotificationCreateManyProjectInputEnvelope
    set?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    disconnect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    delete?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    connect?: ProjectSettingNotificationWhereUniqueInput | ProjectSettingNotificationWhereUniqueInput[]
    update?: ProjectSettingNotificationUpdateWithWhereUniqueWithoutProjectInput | ProjectSettingNotificationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSettingNotificationUpdateManyWithWhereWithoutProjectInput | ProjectSettingNotificationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSettingNotificationScalarWhereInput | ProjectSettingNotificationScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutProjectInput | MemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutProjectInput | MemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutProjectInput | MemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type GridUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<GridCreateWithoutProjectInput, GridUncheckedCreateWithoutProjectInput> | GridCreateWithoutProjectInput[] | GridUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: GridCreateOrConnectWithoutProjectInput | GridCreateOrConnectWithoutProjectInput[]
    upsert?: GridUpsertWithWhereUniqueWithoutProjectInput | GridUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: GridCreateManyProjectInputEnvelope
    set?: GridWhereUniqueInput | GridWhereUniqueInput[]
    disconnect?: GridWhereUniqueInput | GridWhereUniqueInput[]
    delete?: GridWhereUniqueInput | GridWhereUniqueInput[]
    connect?: GridWhereUniqueInput | GridWhereUniqueInput[]
    update?: GridUpdateWithWhereUniqueWithoutProjectInput | GridUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: GridUpdateManyWithWhereWithoutProjectInput | GridUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: GridScalarWhereInput | GridScalarWhereInput[]
  }

  export type TaskStatusUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskStatusCreateWithoutProjectInput, TaskStatusUncheckedCreateWithoutProjectInput> | TaskStatusCreateWithoutProjectInput[] | TaskStatusUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskStatusCreateOrConnectWithoutProjectInput | TaskStatusCreateOrConnectWithoutProjectInput[]
    upsert?: TaskStatusUpsertWithWhereUniqueWithoutProjectInput | TaskStatusUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskStatusCreateManyProjectInputEnvelope
    set?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
    disconnect?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
    delete?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
    connect?: TaskStatusWhereUniqueInput | TaskStatusWhereUniqueInput[]
    update?: TaskStatusUpdateWithWhereUniqueWithoutProjectInput | TaskStatusUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskStatusUpdateManyWithWhereWithoutProjectInput | TaskStatusUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskStatusScalarWhereInput | TaskStatusScalarWhereInput[]
  }

  export type TaskPointUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskPointCreateWithoutProjectInput, TaskPointUncheckedCreateWithoutProjectInput> | TaskPointCreateWithoutProjectInput[] | TaskPointUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskPointCreateOrConnectWithoutProjectInput | TaskPointCreateOrConnectWithoutProjectInput[]
    upsert?: TaskPointUpsertWithWhereUniqueWithoutProjectInput | TaskPointUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskPointCreateManyProjectInputEnvelope
    set?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
    disconnect?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
    delete?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
    connect?: TaskPointWhereUniqueInput | TaskPointWhereUniqueInput[]
    update?: TaskPointUpdateWithWhereUniqueWithoutProjectInput | TaskPointUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskPointUpdateManyWithWhereWithoutProjectInput | TaskPointUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskPointScalarWhereInput | TaskPointScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput> | TagCreateWithoutProjectInput[] | TagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProjectInput | TagCreateOrConnectWithoutProjectInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutProjectInput | TagUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TagCreateManyProjectInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutProjectInput | TagUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TagUpdateManyWithWhereWithoutProjectInput | TagUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskAutomationCreateWithoutProjectInput, TaskAutomationUncheckedCreateWithoutProjectInput> | TaskAutomationCreateWithoutProjectInput[] | TaskAutomationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskAutomationCreateOrConnectWithoutProjectInput | TaskAutomationCreateOrConnectWithoutProjectInput[]
    upsert?: TaskAutomationUpsertWithWhereUniqueWithoutProjectInput | TaskAutomationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskAutomationCreateManyProjectInputEnvelope
    set?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    disconnect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    delete?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    connect?: TaskAutomationWhereUniqueInput | TaskAutomationWhereUniqueInput[]
    update?: TaskAutomationUpdateWithWhereUniqueWithoutProjectInput | TaskAutomationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskAutomationUpdateManyWithWhereWithoutProjectInput | TaskAutomationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskAutomationScalarWhereInput | TaskAutomationScalarWhereInput[]
  }

  export type SchedulerUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SchedulerCreateWithoutProjectInput, SchedulerUncheckedCreateWithoutProjectInput> | SchedulerCreateWithoutProjectInput[] | SchedulerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SchedulerCreateOrConnectWithoutProjectInput | SchedulerCreateOrConnectWithoutProjectInput[]
    upsert?: SchedulerUpsertWithWhereUniqueWithoutProjectInput | SchedulerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SchedulerCreateManyProjectInputEnvelope
    set?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    disconnect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    delete?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    connect?: SchedulerWhereUniqueInput | SchedulerWhereUniqueInput[]
    update?: SchedulerUpdateWithWhereUniqueWithoutProjectInput | SchedulerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SchedulerUpdateManyWithWhereWithoutProjectInput | SchedulerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SchedulerScalarWhereInput | SchedulerScalarWhereInput[]
  }

  export type FileStorageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FileStorageCreateWithoutProjectInput, FileStorageUncheckedCreateWithoutProjectInput> | FileStorageCreateWithoutProjectInput[] | FileStorageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutProjectInput | FileStorageCreateOrConnectWithoutProjectInput[]
    upsert?: FileStorageUpsertWithWhereUniqueWithoutProjectInput | FileStorageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FileStorageCreateManyProjectInputEnvelope
    set?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    disconnect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    delete?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    update?: FileStorageUpdateWithWhereUniqueWithoutProjectInput | FileStorageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FileStorageUpdateManyWithWhereWithoutProjectInput | FileStorageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
  }

  export type StatUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<StatCreateWithoutProjectInput, StatUncheckedCreateWithoutProjectInput> | StatCreateWithoutProjectInput[] | StatUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StatCreateOrConnectWithoutProjectInput | StatCreateOrConnectWithoutProjectInput[]
    upsert?: StatUpsertWithWhereUniqueWithoutProjectInput | StatUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: StatCreateManyProjectInputEnvelope
    set?: StatWhereUniqueInput | StatWhereUniqueInput[]
    disconnect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    delete?: StatWhereUniqueInput | StatWhereUniqueInput[]
    connect?: StatWhereUniqueInput | StatWhereUniqueInput[]
    update?: StatUpdateWithWhereUniqueWithoutProjectInput | StatUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: StatUpdateManyWithWhereWithoutProjectInput | StatUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: StatScalarWhereInput | StatScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProjectInput | CommentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProjectInput | CommentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProjectInput | CommentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type DashboardUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DashboardCreateWithoutProjectInput, DashboardUncheckedCreateWithoutProjectInput> | DashboardCreateWithoutProjectInput[] | DashboardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DashboardCreateOrConnectWithoutProjectInput | DashboardCreateOrConnectWithoutProjectInput[]
    upsert?: DashboardUpsertWithWhereUniqueWithoutProjectInput | DashboardUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DashboardCreateManyProjectInputEnvelope
    set?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    disconnect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    delete?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    update?: DashboardUpdateWithWhereUniqueWithoutProjectInput | DashboardUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DashboardUpdateManyWithWhereWithoutProjectInput | DashboardUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DashboardScalarWhereInput | DashboardScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutProjectViewInput = {
    create?: XOR<ProjectCreateWithoutProjectViewInput, ProjectUncheckedCreateWithoutProjectViewInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectViewInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumProjectViewTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProjectViewType
  }

  export type ProjectUpdateOneWithoutProjectViewNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectViewInput, ProjectUncheckedCreateWithoutProjectViewInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectViewInput
    upsert?: ProjectUpsertWithoutProjectViewInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectViewInput, ProjectUpdateWithoutProjectViewInput>, ProjectUncheckedUpdateWithoutProjectViewInput>
  }

  export type UserCreateNestedOneWithoutProjectSettingNotificationsInput = {
    create?: XOR<UserCreateWithoutProjectSettingNotificationsInput, UserUncheckedCreateWithoutProjectSettingNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectSettingNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutProjectSettingNotificationsInput = {
    create?: XOR<ProjectCreateWithoutProjectSettingNotificationsInput, ProjectUncheckedCreateWithoutProjectSettingNotificationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectSettingNotificationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProjectSettingNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutProjectSettingNotificationsInput, UserUncheckedCreateWithoutProjectSettingNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectSettingNotificationsInput
    upsert?: UserUpsertWithoutProjectSettingNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectSettingNotificationsInput, UserUpdateWithoutProjectSettingNotificationsInput>, UserUncheckedUpdateWithoutProjectSettingNotificationsInput>
  }

  export type ProjectUpdateOneRequiredWithoutProjectSettingNotificationsNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectSettingNotificationsInput, ProjectUncheckedCreateWithoutProjectSettingNotificationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectSettingNotificationsInput
    upsert?: ProjectUpsertWithoutProjectSettingNotificationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectSettingNotificationsInput, ProjectUpdateWithoutProjectSettingNotificationsInput>, ProjectUncheckedUpdateWithoutProjectSettingNotificationsInput>
  }

  export type TaskChecklistCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskChecklistCreateWithoutTaskInput, TaskChecklistUncheckedCreateWithoutTaskInput> | TaskChecklistCreateWithoutTaskInput[] | TaskChecklistUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskChecklistCreateOrConnectWithoutTaskInput | TaskChecklistCreateOrConnectWithoutTaskInput[]
    createMany?: TaskChecklistCreateManyTaskInputEnvelope
    connect?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimerCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimerCreateWithoutTaskInput, TimerUncheckedCreateWithoutTaskInput> | TimerCreateWithoutTaskInput[] | TimerUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimerCreateOrConnectWithoutTaskInput | TimerCreateOrConnectWithoutTaskInput[]
    createMany?: TimerCreateManyTaskInputEnvelope
    connect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
  }

  export type TaskTagCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput> | TaskTagCreateWithoutTaskInput[] | TaskTagUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTaskInput | TaskTagCreateOrConnectWithoutTaskInput[]
    createMany?: TaskTagCreateManyTaskInputEnvelope
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
  }

  export type TaskAssigneeCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type FileStorageCreateNestedManyWithoutTaskInput = {
    create?: XOR<FileStorageCreateWithoutTaskInput, FileStorageUncheckedCreateWithoutTaskInput> | FileStorageCreateWithoutTaskInput[] | FileStorageUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutTaskInput | FileStorageCreateOrConnectWithoutTaskInput[]
    createMany?: FileStorageCreateManyTaskInputEnvelope
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
  }

  export type TaskCreateNestedOneWithoutSubTasksInput = {
    create?: XOR<TaskCreateWithoutSubTasksInput, TaskUncheckedCreateWithoutSubTasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubTasksInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutParentTaskInput = {
    create?: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput> | TaskCreateWithoutParentTaskInput[] | TaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParentTaskInput | TaskCreateOrConnectWithoutParentTaskInput[]
    createMany?: TaskCreateManyParentTaskInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskStatusCreateNestedOneWithoutTasksInput = {
    create?: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TaskStatusCreateOrConnectWithoutTasksInput
    connect?: TaskStatusWhereUniqueInput
  }

  export type TaskChecklistUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskChecklistCreateWithoutTaskInput, TaskChecklistUncheckedCreateWithoutTaskInput> | TaskChecklistCreateWithoutTaskInput[] | TaskChecklistUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskChecklistCreateOrConnectWithoutTaskInput | TaskChecklistCreateOrConnectWithoutTaskInput[]
    createMany?: TaskChecklistCreateManyTaskInputEnvelope
    connect?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimerUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimerCreateWithoutTaskInput, TimerUncheckedCreateWithoutTaskInput> | TimerCreateWithoutTaskInput[] | TimerUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimerCreateOrConnectWithoutTaskInput | TimerCreateOrConnectWithoutTaskInput[]
    createMany?: TimerCreateManyTaskInputEnvelope
    connect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
  }

  export type TaskTagUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput> | TaskTagCreateWithoutTaskInput[] | TaskTagUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTaskInput | TaskTagCreateOrConnectWithoutTaskInput[]
    createMany?: TaskTagCreateManyTaskInputEnvelope
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
  }

  export type TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type FileStorageUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<FileStorageCreateWithoutTaskInput, FileStorageUncheckedCreateWithoutTaskInput> | FileStorageCreateWithoutTaskInput[] | FileStorageUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutTaskInput | FileStorageCreateOrConnectWithoutTaskInput[]
    createMany?: FileStorageCreateManyTaskInputEnvelope
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutParentTaskInput = {
    create?: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput> | TaskCreateWithoutParentTaskInput[] | TaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParentTaskInput | TaskCreateOrConnectWithoutParentTaskInput[]
    createMany?: TaskCreateManyParentTaskInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskType | null
  }

  export type NullableEnumTaskPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TaskPriority | null
  }

  export type TaskChecklistUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskChecklistCreateWithoutTaskInput, TaskChecklistUncheckedCreateWithoutTaskInput> | TaskChecklistCreateWithoutTaskInput[] | TaskChecklistUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskChecklistCreateOrConnectWithoutTaskInput | TaskChecklistCreateOrConnectWithoutTaskInput[]
    upsert?: TaskChecklistUpsertWithWhereUniqueWithoutTaskInput | TaskChecklistUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskChecklistCreateManyTaskInputEnvelope
    set?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
    disconnect?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
    delete?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
    connect?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
    update?: TaskChecklistUpdateWithWhereUniqueWithoutTaskInput | TaskChecklistUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskChecklistUpdateManyWithWhereWithoutTaskInput | TaskChecklistUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskChecklistScalarWhereInput | TaskChecklistScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimerUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimerCreateWithoutTaskInput, TimerUncheckedCreateWithoutTaskInput> | TimerCreateWithoutTaskInput[] | TimerUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimerCreateOrConnectWithoutTaskInput | TimerCreateOrConnectWithoutTaskInput[]
    upsert?: TimerUpsertWithWhereUniqueWithoutTaskInput | TimerUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimerCreateManyTaskInputEnvelope
    set?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    disconnect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    delete?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    connect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    update?: TimerUpdateWithWhereUniqueWithoutTaskInput | TimerUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimerUpdateManyWithWhereWithoutTaskInput | TimerUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimerScalarWhereInput | TimerScalarWhereInput[]
  }

  export type TaskTagUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput> | TaskTagCreateWithoutTaskInput[] | TaskTagUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTaskInput | TaskTagCreateOrConnectWithoutTaskInput[]
    upsert?: TaskTagUpsertWithWhereUniqueWithoutTaskInput | TaskTagUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskTagCreateManyTaskInputEnvelope
    set?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    disconnect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    delete?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    update?: TaskTagUpdateWithWhereUniqueWithoutTaskInput | TaskTagUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskTagUpdateManyWithWhereWithoutTaskInput | TaskTagUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
  }

  export type TaskAssigneeUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutTaskInput | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type FileStorageUpdateManyWithoutTaskNestedInput = {
    create?: XOR<FileStorageCreateWithoutTaskInput, FileStorageUncheckedCreateWithoutTaskInput> | FileStorageCreateWithoutTaskInput[] | FileStorageUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutTaskInput | FileStorageCreateOrConnectWithoutTaskInput[]
    upsert?: FileStorageUpsertWithWhereUniqueWithoutTaskInput | FileStorageUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: FileStorageCreateManyTaskInputEnvelope
    set?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    disconnect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    delete?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    update?: FileStorageUpdateWithWhereUniqueWithoutTaskInput | FileStorageUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: FileStorageUpdateManyWithWhereWithoutTaskInput | FileStorageUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
  }

  export type TaskUpdateOneWithoutSubTasksNestedInput = {
    create?: XOR<TaskCreateWithoutSubTasksInput, TaskUncheckedCreateWithoutSubTasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubTasksInput
    upsert?: TaskUpsertWithoutSubTasksInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutSubTasksInput, TaskUpdateWithoutSubTasksInput>, TaskUncheckedUpdateWithoutSubTasksInput>
  }

  export type TaskUpdateManyWithoutParentTaskNestedInput = {
    create?: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput> | TaskCreateWithoutParentTaskInput[] | TaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParentTaskInput | TaskCreateOrConnectWithoutParentTaskInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutParentTaskInput | TaskUpsertWithWhereUniqueWithoutParentTaskInput[]
    createMany?: TaskCreateManyParentTaskInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutParentTaskInput | TaskUpdateWithWhereUniqueWithoutParentTaskInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutParentTaskInput | TaskUpdateManyWithWhereWithoutParentTaskInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type TaskStatusUpdateOneWithoutTasksNestedInput = {
    create?: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TaskStatusCreateOrConnectWithoutTasksInput
    upsert?: TaskStatusUpsertWithoutTasksInput
    disconnect?: TaskStatusWhereInput | boolean
    delete?: TaskStatusWhereInput | boolean
    connect?: TaskStatusWhereUniqueInput
    update?: XOR<XOR<TaskStatusUpdateToOneWithWhereWithoutTasksInput, TaskStatusUpdateWithoutTasksInput>, TaskStatusUncheckedUpdateWithoutTasksInput>
  }

  export type TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskChecklistCreateWithoutTaskInput, TaskChecklistUncheckedCreateWithoutTaskInput> | TaskChecklistCreateWithoutTaskInput[] | TaskChecklistUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskChecklistCreateOrConnectWithoutTaskInput | TaskChecklistCreateOrConnectWithoutTaskInput[]
    upsert?: TaskChecklistUpsertWithWhereUniqueWithoutTaskInput | TaskChecklistUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskChecklistCreateManyTaskInputEnvelope
    set?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
    disconnect?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
    delete?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
    connect?: TaskChecklistWhereUniqueInput | TaskChecklistWhereUniqueInput[]
    update?: TaskChecklistUpdateWithWhereUniqueWithoutTaskInput | TaskChecklistUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskChecklistUpdateManyWithWhereWithoutTaskInput | TaskChecklistUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskChecklistScalarWhereInput | TaskChecklistScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimerUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimerCreateWithoutTaskInput, TimerUncheckedCreateWithoutTaskInput> | TimerCreateWithoutTaskInput[] | TimerUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimerCreateOrConnectWithoutTaskInput | TimerCreateOrConnectWithoutTaskInput[]
    upsert?: TimerUpsertWithWhereUniqueWithoutTaskInput | TimerUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimerCreateManyTaskInputEnvelope
    set?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    disconnect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    delete?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    connect?: TimerWhereUniqueInput | TimerWhereUniqueInput[]
    update?: TimerUpdateWithWhereUniqueWithoutTaskInput | TimerUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimerUpdateManyWithWhereWithoutTaskInput | TimerUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimerScalarWhereInput | TimerScalarWhereInput[]
  }

  export type TaskTagUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput> | TaskTagCreateWithoutTaskInput[] | TaskTagUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTaskInput | TaskTagCreateOrConnectWithoutTaskInput[]
    upsert?: TaskTagUpsertWithWhereUniqueWithoutTaskInput | TaskTagUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskTagCreateManyTaskInputEnvelope
    set?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    disconnect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    delete?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    update?: TaskTagUpdateWithWhereUniqueWithoutTaskInput | TaskTagUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskTagUpdateManyWithWhereWithoutTaskInput | TaskTagUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutTaskInput | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type FileStorageUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<FileStorageCreateWithoutTaskInput, FileStorageUncheckedCreateWithoutTaskInput> | FileStorageCreateWithoutTaskInput[] | FileStorageUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: FileStorageCreateOrConnectWithoutTaskInput | FileStorageCreateOrConnectWithoutTaskInput[]
    upsert?: FileStorageUpsertWithWhereUniqueWithoutTaskInput | FileStorageUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: FileStorageCreateManyTaskInputEnvelope
    set?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    disconnect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    delete?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    connect?: FileStorageWhereUniqueInput | FileStorageWhereUniqueInput[]
    update?: FileStorageUpdateWithWhereUniqueWithoutTaskInput | FileStorageUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: FileStorageUpdateManyWithWhereWithoutTaskInput | FileStorageUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutParentTaskNestedInput = {
    create?: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput> | TaskCreateWithoutParentTaskInput[] | TaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParentTaskInput | TaskCreateOrConnectWithoutParentTaskInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutParentTaskInput | TaskUpsertWithWhereUniqueWithoutParentTaskInput[]
    createMany?: TaskCreateManyParentTaskInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutParentTaskInput | TaskUpdateWithWhereUniqueWithoutParentTaskInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutParentTaskInput | TaskUpdateManyWithWhereWithoutParentTaskInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskCreateNestedManyWithoutTaskStatusInput = {
    create?: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput> | TaskCreateWithoutTaskStatusInput[] | TaskUncheckedCreateWithoutTaskStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTaskStatusInput | TaskCreateOrConnectWithoutTaskStatusInput[]
    createMany?: TaskCreateManyTaskStatusInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutTaskStatusesInput = {
    create?: XOR<ProjectCreateWithoutTaskStatusesInput, ProjectUncheckedCreateWithoutTaskStatusesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTaskStatusesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskUncheckedCreateNestedManyWithoutTaskStatusInput = {
    create?: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput> | TaskCreateWithoutTaskStatusInput[] | TaskUncheckedCreateWithoutTaskStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTaskStatusInput | TaskCreateOrConnectWithoutTaskStatusInput[]
    createMany?: TaskCreateManyTaskStatusInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EnumStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.StatusType
  }

  export type TaskUpdateManyWithoutTaskStatusNestedInput = {
    create?: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput> | TaskCreateWithoutTaskStatusInput[] | TaskUncheckedCreateWithoutTaskStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTaskStatusInput | TaskCreateOrConnectWithoutTaskStatusInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTaskStatusInput | TaskUpsertWithWhereUniqueWithoutTaskStatusInput[]
    createMany?: TaskCreateManyTaskStatusInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTaskStatusInput | TaskUpdateWithWhereUniqueWithoutTaskStatusInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTaskStatusInput | TaskUpdateManyWithWhereWithoutTaskStatusInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTaskStatusesNestedInput = {
    create?: XOR<ProjectCreateWithoutTaskStatusesInput, ProjectUncheckedCreateWithoutTaskStatusesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTaskStatusesInput
    upsert?: ProjectUpsertWithoutTaskStatusesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTaskStatusesInput, ProjectUpdateWithoutTaskStatusesInput>, ProjectUncheckedUpdateWithoutTaskStatusesInput>
  }

  export type TaskUncheckedUpdateManyWithoutTaskStatusNestedInput = {
    create?: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput> | TaskCreateWithoutTaskStatusInput[] | TaskUncheckedCreateWithoutTaskStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTaskStatusInput | TaskCreateOrConnectWithoutTaskStatusInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTaskStatusInput | TaskUpsertWithWhereUniqueWithoutTaskStatusInput[]
    createMany?: TaskCreateManyTaskStatusInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTaskStatusInput | TaskUpdateWithWhereUniqueWithoutTaskStatusInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTaskStatusInput | TaskUpdateManyWithWhereWithoutTaskStatusInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutTaskAssigneesInput = {
    create?: XOR<TaskCreateWithoutTaskAssigneesInput, TaskUncheckedCreateWithoutTaskAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskAssigneesInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskAssigneesInput = {
    create?: XOR<UserCreateWithoutTaskAssigneesInput, UserUncheckedCreateWithoutTaskAssigneesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssigneesInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTaskAssigneesNestedInput = {
    create?: XOR<TaskCreateWithoutTaskAssigneesInput, TaskUncheckedCreateWithoutTaskAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskAssigneesInput
    upsert?: TaskUpsertWithoutTaskAssigneesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTaskAssigneesInput, TaskUpdateWithoutTaskAssigneesInput>, TaskUncheckedUpdateWithoutTaskAssigneesInput>
  }

  export type UserUpdateOneRequiredWithoutTaskAssigneesNestedInput = {
    create?: XOR<UserCreateWithoutTaskAssigneesInput, UserUncheckedCreateWithoutTaskAssigneesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskAssigneesInput
    upsert?: UserUpsertWithoutTaskAssigneesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskAssigneesInput, UserUpdateWithoutTaskAssigneesInput>, UserUncheckedUpdateWithoutTaskAssigneesInput>
  }

  export type TaskCreateNestedOneWithoutTaskChecklistsInput = {
    create?: XOR<TaskCreateWithoutTaskChecklistsInput, TaskUncheckedCreateWithoutTaskChecklistsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskChecklistsInput
    connect?: TaskWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type TaskUpdateOneRequiredWithoutTaskChecklistsNestedInput = {
    create?: XOR<TaskCreateWithoutTaskChecklistsInput, TaskUncheckedCreateWithoutTaskChecklistsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskChecklistsInput
    upsert?: TaskUpsertWithoutTaskChecklistsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTaskChecklistsInput, TaskUpdateWithoutTaskChecklistsInput>, TaskUncheckedUpdateWithoutTaskChecklistsInput>
  }

  export type ProjectCreateNestedOneWithoutTaskPointsInput = {
    create?: XOR<ProjectCreateWithoutTaskPointsInput, ProjectUncheckedCreateWithoutTaskPointsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTaskPointsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutTaskPointsNestedInput = {
    create?: XOR<ProjectCreateWithoutTaskPointsInput, ProjectUncheckedCreateWithoutTaskPointsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTaskPointsInput
    upsert?: ProjectUpsertWithoutTaskPointsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTaskPointsInput, ProjectUpdateWithoutTaskPointsInput>, ProjectUncheckedUpdateWithoutTaskPointsInput>
  }

  export type OrganizationCreateNestedOneWithoutTaskAutomationsInput = {
    create?: XOR<OrganizationCreateWithoutTaskAutomationsInput, OrganizationUncheckedCreateWithoutTaskAutomationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTaskAutomationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutTaskAutomationsInput = {
    create?: XOR<ProjectCreateWithoutTaskAutomationsInput, ProjectUncheckedCreateWithoutTaskAutomationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTaskAutomationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutTaskAutomationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutTaskAutomationsInput, OrganizationUncheckedCreateWithoutTaskAutomationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTaskAutomationsInput
    upsert?: OrganizationUpsertWithoutTaskAutomationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTaskAutomationsInput, OrganizationUpdateWithoutTaskAutomationsInput>, OrganizationUncheckedUpdateWithoutTaskAutomationsInput>
  }

  export type ProjectUpdateOneRequiredWithoutTaskAutomationsNestedInput = {
    create?: XOR<ProjectCreateWithoutTaskAutomationsInput, ProjectUncheckedCreateWithoutTaskAutomationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTaskAutomationsInput
    upsert?: ProjectUpsertWithoutTaskAutomationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTaskAutomationsInput, ProjectUpdateWithoutTaskAutomationsInput>, ProjectUncheckedUpdateWithoutTaskAutomationsInput>
  }

  export type ProjectCreateNestedOneWithoutVisionInput = {
    create?: XOR<ProjectCreateWithoutVisionInput, ProjectUncheckedCreateWithoutVisionInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutVisionInput
    connect?: ProjectWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutVisionsInput = {
    create?: XOR<OrganizationCreateWithoutVisionsInput, OrganizationUncheckedCreateWithoutVisionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutVisionsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type VisionCreateNestedOneWithoutChildrenInput = {
    create?: XOR<VisionCreateWithoutChildrenInput, VisionUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: VisionCreateOrConnectWithoutChildrenInput
    connect?: VisionWhereUniqueInput
  }

  export type VisionCreateNestedManyWithoutParentInput = {
    create?: XOR<VisionCreateWithoutParentInput, VisionUncheckedCreateWithoutParentInput> | VisionCreateWithoutParentInput[] | VisionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutParentInput | VisionCreateOrConnectWithoutParentInput[]
    createMany?: VisionCreateManyParentInputEnvelope
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
  }

  export type VisionUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<VisionCreateWithoutParentInput, VisionUncheckedCreateWithoutParentInput> | VisionCreateWithoutParentInput[] | VisionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutParentInput | VisionCreateOrConnectWithoutParentInput[]
    createMany?: VisionCreateManyParentInputEnvelope
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
  }

  export type ProjectUpdateOneWithoutVisionNestedInput = {
    create?: XOR<ProjectCreateWithoutVisionInput, ProjectUncheckedCreateWithoutVisionInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutVisionInput
    upsert?: ProjectUpsertWithoutVisionInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutVisionInput, ProjectUpdateWithoutVisionInput>, ProjectUncheckedUpdateWithoutVisionInput>
  }

  export type OrganizationUpdateOneWithoutVisionsNestedInput = {
    create?: XOR<OrganizationCreateWithoutVisionsInput, OrganizationUncheckedCreateWithoutVisionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutVisionsInput
    upsert?: OrganizationUpsertWithoutVisionsInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutVisionsInput, OrganizationUpdateWithoutVisionsInput>, OrganizationUncheckedUpdateWithoutVisionsInput>
  }

  export type VisionUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<VisionCreateWithoutChildrenInput, VisionUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: VisionCreateOrConnectWithoutChildrenInput
    upsert?: VisionUpsertWithoutChildrenInput
    disconnect?: VisionWhereInput | boolean
    delete?: VisionWhereInput | boolean
    connect?: VisionWhereUniqueInput
    update?: XOR<XOR<VisionUpdateToOneWithWhereWithoutChildrenInput, VisionUpdateWithoutChildrenInput>, VisionUncheckedUpdateWithoutChildrenInput>
  }

  export type VisionUpdateManyWithoutParentNestedInput = {
    create?: XOR<VisionCreateWithoutParentInput, VisionUncheckedCreateWithoutParentInput> | VisionCreateWithoutParentInput[] | VisionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutParentInput | VisionCreateOrConnectWithoutParentInput[]
    upsert?: VisionUpsertWithWhereUniqueWithoutParentInput | VisionUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: VisionCreateManyParentInputEnvelope
    set?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    disconnect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    delete?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    update?: VisionUpdateWithWhereUniqueWithoutParentInput | VisionUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: VisionUpdateManyWithWhereWithoutParentInput | VisionUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: VisionScalarWhereInput | VisionScalarWhereInput[]
  }

  export type VisionUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<VisionCreateWithoutParentInput, VisionUncheckedCreateWithoutParentInput> | VisionCreateWithoutParentInput[] | VisionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: VisionCreateOrConnectWithoutParentInput | VisionCreateOrConnectWithoutParentInput[]
    upsert?: VisionUpsertWithWhereUniqueWithoutParentInput | VisionUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: VisionCreateManyParentInputEnvelope
    set?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    disconnect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    delete?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    connect?: VisionWhereUniqueInput | VisionWhereUniqueInput[]
    update?: VisionUpdateWithWhereUniqueWithoutParentInput | VisionUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: VisionUpdateManyWithWhereWithoutParentInput | VisionUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: VisionScalarWhereInput | VisionScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutFieldInput = {
    create?: XOR<ProjectCreateWithoutFieldInput, ProjectUncheckedCreateWithoutFieldInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFieldInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumFieldTypeFieldUpdateOperationsInput = {
    set?: $Enums.FieldType
  }

  export type ProjectUpdateOneRequiredWithoutFieldNestedInput = {
    create?: XOR<ProjectCreateWithoutFieldInput, ProjectUncheckedCreateWithoutFieldInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFieldInput
    upsert?: ProjectUpsertWithoutFieldInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutFieldInput, ProjectUpdateWithoutFieldInput>, ProjectUncheckedUpdateWithoutFieldInput>
  }

  export type ProjectCreateNestedOneWithoutGridInput = {
    create?: XOR<ProjectCreateWithoutGridInput, ProjectUncheckedCreateWithoutGridInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutGridInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutGridNestedInput = {
    create?: XOR<ProjectCreateWithoutGridInput, ProjectUncheckedCreateWithoutGridInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutGridInput
    upsert?: ProjectUpsertWithoutGridInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutGridInput, ProjectUpdateWithoutGridInput>, ProjectUncheckedUpdateWithoutGridInput>
  }

  export type TaskTagCreateNestedManyWithoutTagInput = {
    create?: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput> | TaskTagCreateWithoutTagInput[] | TaskTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTagInput | TaskTagCreateOrConnectWithoutTagInput[]
    createMany?: TaskTagCreateManyTagInputEnvelope
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutTagsInput = {
    create?: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTagsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput> | TaskTagCreateWithoutTagInput[] | TaskTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTagInput | TaskTagCreateOrConnectWithoutTagInput[]
    createMany?: TaskTagCreateManyTagInputEnvelope
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
  }

  export type TaskTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput> | TaskTagCreateWithoutTagInput[] | TaskTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTagInput | TaskTagCreateOrConnectWithoutTagInput[]
    upsert?: TaskTagUpsertWithWhereUniqueWithoutTagInput | TaskTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TaskTagCreateManyTagInputEnvelope
    set?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    disconnect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    delete?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    update?: TaskTagUpdateWithWhereUniqueWithoutTagInput | TaskTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TaskTagUpdateManyWithWhereWithoutTagInput | TaskTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTagsInput
    upsert?: ProjectUpsertWithoutTagsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTagsInput, ProjectUpdateWithoutTagsInput>, ProjectUncheckedUpdateWithoutTagsInput>
  }

  export type TaskTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput> | TaskTagCreateWithoutTagInput[] | TaskTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTagInput | TaskTagCreateOrConnectWithoutTagInput[]
    upsert?: TaskTagUpsertWithWhereUniqueWithoutTagInput | TaskTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TaskTagCreateManyTagInputEnvelope
    set?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    disconnect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    delete?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    update?: TaskTagUpdateWithWhereUniqueWithoutTagInput | TaskTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TaskTagUpdateManyWithWhereWithoutTagInput | TaskTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutTaskTagsInput = {
    create?: XOR<TaskCreateWithoutTaskTagsInput, TaskUncheckedCreateWithoutTaskTagsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskTagsInput
    connect?: TaskWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutTaskTagsInput = {
    create?: XOR<TagCreateWithoutTaskTagsInput, TagUncheckedCreateWithoutTaskTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTaskTagsInput
    connect?: TagWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTaskTagsNestedInput = {
    create?: XOR<TaskCreateWithoutTaskTagsInput, TaskUncheckedCreateWithoutTaskTagsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskTagsInput
    upsert?: TaskUpsertWithoutTaskTagsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTaskTagsInput, TaskUpdateWithoutTaskTagsInput>, TaskUncheckedUpdateWithoutTaskTagsInput>
  }

  export type TagUpdateOneRequiredWithoutTaskTagsNestedInput = {
    create?: XOR<TagCreateWithoutTaskTagsInput, TagUncheckedCreateWithoutTaskTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTaskTagsInput
    upsert?: TagUpsertWithoutTaskTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutTaskTagsInput, TagUpdateWithoutTaskTagsInput>, TagUncheckedUpdateWithoutTaskTagsInput>
  }

  export type ProjectCreateNestedOneWithoutSchedulersInput = {
    create?: XOR<ProjectCreateWithoutSchedulersInput, ProjectUncheckedCreateWithoutSchedulersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSchedulersInput
    connect?: ProjectWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutSchedulersInput = {
    create?: XOR<OrganizationCreateWithoutSchedulersInput, OrganizationUncheckedCreateWithoutSchedulersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSchedulersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutSchedulersNestedInput = {
    create?: XOR<ProjectCreateWithoutSchedulersInput, ProjectUncheckedCreateWithoutSchedulersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSchedulersInput
    upsert?: ProjectUpsertWithoutSchedulersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSchedulersInput, ProjectUpdateWithoutSchedulersInput>, ProjectUncheckedUpdateWithoutSchedulersInput>
  }

  export type OrganizationUpdateOneRequiredWithoutSchedulersNestedInput = {
    create?: XOR<OrganizationCreateWithoutSchedulersInput, OrganizationUncheckedCreateWithoutSchedulersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSchedulersInput
    upsert?: OrganizationUpsertWithoutSchedulersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSchedulersInput, OrganizationUpdateWithoutSchedulersInput>, OrganizationUncheckedUpdateWithoutSchedulersInput>
  }

  export type OrganizationCreateNestedOneWithoutFileStoragesInput = {
    create?: XOR<OrganizationCreateWithoutFileStoragesInput, OrganizationUncheckedCreateWithoutFileStoragesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFileStoragesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutFileStoragesInput = {
    create?: XOR<ProjectCreateWithoutFileStoragesInput, ProjectUncheckedCreateWithoutFileStoragesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFileStoragesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutFileStoragesInput = {
    create?: XOR<TaskCreateWithoutFileStoragesInput, TaskUncheckedCreateWithoutFileStoragesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutFileStoragesInput
    connect?: TaskWhereUniqueInput
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumFileOwnerTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileOwnerType | null
  }

  export type OrganizationUpdateOneWithoutFileStoragesNestedInput = {
    create?: XOR<OrganizationCreateWithoutFileStoragesInput, OrganizationUncheckedCreateWithoutFileStoragesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFileStoragesInput
    upsert?: OrganizationUpsertWithoutFileStoragesInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutFileStoragesInput, OrganizationUpdateWithoutFileStoragesInput>, OrganizationUncheckedUpdateWithoutFileStoragesInput>
  }

  export type ProjectUpdateOneWithoutFileStoragesNestedInput = {
    create?: XOR<ProjectCreateWithoutFileStoragesInput, ProjectUncheckedCreateWithoutFileStoragesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFileStoragesInput
    upsert?: ProjectUpsertWithoutFileStoragesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutFileStoragesInput, ProjectUpdateWithoutFileStoragesInput>, ProjectUncheckedUpdateWithoutFileStoragesInput>
  }

  export type TaskUpdateOneWithoutFileStoragesNestedInput = {
    create?: XOR<TaskCreateWithoutFileStoragesInput, TaskUncheckedCreateWithoutFileStoragesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutFileStoragesInput
    upsert?: TaskUpsertWithoutFileStoragesInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutFileStoragesInput, TaskUpdateWithoutFileStoragesInput>, TaskUncheckedUpdateWithoutFileStoragesInput>
  }

  export type UserCreateNestedOneWithoutStatsInput = {
    create?: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutStatsInput = {
    create?: XOR<ProjectCreateWithoutStatsInput, ProjectUncheckedCreateWithoutStatsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutStatsInput
    connect?: ProjectWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutStatsInput = {
    create?: XOR<OrganizationCreateWithoutStatsInput, OrganizationUncheckedCreateWithoutStatsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStatsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumStatTypeFieldUpdateOperationsInput = {
    set?: $Enums.StatType
  }

  export type UserUpdateOneWithoutStatsNestedInput = {
    create?: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatsInput
    upsert?: UserUpsertWithoutStatsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatsInput, UserUpdateWithoutStatsInput>, UserUncheckedUpdateWithoutStatsInput>
  }

  export type ProjectUpdateOneWithoutStatsNestedInput = {
    create?: XOR<ProjectCreateWithoutStatsInput, ProjectUncheckedCreateWithoutStatsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutStatsInput
    upsert?: ProjectUpsertWithoutStatsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutStatsInput, ProjectUpdateWithoutStatsInput>, ProjectUncheckedUpdateWithoutStatsInput>
  }

  export type OrganizationUpdateOneWithoutStatsNestedInput = {
    create?: XOR<OrganizationCreateWithoutStatsInput, OrganizationUncheckedCreateWithoutStatsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStatsInput
    upsert?: OrganizationUpsertWithoutStatsInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutStatsInput, OrganizationUpdateWithoutStatsInput>, OrganizationUncheckedUpdateWithoutStatsInput>
  }

  export type DashboardComponentCreateNestedManyWithoutDashboardInput = {
    create?: XOR<DashboardComponentCreateWithoutDashboardInput, DashboardComponentUncheckedCreateWithoutDashboardInput> | DashboardComponentCreateWithoutDashboardInput[] | DashboardComponentUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: DashboardComponentCreateOrConnectWithoutDashboardInput | DashboardComponentCreateOrConnectWithoutDashboardInput[]
    createMany?: DashboardComponentCreateManyDashboardInputEnvelope
    connect?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutDashboardInput = {
    create?: XOR<ProjectCreateWithoutDashboardInput, ProjectUncheckedCreateWithoutDashboardInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDashboardInput
    connect?: ProjectWhereUniqueInput
  }

  export type DashboardComponentUncheckedCreateNestedManyWithoutDashboardInput = {
    create?: XOR<DashboardComponentCreateWithoutDashboardInput, DashboardComponentUncheckedCreateWithoutDashboardInput> | DashboardComponentCreateWithoutDashboardInput[] | DashboardComponentUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: DashboardComponentCreateOrConnectWithoutDashboardInput | DashboardComponentCreateOrConnectWithoutDashboardInput[]
    createMany?: DashboardComponentCreateManyDashboardInputEnvelope
    connect?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
  }

  export type DashboardComponentUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<DashboardComponentCreateWithoutDashboardInput, DashboardComponentUncheckedCreateWithoutDashboardInput> | DashboardComponentCreateWithoutDashboardInput[] | DashboardComponentUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: DashboardComponentCreateOrConnectWithoutDashboardInput | DashboardComponentCreateOrConnectWithoutDashboardInput[]
    upsert?: DashboardComponentUpsertWithWhereUniqueWithoutDashboardInput | DashboardComponentUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: DashboardComponentCreateManyDashboardInputEnvelope
    set?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
    disconnect?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
    delete?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
    connect?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
    update?: DashboardComponentUpdateWithWhereUniqueWithoutDashboardInput | DashboardComponentUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: DashboardComponentUpdateManyWithWhereWithoutDashboardInput | DashboardComponentUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: DashboardComponentScalarWhereInput | DashboardComponentScalarWhereInput[]
  }

  export type ProjectUpdateOneWithoutDashboardNestedInput = {
    create?: XOR<ProjectCreateWithoutDashboardInput, ProjectUncheckedCreateWithoutDashboardInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDashboardInput
    upsert?: ProjectUpsertWithoutDashboardInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDashboardInput, ProjectUpdateWithoutDashboardInput>, ProjectUncheckedUpdateWithoutDashboardInput>
  }

  export type DashboardComponentUncheckedUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<DashboardComponentCreateWithoutDashboardInput, DashboardComponentUncheckedCreateWithoutDashboardInput> | DashboardComponentCreateWithoutDashboardInput[] | DashboardComponentUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: DashboardComponentCreateOrConnectWithoutDashboardInput | DashboardComponentCreateOrConnectWithoutDashboardInput[]
    upsert?: DashboardComponentUpsertWithWhereUniqueWithoutDashboardInput | DashboardComponentUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: DashboardComponentCreateManyDashboardInputEnvelope
    set?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
    disconnect?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
    delete?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
    connect?: DashboardComponentWhereUniqueInput | DashboardComponentWhereUniqueInput[]
    update?: DashboardComponentUpdateWithWhereUniqueWithoutDashboardInput | DashboardComponentUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: DashboardComponentUpdateManyWithWhereWithoutDashboardInput | DashboardComponentUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: DashboardComponentScalarWhereInput | DashboardComponentScalarWhereInput[]
  }

  export type DashboardCreateNestedOneWithoutDashboardComponentsInput = {
    create?: XOR<DashboardCreateWithoutDashboardComponentsInput, DashboardUncheckedCreateWithoutDashboardComponentsInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutDashboardComponentsInput
    connect?: DashboardWhereUniqueInput
  }

  export type NullableEnumDashboardComponentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DashboardComponentType | null
  }

  export type DashboardUpdateOneWithoutDashboardComponentsNestedInput = {
    create?: XOR<DashboardCreateWithoutDashboardComponentsInput, DashboardUncheckedCreateWithoutDashboardComponentsInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutDashboardComponentsInput
    upsert?: DashboardUpsertWithoutDashboardComponentsInput
    disconnect?: DashboardWhereInput | boolean
    delete?: DashboardWhereInput | boolean
    connect?: DashboardWhereUniqueInput
    update?: XOR<XOR<DashboardUpdateToOneWithWhereWithoutDashboardComponentsInput, DashboardUpdateWithoutDashboardComponentsInput>, DashboardUncheckedUpdateWithoutDashboardComponentsInput>
  }

  export type EnumActivityTargetTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityTargetType
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type TaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    connect?: TaskWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    upsert?: TaskUpsertWithoutCommentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCommentsInput, TaskUpdateWithoutCommentsInput>, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type ProjectUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommentsInput
    upsert?: ProjectUpsertWithoutCommentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCommentsInput, ProjectUpdateWithoutCommentsInput>, ProjectUncheckedUpdateWithoutCommentsInput>
  }

  export type ApplicationCreatescopesInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<OrganizationCreateWithoutApplicationsInput, OrganizationUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutApplicationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ApplicationUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutApplicationsInput, OrganizationUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutApplicationsInput
    upsert?: OrganizationUpsertWithoutApplicationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutApplicationsInput, OrganizationUpdateWithoutApplicationsInput>, OrganizationUncheckedUpdateWithoutApplicationsInput>
  }

  export type TaskCreateNestedOneWithoutTimersInput = {
    create?: XOR<TaskCreateWithoutTimersInput, TaskUncheckedCreateWithoutTimersInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimersInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTimersInput = {
    create?: XOR<UserCreateWithoutTimersInput, UserUncheckedCreateWithoutTimersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimersInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTimersNestedInput = {
    create?: XOR<TaskCreateWithoutTimersInput, TaskUncheckedCreateWithoutTimersInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimersInput
    upsert?: TaskUpsertWithoutTimersInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTimersInput, TaskUpdateWithoutTimersInput>, TaskUncheckedUpdateWithoutTimersInput>
  }

  export type UserUpdateOneRequiredWithoutTimersNestedInput = {
    create?: XOR<UserCreateWithoutTimersInput, UserUncheckedCreateWithoutTimersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimersInput
    upsert?: UserUpsertWithoutTimersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimersInput, UserUpdateWithoutTimersInput>, UserUncheckedUpdateWithoutTimersInput>
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<OrganizationCreateWithoutFavoritesInput, OrganizationUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFavoritesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type OrganizationUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<OrganizationCreateWithoutFavoritesInput, OrganizationUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFavoritesInput
    upsert?: OrganizationUpsertWithoutFavoritesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutFavoritesInput, OrganizationUpdateWithoutFavoritesInput>, OrganizationUncheckedUpdateWithoutFavoritesInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableFilter<$PrismaModel> | $Enums.UserStatus | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserStatusNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumOrganizationRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationRole | EnumOrganizationRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationRoleFilter<$PrismaModel> | $Enums.OrganizationRole
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrganizationRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationRole | EnumOrganizationRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrganizationRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrganizationRoleFilter<$PrismaModel>
    _max?: NestedEnumOrganizationRoleFilter<$PrismaModel>
  }

  export type NestedEnumOrgStorageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStorageType | EnumOrgStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStorageType[] | ListEnumOrgStorageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStorageType[] | ListEnumOrgStorageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStorageTypeFilter<$PrismaModel> | $Enums.OrgStorageType
  }

  export type NestedEnumOrgStorageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgStorageType | EnumOrgStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrgStorageType[] | ListEnumOrgStorageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgStorageType[] | ListEnumOrgStorageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgStorageTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrgStorageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgStorageTypeFilter<$PrismaModel>
    _max?: NestedEnumOrgStorageTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumProjectViewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectViewType | EnumProjectViewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectViewType[] | ListEnumProjectViewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectViewType[] | ListEnumProjectViewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectViewTypeFilter<$PrismaModel> | $Enums.ProjectViewType
  }

  export type NestedEnumProjectViewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectViewType | EnumProjectViewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectViewType[] | ListEnumProjectViewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectViewType[] | ListEnumProjectViewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectViewTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProjectViewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectViewTypeFilter<$PrismaModel>
    _max?: NestedEnumProjectViewTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskTypeNullableFilter<$PrismaModel> | $Enums.TaskType | null
  }

  export type NestedEnumTaskPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskPriorityNullableFilter<$PrismaModel> | $Enums.TaskPriority | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTaskTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTaskPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskPriority[] | ListEnumTaskPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeFilter<$PrismaModel> | $Enums.StatusType
  }

  export type NestedEnumStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumStatusTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumFileOwnerTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FileOwnerType | EnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FileOwnerType[] | ListEnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FileOwnerType[] | ListEnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFileOwnerTypeNullableFilter<$PrismaModel> | $Enums.FileOwnerType | null
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumFileOwnerTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileOwnerType | EnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FileOwnerType[] | ListEnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FileOwnerType[] | ListEnumFileOwnerTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFileOwnerTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FileOwnerType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFileOwnerTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFileOwnerTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatType | EnumStatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatType[] | ListEnumStatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatType[] | ListEnumStatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatTypeFilter<$PrismaModel> | $Enums.StatType
  }

  export type NestedEnumStatTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatType | EnumStatTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatType[] | ListEnumStatTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatType[] | ListEnumStatTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatTypeFilter<$PrismaModel>
    _max?: NestedEnumStatTypeFilter<$PrismaModel>
  }

  export type NestedEnumDashboardComponentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DashboardComponentType | EnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DashboardComponentType[] | ListEnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DashboardComponentType[] | ListEnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDashboardComponentTypeNullableFilter<$PrismaModel> | $Enums.DashboardComponentType | null
  }

  export type NestedEnumDashboardComponentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DashboardComponentType | EnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DashboardComponentType[] | ListEnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DashboardComponentType[] | ListEnumDashboardComponentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDashboardComponentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DashboardComponentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDashboardComponentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDashboardComponentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumActivityTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetType | EnumActivityTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTargetTypeFilter<$PrismaModel> | $Enums.ActivityTargetType
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityTargetType | EnumActivityTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityTargetType[] | ListEnumActivityTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTargetTypeFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type MemberCreateWithoutUserInput = {
    id?: string
    role: $Enums.MemberRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    id?: string
    role: $Enums.MemberRole
    projectId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: MemberCreateManyUserInput | MemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMemberCreateWithoutUserInput = {
    id?: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organization: OrganizationCreateNestedOneWithoutOrganizationMembersInput
  }

  export type OrganizationMemberUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationMemberCreateOrConnectWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberCreateManyUserInputEnvelope = {
    data: OrganizationMemberCreateManyUserInput | OrganizationMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssigneeCreateWithoutUserInput = {
    assignedAt?: Date | string
    task: TaskCreateNestedOneWithoutTaskAssigneesInput
  }

  export type TaskAssigneeUncheckedCreateWithoutUserInput = {
    taskId: string
    assignedAt?: Date | string
  }

  export type TaskAssigneeCreateOrConnectWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput
    create: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
  }

  export type TaskAssigneeCreateManyUserInputEnvelope = {
    data: TaskAssigneeCreateManyUserInput | TaskAssigneeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSettingNotificationCreateWithoutUserInput = {
    id?: string
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    project: ProjectCreateNestedOneWithoutProjectSettingNotificationsInput
  }

  export type ProjectSettingNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type ProjectSettingNotificationCreateOrConnectWithoutUserInput = {
    where: ProjectSettingNotificationWhereUniqueInput
    create: XOR<ProjectSettingNotificationCreateWithoutUserInput, ProjectSettingNotificationUncheckedCreateWithoutUserInput>
  }

  export type ProjectSettingNotificationCreateManyUserInputEnvelope = {
    data: ProjectSettingNotificationCreateManyUserInput | ProjectSettingNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StatCreateWithoutUserInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
    project?: ProjectCreateNestedOneWithoutStatsInput
    organization?: OrganizationCreateNestedOneWithoutStatsInput
  }

  export type StatUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    projectId?: string | null
    organizationId?: string | null
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
  }

  export type StatCreateOrConnectWithoutUserInput = {
    where: StatWhereUniqueInput
    create: XOR<StatCreateWithoutUserInput, StatUncheckedCreateWithoutUserInput>
  }

  export type StatCreateManyUserInputEnvelope = {
    data: StatCreateManyUserInput | StatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TimerCreateWithoutUserInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutTimersInput
  }

  export type TimerUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimerCreateOrConnectWithoutUserInput = {
    where: TimerWhereUniqueInput
    create: XOR<TimerCreateWithoutUserInput, TimerUncheckedCreateWithoutUserInput>
  }

  export type TimerCreateManyUserInputEnvelope = {
    data: TimerCreateManyUserInput | TimerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutUserInput = {
    id?: string
    name: string
    icon: string
    link: string
    type: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    organization: OrganizationCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    icon: string
    link: string
    organizationId: string
    type: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type FavoriteCreateOrConnectWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateManyUserInputEnvelope = {
    data: FavoriteCreateManyUserInput | FavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: UuidFilter<"Member"> | string
    role?: EnumMemberRoleFilter<"Member"> | $Enums.MemberRole
    userId?: UuidFilter<"Member"> | string
    projectId?: UuidFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    createdBy?: UuidNullableFilter<"Member"> | string | null
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    updatedBy?: UuidNullableFilter<"Member"> | string | null
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationMemberScalarWhereInput = {
    AND?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    OR?: OrganizationMemberScalarWhereInput[]
    NOT?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    id?: UuidFilter<"OrganizationMember"> | string
    organizationId?: UuidFilter<"OrganizationMember"> | string
    userId?: UuidFilter<"OrganizationMember"> | string
    status?: EnumInvitationStatusFilter<"OrganizationMember"> | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFilter<"OrganizationMember"> | $Enums.OrganizationRole
    createdAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    createdBy?: UuidNullableFilter<"OrganizationMember"> | string | null
    updatedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    updatedBy?: UuidNullableFilter<"OrganizationMember"> | string | null
  }

  export type TaskAssigneeUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput
    update: XOR<TaskAssigneeUpdateWithoutUserInput, TaskAssigneeUncheckedUpdateWithoutUserInput>
    create: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
  }

  export type TaskAssigneeUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput
    data: XOR<TaskAssigneeUpdateWithoutUserInput, TaskAssigneeUncheckedUpdateWithoutUserInput>
  }

  export type TaskAssigneeUpdateManyWithWhereWithoutUserInput = {
    where: TaskAssigneeScalarWhereInput
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskAssigneeScalarWhereInput = {
    AND?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
    OR?: TaskAssigneeScalarWhereInput[]
    NOT?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
    taskId?: UuidFilter<"TaskAssignee"> | string
    userId?: UuidFilter<"TaskAssignee"> | string
    assignedAt?: DateTimeFilter<"TaskAssignee"> | Date | string
  }

  export type ProjectSettingNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectSettingNotificationWhereUniqueInput
    update: XOR<ProjectSettingNotificationUpdateWithoutUserInput, ProjectSettingNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectSettingNotificationCreateWithoutUserInput, ProjectSettingNotificationUncheckedCreateWithoutUserInput>
  }

  export type ProjectSettingNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectSettingNotificationWhereUniqueInput
    data: XOR<ProjectSettingNotificationUpdateWithoutUserInput, ProjectSettingNotificationUncheckedUpdateWithoutUserInput>
  }

  export type ProjectSettingNotificationUpdateManyWithWhereWithoutUserInput = {
    where: ProjectSettingNotificationScalarWhereInput
    data: XOR<ProjectSettingNotificationUpdateManyMutationInput, ProjectSettingNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectSettingNotificationScalarWhereInput = {
    AND?: ProjectSettingNotificationScalarWhereInput | ProjectSettingNotificationScalarWhereInput[]
    OR?: ProjectSettingNotificationScalarWhereInput[]
    NOT?: ProjectSettingNotificationScalarWhereInput | ProjectSettingNotificationScalarWhereInput[]
    id?: UuidFilter<"ProjectSettingNotification"> | string
    userId?: UuidFilter<"ProjectSettingNotification"> | string
    projectId?: UuidFilter<"ProjectSettingNotification"> | string
    taskChanges?: BoolFilter<"ProjectSettingNotification"> | boolean
    remind?: BoolFilter<"ProjectSettingNotification"> | boolean
    overdue?: BoolFilter<"ProjectSettingNotification"> | boolean
    createdAt?: DateTimeFilter<"ProjectSettingNotification"> | Date | string
    createdBy?: UuidNullableFilter<"ProjectSettingNotification"> | string | null
  }

  export type StatUpsertWithWhereUniqueWithoutUserInput = {
    where: StatWhereUniqueInput
    update: XOR<StatUpdateWithoutUserInput, StatUncheckedUpdateWithoutUserInput>
    create: XOR<StatCreateWithoutUserInput, StatUncheckedCreateWithoutUserInput>
  }

  export type StatUpdateWithWhereUniqueWithoutUserInput = {
    where: StatWhereUniqueInput
    data: XOR<StatUpdateWithoutUserInput, StatUncheckedUpdateWithoutUserInput>
  }

  export type StatUpdateManyWithWhereWithoutUserInput = {
    where: StatScalarWhereInput
    data: XOR<StatUpdateManyMutationInput, StatUncheckedUpdateManyWithoutUserInput>
  }

  export type StatScalarWhereInput = {
    AND?: StatScalarWhereInput | StatScalarWhereInput[]
    OR?: StatScalarWhereInput[]
    NOT?: StatScalarWhereInput | StatScalarWhereInput[]
    id?: UuidFilter<"Stat"> | string
    type?: EnumStatTypeFilter<"Stat"> | $Enums.StatType
    data?: JsonNullableFilter<"Stat">
    userId?: UuidNullableFilter<"Stat"> | string | null
    projectId?: UuidNullableFilter<"Stat"> | string | null
    organizationId?: UuidNullableFilter<"Stat"> | string | null
    year?: IntFilter<"Stat"> | number
    month?: IntFilter<"Stat"> | number
    date?: IntFilter<"Stat"> | number
    updatedAt?: DateTimeNullableFilter<"Stat"> | Date | string | null
  }

  export type TimerUpsertWithWhereUniqueWithoutUserInput = {
    where: TimerWhereUniqueInput
    update: XOR<TimerUpdateWithoutUserInput, TimerUncheckedUpdateWithoutUserInput>
    create: XOR<TimerCreateWithoutUserInput, TimerUncheckedCreateWithoutUserInput>
  }

  export type TimerUpdateWithWhereUniqueWithoutUserInput = {
    where: TimerWhereUniqueInput
    data: XOR<TimerUpdateWithoutUserInput, TimerUncheckedUpdateWithoutUserInput>
  }

  export type TimerUpdateManyWithWhereWithoutUserInput = {
    where: TimerScalarWhereInput
    data: XOR<TimerUpdateManyMutationInput, TimerUncheckedUpdateManyWithoutUserInput>
  }

  export type TimerScalarWhereInput = {
    AND?: TimerScalarWhereInput | TimerScalarWhereInput[]
    OR?: TimerScalarWhereInput[]
    NOT?: TimerScalarWhereInput | TimerScalarWhereInput[]
    id?: UuidFilter<"Timer"> | string
    taskId?: UuidFilter<"Timer"> | string
    userId?: UuidFilter<"Timer"> | string
    startTime?: DateTimeFilter<"Timer"> | Date | string
    endTime?: DateTimeNullableFilter<"Timer"> | Date | string | null
    duration?: IntFilter<"Timer"> | number
    createdAt?: DateTimeFilter<"Timer"> | Date | string
    updatedAt?: DateTimeFilter<"Timer"> | Date | string
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: UuidFilter<"Favorite"> | string
    name?: StringFilter<"Favorite"> | string
    icon?: StringFilter<"Favorite"> | string
    link?: StringFilter<"Favorite"> | string
    userId?: UuidFilter<"Favorite"> | string
    organizationId?: UuidFilter<"Favorite"> | string
    type?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    createdBy?: UuidNullableFilter<"Favorite"> | string | null
    updatedAt?: DateTimeNullableFilter<"Favorite"> | Date | string | null
    updatedBy?: UuidNullableFilter<"Favorite"> | string | null
  }

  export type ProjectCreateWithoutOrganizationInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectCreateManyOrganizationInputEnvelope = {
    data: ProjectCreateManyOrganizationInput | ProjectCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type VisionCreateWithoutOrganizationInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project?: ProjectCreateNestedOneWithoutVisionInput
    parent?: VisionCreateNestedOneWithoutChildrenInput
    children?: VisionCreateNestedManyWithoutParentInput
  }

  export type VisionUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    projectId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    children?: VisionUncheckedCreateNestedManyWithoutParentInput
  }

  export type VisionCreateOrConnectWithoutOrganizationInput = {
    where: VisionWhereUniqueInput
    create: XOR<VisionCreateWithoutOrganizationInput, VisionUncheckedCreateWithoutOrganizationInput>
  }

  export type VisionCreateManyOrganizationInputEnvelope = {
    data: VisionCreateManyOrganizationInput | VisionCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMemberCreateWithoutOrganizationInput = {
    id?: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    user: UserCreateNestedOneWithoutOrganizationMembersInput
  }

  export type OrganizationMemberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationMemberCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberCreateManyOrganizationInputEnvelope = {
    data: OrganizationMemberCreateManyOrganizationInput | OrganizationMemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type TaskAutomationCreateWithoutOrganizationInput = {
    id?: string
    when: JsonNullValueInput | InputJsonValue
    then: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project: ProjectCreateNestedOneWithoutTaskAutomationsInput
  }

  export type TaskAutomationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    projectId: string
    when: JsonNullValueInput | InputJsonValue
    then: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskAutomationCreateOrConnectWithoutOrganizationInput = {
    where: TaskAutomationWhereUniqueInput
    create: XOR<TaskAutomationCreateWithoutOrganizationInput, TaskAutomationUncheckedCreateWithoutOrganizationInput>
  }

  export type TaskAutomationCreateManyOrganizationInputEnvelope = {
    data: TaskAutomationCreateManyOrganizationInput | TaskAutomationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SchedulerCreateWithoutOrganizationInput = {
    id?: string
    cronId?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project: ProjectCreateNestedOneWithoutSchedulersInput
  }

  export type SchedulerUncheckedCreateWithoutOrganizationInput = {
    id?: string
    projectId: string
    cronId?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SchedulerCreateOrConnectWithoutOrganizationInput = {
    where: SchedulerWhereUniqueInput
    create: XOR<SchedulerCreateWithoutOrganizationInput, SchedulerUncheckedCreateWithoutOrganizationInput>
  }

  export type SchedulerCreateManyOrganizationInputEnvelope = {
    data: SchedulerCreateManyOrganizationInput | SchedulerCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type FileStorageCreateWithoutOrganizationInput = {
    id?: string
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    project?: ProjectCreateNestedOneWithoutFileStoragesInput
    task?: TaskCreateNestedOneWithoutFileStoragesInput
  }

  export type FileStorageUncheckedCreateWithoutOrganizationInput = {
    id?: string
    projectId?: string | null
    taskId?: string | null
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type FileStorageCreateOrConnectWithoutOrganizationInput = {
    where: FileStorageWhereUniqueInput
    create: XOR<FileStorageCreateWithoutOrganizationInput, FileStorageUncheckedCreateWithoutOrganizationInput>
  }

  export type FileStorageCreateManyOrganizationInputEnvelope = {
    data: FileStorageCreateManyOrganizationInput | FileStorageCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type StatCreateWithoutOrganizationInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutStatsInput
    project?: ProjectCreateNestedOneWithoutStatsInput
  }

  export type StatUncheckedCreateWithoutOrganizationInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    projectId?: string | null
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
  }

  export type StatCreateOrConnectWithoutOrganizationInput = {
    where: StatWhereUniqueInput
    create: XOR<StatCreateWithoutOrganizationInput, StatUncheckedCreateWithoutOrganizationInput>
  }

  export type StatCreateManyOrganizationInputEnvelope = {
    data: StatCreateManyOrganizationInput | StatCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    clientSecret: string
    scopes?: ApplicationCreatescopesInput | string[]
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ApplicationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    clientSecret: string
    scopes?: ApplicationCreatescopesInput | string[]
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ApplicationCreateOrConnectWithoutOrganizationInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutOrganizationInput, ApplicationUncheckedCreateWithoutOrganizationInput>
  }

  export type ApplicationCreateManyOrganizationInputEnvelope = {
    data: ApplicationCreateManyOrganizationInput | ApplicationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutOrganizationInput = {
    id?: string
    name: string
    icon: string
    link: string
    type: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    icon: string
    link: string
    userId: string
    type: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type FavoriteCreateOrConnectWithoutOrganizationInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutOrganizationInput, FavoriteUncheckedCreateWithoutOrganizationInput>
  }

  export type FavoriteCreateManyOrganizationInputEnvelope = {
    data: FavoriteCreateManyOrganizationInput | FavoriteCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: UuidFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    organizationId?: UuidFilter<"Project"> | string
    desc?: StringNullableFilter<"Project"> | string | null
    cover?: StringNullableFilter<"Project"> | string | null
    icon?: StringNullableFilter<"Project"> | string | null
    isArchived?: BoolFilter<"Project"> | boolean
    countMemberTask?: BoolFilter<"Project"> | boolean
    countProjectTask?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: UuidNullableFilter<"Project"> | string | null
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    updatedBy?: UuidNullableFilter<"Project"> | string | null
  }

  export type VisionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: VisionWhereUniqueInput
    update: XOR<VisionUpdateWithoutOrganizationInput, VisionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<VisionCreateWithoutOrganizationInput, VisionUncheckedCreateWithoutOrganizationInput>
  }

  export type VisionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: VisionWhereUniqueInput
    data: XOR<VisionUpdateWithoutOrganizationInput, VisionUncheckedUpdateWithoutOrganizationInput>
  }

  export type VisionUpdateManyWithWhereWithoutOrganizationInput = {
    where: VisionScalarWhereInput
    data: XOR<VisionUpdateManyMutationInput, VisionUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type VisionScalarWhereInput = {
    AND?: VisionScalarWhereInput | VisionScalarWhereInput[]
    OR?: VisionScalarWhereInput[]
    NOT?: VisionScalarWhereInput | VisionScalarWhereInput[]
    id?: UuidFilter<"Vision"> | string
    name?: StringFilter<"Vision"> | string
    startDate?: DateTimeNullableFilter<"Vision"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Vision"> | Date | string | null
    progress?: IntNullableFilter<"Vision"> | number | null
    projectId?: UuidNullableFilter<"Vision"> | string | null
    organizationId?: UuidNullableFilter<"Vision"> | string | null
    parentId?: UuidNullableFilter<"Vision"> | string | null
    createdAt?: DateTimeFilter<"Vision"> | Date | string
    createdBy?: StringNullableFilter<"Vision"> | string | null
    updatedAt?: DateTimeFilter<"Vision"> | Date | string
    updatedBy?: StringNullableFilter<"Vision"> | string | null
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type TaskAutomationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TaskAutomationWhereUniqueInput
    update: XOR<TaskAutomationUpdateWithoutOrganizationInput, TaskAutomationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<TaskAutomationCreateWithoutOrganizationInput, TaskAutomationUncheckedCreateWithoutOrganizationInput>
  }

  export type TaskAutomationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TaskAutomationWhereUniqueInput
    data: XOR<TaskAutomationUpdateWithoutOrganizationInput, TaskAutomationUncheckedUpdateWithoutOrganizationInput>
  }

  export type TaskAutomationUpdateManyWithWhereWithoutOrganizationInput = {
    where: TaskAutomationScalarWhereInput
    data: XOR<TaskAutomationUpdateManyMutationInput, TaskAutomationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type TaskAutomationScalarWhereInput = {
    AND?: TaskAutomationScalarWhereInput | TaskAutomationScalarWhereInput[]
    OR?: TaskAutomationScalarWhereInput[]
    NOT?: TaskAutomationScalarWhereInput | TaskAutomationScalarWhereInput[]
    id?: UuidFilter<"TaskAutomation"> | string
    organizationId?: UuidFilter<"TaskAutomation"> | string
    projectId?: UuidFilter<"TaskAutomation"> | string
    when?: JsonFilter<"TaskAutomation">
    then?: JsonFilter<"TaskAutomation">
    createdAt?: DateTimeFilter<"TaskAutomation"> | Date | string
    createdBy?: UuidNullableFilter<"TaskAutomation"> | string | null
    updatedAt?: DateTimeFilter<"TaskAutomation"> | Date | string
    updatedBy?: UuidNullableFilter<"TaskAutomation"> | string | null
  }

  export type SchedulerUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SchedulerWhereUniqueInput
    update: XOR<SchedulerUpdateWithoutOrganizationInput, SchedulerUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SchedulerCreateWithoutOrganizationInput, SchedulerUncheckedCreateWithoutOrganizationInput>
  }

  export type SchedulerUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SchedulerWhereUniqueInput
    data: XOR<SchedulerUpdateWithoutOrganizationInput, SchedulerUncheckedUpdateWithoutOrganizationInput>
  }

  export type SchedulerUpdateManyWithWhereWithoutOrganizationInput = {
    where: SchedulerScalarWhereInput
    data: XOR<SchedulerUpdateManyMutationInput, SchedulerUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SchedulerScalarWhereInput = {
    AND?: SchedulerScalarWhereInput | SchedulerScalarWhereInput[]
    OR?: SchedulerScalarWhereInput[]
    NOT?: SchedulerScalarWhereInput | SchedulerScalarWhereInput[]
    id?: UuidFilter<"Scheduler"> | string
    organizationId?: UuidFilter<"Scheduler"> | string
    projectId?: UuidFilter<"Scheduler"> | string
    cronId?: StringNullableFilter<"Scheduler"> | string | null
    trigger?: JsonFilter<"Scheduler">
    action?: JsonFilter<"Scheduler">
    createdAt?: DateTimeFilter<"Scheduler"> | Date | string
    createdBy?: UuidNullableFilter<"Scheduler"> | string | null
    updatedAt?: DateTimeFilter<"Scheduler"> | Date | string
    updatedBy?: UuidNullableFilter<"Scheduler"> | string | null
  }

  export type FileStorageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: FileStorageWhereUniqueInput
    update: XOR<FileStorageUpdateWithoutOrganizationInput, FileStorageUncheckedUpdateWithoutOrganizationInput>
    create: XOR<FileStorageCreateWithoutOrganizationInput, FileStorageUncheckedCreateWithoutOrganizationInput>
  }

  export type FileStorageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: FileStorageWhereUniqueInput
    data: XOR<FileStorageUpdateWithoutOrganizationInput, FileStorageUncheckedUpdateWithoutOrganizationInput>
  }

  export type FileStorageUpdateManyWithWhereWithoutOrganizationInput = {
    where: FileStorageScalarWhereInput
    data: XOR<FileStorageUpdateManyMutationInput, FileStorageUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type FileStorageScalarWhereInput = {
    AND?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
    OR?: FileStorageScalarWhereInput[]
    NOT?: FileStorageScalarWhereInput | FileStorageScalarWhereInput[]
    id?: UuidFilter<"FileStorage"> | string
    organizationId?: UuidNullableFilter<"FileStorage"> | string | null
    projectId?: UuidNullableFilter<"FileStorage"> | string | null
    taskId?: UuidNullableFilter<"FileStorage"> | string | null
    name?: StringFilter<"FileStorage"> | string
    keyName?: StringFilter<"FileStorage"> | string
    type?: EnumFileTypeFilter<"FileStorage"> | $Enums.FileType
    url?: StringNullableFilter<"FileStorage"> | string | null
    size?: FloatNullableFilter<"FileStorage"> | number | null
    mimeType?: StringNullableFilter<"FileStorage"> | string | null
    parentId?: StringNullableFilter<"FileStorage"> | string | null
    owner?: UuidNullableFilter<"FileStorage"> | string | null
    ownerType?: EnumFileOwnerTypeNullableFilter<"FileStorage"> | $Enums.FileOwnerType | null
    isDeleted?: BoolNullableFilter<"FileStorage"> | boolean | null
    createdAt?: DateTimeFilter<"FileStorage"> | Date | string
    createdBy?: UuidNullableFilter<"FileStorage"> | string | null
    deletedAt?: DateTimeNullableFilter<"FileStorage"> | Date | string | null
    deletedBy?: UuidNullableFilter<"FileStorage"> | string | null
  }

  export type StatUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: StatWhereUniqueInput
    update: XOR<StatUpdateWithoutOrganizationInput, StatUncheckedUpdateWithoutOrganizationInput>
    create: XOR<StatCreateWithoutOrganizationInput, StatUncheckedCreateWithoutOrganizationInput>
  }

  export type StatUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: StatWhereUniqueInput
    data: XOR<StatUpdateWithoutOrganizationInput, StatUncheckedUpdateWithoutOrganizationInput>
  }

  export type StatUpdateManyWithWhereWithoutOrganizationInput = {
    where: StatScalarWhereInput
    data: XOR<StatUpdateManyMutationInput, StatUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ApplicationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutOrganizationInput, ApplicationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ApplicationCreateWithoutOrganizationInput, ApplicationUncheckedCreateWithoutOrganizationInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutOrganizationInput, ApplicationUncheckedUpdateWithoutOrganizationInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutOrganizationInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    OR?: ApplicationScalarWhereInput[]
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    id?: UuidFilter<"Application"> | string
    name?: StringFilter<"Application"> | string
    description?: StringNullableFilter<"Application"> | string | null
    clientId?: StringFilter<"Application"> | string
    clientSecret?: StringFilter<"Application"> | string
    organizationId?: UuidFilter<"Application"> | string
    scopes?: StringNullableListFilter<"Application">
    createdAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    createdBy?: UuidNullableFilter<"Application"> | string | null
    updatedAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    updatedBy?: UuidNullableFilter<"Application"> | string | null
  }

  export type FavoriteUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutOrganizationInput, FavoriteUncheckedUpdateWithoutOrganizationInput>
    create: XOR<FavoriteCreateWithoutOrganizationInput, FavoriteUncheckedCreateWithoutOrganizationInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutOrganizationInput, FavoriteUncheckedUpdateWithoutOrganizationInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutOrganizationInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationCreateWithoutOrganizationMembersInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    visions?: VisionCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageCreateNestedManyWithoutOrganizationInput
    stats?: StatCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOrganizationMembersInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    visions?: VisionUncheckedCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutOrganizationInput
    stats?: StatUncheckedCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOrganizationMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrganizationMembersInput, OrganizationUncheckedCreateWithoutOrganizationMembersInput>
  }

  export type UserCreateWithoutOrganizationMembersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutUserInput
    stats?: StatCreateNestedManyWithoutUserInput
    timers?: TimerCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationMembersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutUserInput
    stats?: StatUncheckedCreateNestedManyWithoutUserInput
    timers?: TimerUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationMembersInput, UserUncheckedCreateWithoutOrganizationMembersInput>
  }

  export type OrganizationUpsertWithoutOrganizationMembersInput = {
    update: XOR<OrganizationUpdateWithoutOrganizationMembersInput, OrganizationUncheckedUpdateWithoutOrganizationMembersInput>
    create: XOR<OrganizationCreateWithoutOrganizationMembersInput, OrganizationUncheckedCreateWithoutOrganizationMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrganizationMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrganizationMembersInput, OrganizationUncheckedUpdateWithoutOrganizationMembersInput>
  }

  export type OrganizationUpdateWithoutOrganizationMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUpdateManyWithoutOrganizationNestedInput
    stats?: StatUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrganizationMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUncheckedUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput
    stats?: StatUncheckedUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOrganizationMembersInput = {
    update: XOR<UserUpdateWithoutOrganizationMembersInput, UserUncheckedUpdateWithoutOrganizationMembersInput>
    create: XOR<UserCreateWithoutOrganizationMembersInput, UserUncheckedCreateWithoutOrganizationMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationMembersInput, UserUncheckedUpdateWithoutOrganizationMembersInput>
  }

  export type UserUpdateWithoutOrganizationMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutUserNestedInput
    stats?: StatUpdateManyWithoutUserNestedInput
    timers?: TimerUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutUserNestedInput
    stats?: StatUncheckedUpdateManyWithoutUserNestedInput
    timers?: TimerUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMembersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutUserInput
    stats?: StatCreateNestedManyWithoutUserInput
    timers?: TimerCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutUserInput
    stats?: StatUncheckedCreateNestedManyWithoutUserInput
    timers?: TimerUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutMembersInput = {
    update: XOR<UserUpdateWithoutMembersInput, UserUncheckedUpdateWithoutMembersInput>
    create: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembersInput, UserUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationMembers?: OrganizationMemberUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutUserNestedInput
    stats?: StatUpdateManyWithoutUserNestedInput
    timers?: TimerUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutUserNestedInput
    stats?: StatUncheckedUpdateManyWithoutUserNestedInput
    timers?: TimerUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectViewCreateWithoutProjectInput = {
    id?: string
    name?: string | null
    type: $Enums.ProjectViewType
    onlyMe?: boolean
    icon?: string | null
    order?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProjectViewUncheckedCreateWithoutProjectInput = {
    id?: string
    name?: string | null
    type: $Enums.ProjectViewType
    onlyMe?: boolean
    icon?: string | null
    order?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProjectViewCreateOrConnectWithoutProjectInput = {
    where: ProjectViewWhereUniqueInput
    create: XOR<ProjectViewCreateWithoutProjectInput, ProjectViewUncheckedCreateWithoutProjectInput>
  }

  export type FieldCreateWithoutProjectInput = {
    id?: string
    name: string
    type: $Enums.FieldType
    icon?: string | null
    hidden?: boolean
    width: number
    order: number
    desc?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FieldUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    type: $Enums.FieldType
    icon?: string | null
    hidden?: boolean
    width: number
    order: number
    desc?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FieldCreateOrConnectWithoutProjectInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutProjectInput, FieldUncheckedCreateWithoutProjectInput>
  }

  export type FieldCreateManyProjectInputEnvelope = {
    data: FieldCreateManyProjectInput | FieldCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type VisionCreateWithoutProjectInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organization?: OrganizationCreateNestedOneWithoutVisionsInput
    parent?: VisionCreateNestedOneWithoutChildrenInput
    children?: VisionCreateNestedManyWithoutParentInput
  }

  export type VisionUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    organizationId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    children?: VisionUncheckedCreateNestedManyWithoutParentInput
  }

  export type VisionCreateOrConnectWithoutProjectInput = {
    where: VisionWhereUniqueInput
    create: XOR<VisionCreateWithoutProjectInput, VisionUncheckedCreateWithoutProjectInput>
  }

  export type VisionCreateManyProjectInputEnvelope = {
    data: VisionCreateManyProjectInput | VisionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSettingNotificationCreateWithoutProjectInput = {
    id?: string
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    user: UserCreateNestedOneWithoutProjectSettingNotificationsInput
  }

  export type ProjectSettingNotificationUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type ProjectSettingNotificationCreateOrConnectWithoutProjectInput = {
    where: ProjectSettingNotificationWhereUniqueInput
    create: XOR<ProjectSettingNotificationCreateWithoutProjectInput, ProjectSettingNotificationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSettingNotificationCreateManyProjectInputEnvelope = {
    data: ProjectSettingNotificationCreateManyProjectInput | ProjectSettingNotificationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutProjectInput = {
    id?: string
    role: $Enums.MemberRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    user: UserCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutProjectInput = {
    id?: string
    role: $Enums.MemberRole
    userId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type MemberCreateOrConnectWithoutProjectInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput>
  }

  export type MemberCreateManyProjectInputEnvelope = {
    data: MemberCreateManyProjectInput | MemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type GridCreateWithoutProjectInput = {
    id?: string
    title: string
    cover?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type GridUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    cover?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type GridCreateOrConnectWithoutProjectInput = {
    where: GridWhereUniqueInput
    create: XOR<GridCreateWithoutProjectInput, GridUncheckedCreateWithoutProjectInput>
  }

  export type GridCreateManyProjectInputEnvelope = {
    data: GridCreateManyProjectInput | GridCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskStatusCreateWithoutProjectInput = {
    id?: string
    name: string
    color: string
    order: number
    type?: $Enums.StatusType
    tasks?: TaskCreateNestedManyWithoutTaskStatusInput
  }

  export type TaskStatusUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    color: string
    order: number
    type?: $Enums.StatusType
    tasks?: TaskUncheckedCreateNestedManyWithoutTaskStatusInput
  }

  export type TaskStatusCreateOrConnectWithoutProjectInput = {
    where: TaskStatusWhereUniqueInput
    create: XOR<TaskStatusCreateWithoutProjectInput, TaskStatusUncheckedCreateWithoutProjectInput>
  }

  export type TaskStatusCreateManyProjectInputEnvelope = {
    data: TaskStatusCreateManyProjectInput | TaskStatusCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskPointCreateWithoutProjectInput = {
    id?: string
    point: number
    icon?: string | null
  }

  export type TaskPointUncheckedCreateWithoutProjectInput = {
    id?: string
    point: number
    icon?: string | null
  }

  export type TaskPointCreateOrConnectWithoutProjectInput = {
    where: TaskPointWhereUniqueInput
    create: XOR<TaskPointCreateWithoutProjectInput, TaskPointUncheckedCreateWithoutProjectInput>
  }

  export type TaskPointCreateManyProjectInputEnvelope = {
    data: TaskPointCreateManyProjectInput | TaskPointCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutProjectInput = {
    id?: string
    name: string
    color: string
    taskTags?: TaskTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    color: string
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutProjectInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput>
  }

  export type TagCreateManyProjectInputEnvelope = {
    data: TagCreateManyProjectInput | TagCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskAutomationCreateWithoutProjectInput = {
    id?: string
    when: JsonNullValueInput | InputJsonValue
    then: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organization: OrganizationCreateNestedOneWithoutTaskAutomationsInput
  }

  export type TaskAutomationUncheckedCreateWithoutProjectInput = {
    id?: string
    organizationId: string
    when: JsonNullValueInput | InputJsonValue
    then: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskAutomationCreateOrConnectWithoutProjectInput = {
    where: TaskAutomationWhereUniqueInput
    create: XOR<TaskAutomationCreateWithoutProjectInput, TaskAutomationUncheckedCreateWithoutProjectInput>
  }

  export type TaskAutomationCreateManyProjectInputEnvelope = {
    data: TaskAutomationCreateManyProjectInput | TaskAutomationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SchedulerCreateWithoutProjectInput = {
    id?: string
    cronId?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    organization: OrganizationCreateNestedOneWithoutSchedulersInput
  }

  export type SchedulerUncheckedCreateWithoutProjectInput = {
    id?: string
    organizationId: string
    cronId?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SchedulerCreateOrConnectWithoutProjectInput = {
    where: SchedulerWhereUniqueInput
    create: XOR<SchedulerCreateWithoutProjectInput, SchedulerUncheckedCreateWithoutProjectInput>
  }

  export type SchedulerCreateManyProjectInputEnvelope = {
    data: SchedulerCreateManyProjectInput | SchedulerCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type FileStorageCreateWithoutProjectInput = {
    id?: string
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    organization?: OrganizationCreateNestedOneWithoutFileStoragesInput
    task?: TaskCreateNestedOneWithoutFileStoragesInput
  }

  export type FileStorageUncheckedCreateWithoutProjectInput = {
    id?: string
    organizationId?: string | null
    taskId?: string | null
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type FileStorageCreateOrConnectWithoutProjectInput = {
    where: FileStorageWhereUniqueInput
    create: XOR<FileStorageCreateWithoutProjectInput, FileStorageUncheckedCreateWithoutProjectInput>
  }

  export type FileStorageCreateManyProjectInputEnvelope = {
    data: FileStorageCreateManyProjectInput | FileStorageCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type StatCreateWithoutProjectInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutStatsInput
    organization?: OrganizationCreateNestedOneWithoutStatsInput
  }

  export type StatUncheckedCreateWithoutProjectInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    organizationId?: string | null
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
  }

  export type StatCreateOrConnectWithoutProjectInput = {
    where: StatWhereUniqueInput
    create: XOR<StatCreateWithoutProjectInput, StatUncheckedCreateWithoutProjectInput>
  }

  export type StatCreateManyProjectInputEnvelope = {
    data: StatCreateManyProjectInput | StatCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutProjectInput = {
    id?: string
    content: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutProjectInput = {
    id?: string
    taskId: string
    content: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutProjectInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput>
  }

  export type CommentCreateManyProjectInputEnvelope = {
    data: CommentCreateManyProjectInput | CommentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type DashboardCreateWithoutProjectInput = {
    id?: string
    title?: string | null
    isDefault?: boolean | null
    dashboardComponents?: DashboardComponentCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUncheckedCreateWithoutProjectInput = {
    id?: string
    title?: string | null
    isDefault?: boolean | null
    dashboardComponents?: DashboardComponentUncheckedCreateNestedManyWithoutDashboardInput
  }

  export type DashboardCreateOrConnectWithoutProjectInput = {
    where: DashboardWhereUniqueInput
    create: XOR<DashboardCreateWithoutProjectInput, DashboardUncheckedCreateWithoutProjectInput>
  }

  export type DashboardCreateManyProjectInputEnvelope = {
    data: DashboardCreateManyProjectInput | DashboardCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    visions?: VisionCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageCreateNestedManyWithoutOrganizationInput
    stats?: StatCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    visions?: VisionUncheckedCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutOrganizationInput
    stats?: StatUncheckedCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProjectsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectViewUpsertWithoutProjectInput = {
    update: XOR<ProjectViewUpdateWithoutProjectInput, ProjectViewUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectViewCreateWithoutProjectInput, ProjectViewUncheckedCreateWithoutProjectInput>
    where?: ProjectViewWhereInput
  }

  export type ProjectViewUpdateToOneWithWhereWithoutProjectInput = {
    where?: ProjectViewWhereInput
    data: XOR<ProjectViewUpdateWithoutProjectInput, ProjectViewUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectViewUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectViewTypeFieldUpdateOperationsInput | $Enums.ProjectViewType
    onlyMe?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectViewUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectViewTypeFieldUpdateOperationsInput | $Enums.ProjectViewType
    onlyMe?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldUpsertWithWhereUniqueWithoutProjectInput = {
    where: FieldWhereUniqueInput
    update: XOR<FieldUpdateWithoutProjectInput, FieldUncheckedUpdateWithoutProjectInput>
    create: XOR<FieldCreateWithoutProjectInput, FieldUncheckedCreateWithoutProjectInput>
  }

  export type FieldUpdateWithWhereUniqueWithoutProjectInput = {
    where: FieldWhereUniqueInput
    data: XOR<FieldUpdateWithoutProjectInput, FieldUncheckedUpdateWithoutProjectInput>
  }

  export type FieldUpdateManyWithWhereWithoutProjectInput = {
    where: FieldScalarWhereInput
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyWithoutProjectInput>
  }

  export type FieldScalarWhereInput = {
    AND?: FieldScalarWhereInput | FieldScalarWhereInput[]
    OR?: FieldScalarWhereInput[]
    NOT?: FieldScalarWhereInput | FieldScalarWhereInput[]
    id?: UuidFilter<"Field"> | string
    projectId?: UuidFilter<"Field"> | string
    name?: StringFilter<"Field"> | string
    type?: EnumFieldTypeFilter<"Field"> | $Enums.FieldType
    icon?: StringNullableFilter<"Field"> | string | null
    hidden?: BoolFilter<"Field"> | boolean
    width?: IntFilter<"Field"> | number
    order?: IntFilter<"Field"> | number
    desc?: StringNullableFilter<"Field"> | string | null
    data?: JsonNullableFilter<"Field">
    config?: JsonNullableFilter<"Field">
  }

  export type VisionUpsertWithWhereUniqueWithoutProjectInput = {
    where: VisionWhereUniqueInput
    update: XOR<VisionUpdateWithoutProjectInput, VisionUncheckedUpdateWithoutProjectInput>
    create: XOR<VisionCreateWithoutProjectInput, VisionUncheckedCreateWithoutProjectInput>
  }

  export type VisionUpdateWithWhereUniqueWithoutProjectInput = {
    where: VisionWhereUniqueInput
    data: XOR<VisionUpdateWithoutProjectInput, VisionUncheckedUpdateWithoutProjectInput>
  }

  export type VisionUpdateManyWithWhereWithoutProjectInput = {
    where: VisionScalarWhereInput
    data: XOR<VisionUpdateManyMutationInput, VisionUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectSettingNotificationUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectSettingNotificationWhereUniqueInput
    update: XOR<ProjectSettingNotificationUpdateWithoutProjectInput, ProjectSettingNotificationUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectSettingNotificationCreateWithoutProjectInput, ProjectSettingNotificationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSettingNotificationUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectSettingNotificationWhereUniqueInput
    data: XOR<ProjectSettingNotificationUpdateWithoutProjectInput, ProjectSettingNotificationUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectSettingNotificationUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectSettingNotificationScalarWhereInput
    data: XOR<ProjectSettingNotificationUpdateManyMutationInput, ProjectSettingNotificationUncheckedUpdateManyWithoutProjectInput>
  }

  export type MemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutProjectInput, MemberUncheckedUpdateWithoutProjectInput>
    create: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutProjectInput, MemberUncheckedUpdateWithoutProjectInput>
  }

  export type MemberUpdateManyWithWhereWithoutProjectInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type GridUpsertWithWhereUniqueWithoutProjectInput = {
    where: GridWhereUniqueInput
    update: XOR<GridUpdateWithoutProjectInput, GridUncheckedUpdateWithoutProjectInput>
    create: XOR<GridCreateWithoutProjectInput, GridUncheckedCreateWithoutProjectInput>
  }

  export type GridUpdateWithWhereUniqueWithoutProjectInput = {
    where: GridWhereUniqueInput
    data: XOR<GridUpdateWithoutProjectInput, GridUncheckedUpdateWithoutProjectInput>
  }

  export type GridUpdateManyWithWhereWithoutProjectInput = {
    where: GridScalarWhereInput
    data: XOR<GridUpdateManyMutationInput, GridUncheckedUpdateManyWithoutProjectInput>
  }

  export type GridScalarWhereInput = {
    AND?: GridScalarWhereInput | GridScalarWhereInput[]
    OR?: GridScalarWhereInput[]
    NOT?: GridScalarWhereInput | GridScalarWhereInput[]
    id?: UuidFilter<"Grid"> | string
    title?: StringFilter<"Grid"> | string
    cover?: StringNullableFilter<"Grid"> | string | null
    projectId?: UuidFilter<"Grid"> | string
    customFields?: JsonNullableFilter<"Grid">
    isDeleted?: BoolNullableFilter<"Grid"> | boolean | null
    createdAt?: DateTimeFilter<"Grid"> | Date | string
    createdBy?: UuidNullableFilter<"Grid"> | string | null
    updatedAt?: DateTimeFilter<"Grid"> | Date | string
    updatedBy?: UuidNullableFilter<"Grid"> | string | null
  }

  export type TaskStatusUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskStatusWhereUniqueInput
    update: XOR<TaskStatusUpdateWithoutProjectInput, TaskStatusUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskStatusCreateWithoutProjectInput, TaskStatusUncheckedCreateWithoutProjectInput>
  }

  export type TaskStatusUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskStatusWhereUniqueInput
    data: XOR<TaskStatusUpdateWithoutProjectInput, TaskStatusUncheckedUpdateWithoutProjectInput>
  }

  export type TaskStatusUpdateManyWithWhereWithoutProjectInput = {
    where: TaskStatusScalarWhereInput
    data: XOR<TaskStatusUpdateManyMutationInput, TaskStatusUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskStatusScalarWhereInput = {
    AND?: TaskStatusScalarWhereInput | TaskStatusScalarWhereInput[]
    OR?: TaskStatusScalarWhereInput[]
    NOT?: TaskStatusScalarWhereInput | TaskStatusScalarWhereInput[]
    id?: UuidFilter<"TaskStatus"> | string
    name?: StringFilter<"TaskStatus"> | string
    color?: StringFilter<"TaskStatus"> | string
    order?: IntFilter<"TaskStatus"> | number
    projectId?: UuidFilter<"TaskStatus"> | string
    type?: EnumStatusTypeFilter<"TaskStatus"> | $Enums.StatusType
  }

  export type TaskPointUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskPointWhereUniqueInput
    update: XOR<TaskPointUpdateWithoutProjectInput, TaskPointUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskPointCreateWithoutProjectInput, TaskPointUncheckedCreateWithoutProjectInput>
  }

  export type TaskPointUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskPointWhereUniqueInput
    data: XOR<TaskPointUpdateWithoutProjectInput, TaskPointUncheckedUpdateWithoutProjectInput>
  }

  export type TaskPointUpdateManyWithWhereWithoutProjectInput = {
    where: TaskPointScalarWhereInput
    data: XOR<TaskPointUpdateManyMutationInput, TaskPointUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskPointScalarWhereInput = {
    AND?: TaskPointScalarWhereInput | TaskPointScalarWhereInput[]
    OR?: TaskPointScalarWhereInput[]
    NOT?: TaskPointScalarWhereInput | TaskPointScalarWhereInput[]
    id?: UuidFilter<"TaskPoint"> | string
    point?: IntFilter<"TaskPoint"> | number
    projectId?: UuidFilter<"TaskPoint"> | string
    icon?: StringNullableFilter<"TaskPoint"> | string | null
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: UuidFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    desc?: StringNullableFilter<"Task"> | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    order?: IntFilter<"Task"> | number
    type?: EnumTaskTypeNullableFilter<"Task"> | $Enums.TaskType | null
    checklistDone?: IntNullableFilter<"Task"> | number | null
    checklistTodos?: IntNullableFilter<"Task"> | number | null
    cover?: StringNullableFilter<"Task"> | string | null
    plannedStartDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    plannedDueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    projectId?: UuidFilter<"Task"> | string
    priority?: EnumTaskPriorityNullableFilter<"Task"> | $Enums.TaskPriority | null
    taskStatusId?: UuidNullableFilter<"Task"> | string | null
    parentTaskId?: UuidNullableFilter<"Task"> | string | null
    progress?: IntNullableFilter<"Task"> | number | null
    done?: BoolFilter<"Task"> | boolean
    taskPoint?: IntNullableFilter<"Task"> | number | null
    customFields?: JsonNullableFilter<"Task">
    createdAt?: DateTimeFilter<"Task"> | Date | string
    createdBy?: UuidNullableFilter<"Task"> | string | null
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    updatedBy?: UuidNullableFilter<"Task"> | string | null
  }

  export type TagUpsertWithWhereUniqueWithoutProjectInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutProjectInput, TagUncheckedUpdateWithoutProjectInput>
    create: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput>
  }

  export type TagUpdateWithWhereUniqueWithoutProjectInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutProjectInput, TagUncheckedUpdateWithoutProjectInput>
  }

  export type TagUpdateManyWithWhereWithoutProjectInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutProjectInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: UuidFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    projectId?: UuidFilter<"Tag"> | string
  }

  export type TaskAutomationUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskAutomationWhereUniqueInput
    update: XOR<TaskAutomationUpdateWithoutProjectInput, TaskAutomationUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskAutomationCreateWithoutProjectInput, TaskAutomationUncheckedCreateWithoutProjectInput>
  }

  export type TaskAutomationUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskAutomationWhereUniqueInput
    data: XOR<TaskAutomationUpdateWithoutProjectInput, TaskAutomationUncheckedUpdateWithoutProjectInput>
  }

  export type TaskAutomationUpdateManyWithWhereWithoutProjectInput = {
    where: TaskAutomationScalarWhereInput
    data: XOR<TaskAutomationUpdateManyMutationInput, TaskAutomationUncheckedUpdateManyWithoutProjectInput>
  }

  export type SchedulerUpsertWithWhereUniqueWithoutProjectInput = {
    where: SchedulerWhereUniqueInput
    update: XOR<SchedulerUpdateWithoutProjectInput, SchedulerUncheckedUpdateWithoutProjectInput>
    create: XOR<SchedulerCreateWithoutProjectInput, SchedulerUncheckedCreateWithoutProjectInput>
  }

  export type SchedulerUpdateWithWhereUniqueWithoutProjectInput = {
    where: SchedulerWhereUniqueInput
    data: XOR<SchedulerUpdateWithoutProjectInput, SchedulerUncheckedUpdateWithoutProjectInput>
  }

  export type SchedulerUpdateManyWithWhereWithoutProjectInput = {
    where: SchedulerScalarWhereInput
    data: XOR<SchedulerUpdateManyMutationInput, SchedulerUncheckedUpdateManyWithoutProjectInput>
  }

  export type FileStorageUpsertWithWhereUniqueWithoutProjectInput = {
    where: FileStorageWhereUniqueInput
    update: XOR<FileStorageUpdateWithoutProjectInput, FileStorageUncheckedUpdateWithoutProjectInput>
    create: XOR<FileStorageCreateWithoutProjectInput, FileStorageUncheckedCreateWithoutProjectInput>
  }

  export type FileStorageUpdateWithWhereUniqueWithoutProjectInput = {
    where: FileStorageWhereUniqueInput
    data: XOR<FileStorageUpdateWithoutProjectInput, FileStorageUncheckedUpdateWithoutProjectInput>
  }

  export type FileStorageUpdateManyWithWhereWithoutProjectInput = {
    where: FileStorageScalarWhereInput
    data: XOR<FileStorageUpdateManyMutationInput, FileStorageUncheckedUpdateManyWithoutProjectInput>
  }

  export type StatUpsertWithWhereUniqueWithoutProjectInput = {
    where: StatWhereUniqueInput
    update: XOR<StatUpdateWithoutProjectInput, StatUncheckedUpdateWithoutProjectInput>
    create: XOR<StatCreateWithoutProjectInput, StatUncheckedCreateWithoutProjectInput>
  }

  export type StatUpdateWithWhereUniqueWithoutProjectInput = {
    where: StatWhereUniqueInput
    data: XOR<StatUpdateWithoutProjectInput, StatUncheckedUpdateWithoutProjectInput>
  }

  export type StatUpdateManyWithWhereWithoutProjectInput = {
    where: StatScalarWhereInput
    data: XOR<StatUpdateManyMutationInput, StatUncheckedUpdateManyWithoutProjectInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutProjectInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutProjectInput, CommentUncheckedUpdateWithoutProjectInput>
    create: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutProjectInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutProjectInput, CommentUncheckedUpdateWithoutProjectInput>
  }

  export type CommentUpdateManyWithWhereWithoutProjectInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutProjectInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: UuidFilter<"Comment"> | string
    taskId?: UuidFilter<"Comment"> | string
    projectId?: UuidFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    createdBy?: UuidFilter<"Comment"> | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type DashboardUpsertWithWhereUniqueWithoutProjectInput = {
    where: DashboardWhereUniqueInput
    update: XOR<DashboardUpdateWithoutProjectInput, DashboardUncheckedUpdateWithoutProjectInput>
    create: XOR<DashboardCreateWithoutProjectInput, DashboardUncheckedCreateWithoutProjectInput>
  }

  export type DashboardUpdateWithWhereUniqueWithoutProjectInput = {
    where: DashboardWhereUniqueInput
    data: XOR<DashboardUpdateWithoutProjectInput, DashboardUncheckedUpdateWithoutProjectInput>
  }

  export type DashboardUpdateManyWithWhereWithoutProjectInput = {
    where: DashboardScalarWhereInput
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyWithoutProjectInput>
  }

  export type DashboardScalarWhereInput = {
    AND?: DashboardScalarWhereInput | DashboardScalarWhereInput[]
    OR?: DashboardScalarWhereInput[]
    NOT?: DashboardScalarWhereInput | DashboardScalarWhereInput[]
    id?: UuidFilter<"Dashboard"> | string
    title?: StringNullableFilter<"Dashboard"> | string | null
    projectId?: UuidNullableFilter<"Dashboard"> | string | null
    isDefault?: BoolNullableFilter<"Dashboard"> | boolean | null
  }

  export type OrganizationUpsertWithoutProjectsInput = {
    update: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProjectsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type OrganizationUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    visions?: VisionUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUpdateManyWithoutOrganizationNestedInput
    stats?: StatUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    visions?: VisionUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput
    stats?: StatUncheckedUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectCreateWithoutProjectViewInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutProjectViewInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectViewInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectViewInput, ProjectUncheckedCreateWithoutProjectViewInput>
  }

  export type ProjectUpsertWithoutProjectViewInput = {
    update: XOR<ProjectUpdateWithoutProjectViewInput, ProjectUncheckedUpdateWithoutProjectViewInput>
    create: XOR<ProjectCreateWithoutProjectViewInput, ProjectUncheckedCreateWithoutProjectViewInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectViewInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectViewInput, ProjectUncheckedUpdateWithoutProjectViewInput>
  }

  export type ProjectUpdateWithoutProjectViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectViewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutProjectSettingNotificationsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutUserInput
    stats?: StatCreateNestedManyWithoutUserInput
    timers?: TimerCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectSettingNotificationsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    stats?: StatUncheckedCreateNestedManyWithoutUserInput
    timers?: TimerUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectSettingNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectSettingNotificationsInput, UserUncheckedCreateWithoutProjectSettingNotificationsInput>
  }

  export type ProjectCreateWithoutProjectSettingNotificationsInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutProjectSettingNotificationsInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectSettingNotificationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectSettingNotificationsInput, ProjectUncheckedCreateWithoutProjectSettingNotificationsInput>
  }

  export type UserUpsertWithoutProjectSettingNotificationsInput = {
    update: XOR<UserUpdateWithoutProjectSettingNotificationsInput, UserUncheckedUpdateWithoutProjectSettingNotificationsInput>
    create: XOR<UserCreateWithoutProjectSettingNotificationsInput, UserUncheckedCreateWithoutProjectSettingNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectSettingNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectSettingNotificationsInput, UserUncheckedUpdateWithoutProjectSettingNotificationsInput>
  }

  export type UserUpdateWithoutProjectSettingNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutUserNestedInput
    stats?: StatUpdateManyWithoutUserNestedInput
    timers?: TimerUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectSettingNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    stats?: StatUncheckedUpdateManyWithoutUserNestedInput
    timers?: TimerUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutProjectSettingNotificationsInput = {
    update: XOR<ProjectUpdateWithoutProjectSettingNotificationsInput, ProjectUncheckedUpdateWithoutProjectSettingNotificationsInput>
    create: XOR<ProjectCreateWithoutProjectSettingNotificationsInput, ProjectUncheckedCreateWithoutProjectSettingNotificationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectSettingNotificationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectSettingNotificationsInput, ProjectUncheckedUpdateWithoutProjectSettingNotificationsInput>
  }

  export type ProjectUpdateWithoutProjectSettingNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectSettingNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskChecklistCreateWithoutTaskInput = {
    id?: string
    title: string
    order: number
    done?: boolean | null
    doneAt?: Date | string | null
  }

  export type TaskChecklistUncheckedCreateWithoutTaskInput = {
    id?: string
    title: string
    order: number
    done?: boolean | null
    doneAt?: Date | string | null
  }

  export type TaskChecklistCreateOrConnectWithoutTaskInput = {
    where: TaskChecklistWhereUniqueInput
    create: XOR<TaskChecklistCreateWithoutTaskInput, TaskChecklistUncheckedCreateWithoutTaskInput>
  }

  export type TaskChecklistCreateManyTaskInputEnvelope = {
    data: TaskChecklistCreateManyTaskInput | TaskChecklistCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutTaskInput = {
    id?: string
    projectId: string
    content: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutTaskInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentCreateManyTaskInputEnvelope = {
    data: CommentCreateManyTaskInput | CommentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TimerCreateWithoutTaskInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTimersInput
  }

  export type TimerUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimerCreateOrConnectWithoutTaskInput = {
    where: TimerWhereUniqueInput
    create: XOR<TimerCreateWithoutTaskInput, TimerUncheckedCreateWithoutTaskInput>
  }

  export type TimerCreateManyTaskInputEnvelope = {
    data: TimerCreateManyTaskInput | TimerCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskTagCreateWithoutTaskInput = {
    tag: TagCreateNestedOneWithoutTaskTagsInput
  }

  export type TaskTagUncheckedCreateWithoutTaskInput = {
    tagId: string
  }

  export type TaskTagCreateOrConnectWithoutTaskInput = {
    where: TaskTagWhereUniqueInput
    create: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput>
  }

  export type TaskTagCreateManyTaskInputEnvelope = {
    data: TaskTagCreateManyTaskInput | TaskTagCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssigneeCreateWithoutTaskInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutTaskAssigneesInput
  }

  export type TaskAssigneeUncheckedCreateWithoutTaskInput = {
    userId: string
    assignedAt?: Date | string
  }

  export type TaskAssigneeCreateOrConnectWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssigneeCreateManyTaskInputEnvelope = {
    data: TaskAssigneeCreateManyTaskInput | TaskAssigneeCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type FileStorageCreateWithoutTaskInput = {
    id?: string
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    organization?: OrganizationCreateNestedOneWithoutFileStoragesInput
    project?: ProjectCreateNestedOneWithoutFileStoragesInput
  }

  export type FileStorageUncheckedCreateWithoutTaskInput = {
    id?: string
    organizationId?: string | null
    projectId?: string | null
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type FileStorageCreateOrConnectWithoutTaskInput = {
    where: FileStorageWhereUniqueInput
    create: XOR<FileStorageCreateWithoutTaskInput, FileStorageUncheckedCreateWithoutTaskInput>
  }

  export type FileStorageCreateManyTaskInputEnvelope = {
    data: FileStorageCreateManyTaskInput | FileStorageCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutSubTasksInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutSubTasksInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutSubTasksInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSubTasksInput, TaskUncheckedCreateWithoutSubTasksInput>
  }

  export type TaskCreateWithoutParentTaskInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutParentTaskInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskCreateOrConnectWithoutParentTaskInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput>
  }

  export type TaskCreateManyParentTaskInputEnvelope = {
    data: TaskCreateManyParentTaskInput | TaskCreateManyParentTaskInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type TaskStatusCreateWithoutTasksInput = {
    id?: string
    name: string
    color: string
    order: number
    type?: $Enums.StatusType
    project: ProjectCreateNestedOneWithoutTaskStatusesInput
  }

  export type TaskStatusUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    color: string
    order: number
    projectId: string
    type?: $Enums.StatusType
  }

  export type TaskStatusCreateOrConnectWithoutTasksInput = {
    where: TaskStatusWhereUniqueInput
    create: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
  }

  export type TaskChecklistUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskChecklistWhereUniqueInput
    update: XOR<TaskChecklistUpdateWithoutTaskInput, TaskChecklistUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskChecklistCreateWithoutTaskInput, TaskChecklistUncheckedCreateWithoutTaskInput>
  }

  export type TaskChecklistUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskChecklistWhereUniqueInput
    data: XOR<TaskChecklistUpdateWithoutTaskInput, TaskChecklistUncheckedUpdateWithoutTaskInput>
  }

  export type TaskChecklistUpdateManyWithWhereWithoutTaskInput = {
    where: TaskChecklistScalarWhereInput
    data: XOR<TaskChecklistUpdateManyMutationInput, TaskChecklistUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskChecklistScalarWhereInput = {
    AND?: TaskChecklistScalarWhereInput | TaskChecklistScalarWhereInput[]
    OR?: TaskChecklistScalarWhereInput[]
    NOT?: TaskChecklistScalarWhereInput | TaskChecklistScalarWhereInput[]
    id?: UuidFilter<"TaskChecklist"> | string
    title?: StringFilter<"TaskChecklist"> | string
    order?: IntFilter<"TaskChecklist"> | number
    taskId?: UuidFilter<"TaskChecklist"> | string
    done?: BoolNullableFilter<"TaskChecklist"> | boolean | null
    doneAt?: DateTimeNullableFilter<"TaskChecklist"> | Date | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
  }

  export type CommentUpdateManyWithWhereWithoutTaskInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TimerUpsertWithWhereUniqueWithoutTaskInput = {
    where: TimerWhereUniqueInput
    update: XOR<TimerUpdateWithoutTaskInput, TimerUncheckedUpdateWithoutTaskInput>
    create: XOR<TimerCreateWithoutTaskInput, TimerUncheckedCreateWithoutTaskInput>
  }

  export type TimerUpdateWithWhereUniqueWithoutTaskInput = {
    where: TimerWhereUniqueInput
    data: XOR<TimerUpdateWithoutTaskInput, TimerUncheckedUpdateWithoutTaskInput>
  }

  export type TimerUpdateManyWithWhereWithoutTaskInput = {
    where: TimerScalarWhereInput
    data: XOR<TimerUpdateManyMutationInput, TimerUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskTagUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskTagWhereUniqueInput
    update: XOR<TaskTagUpdateWithoutTaskInput, TaskTagUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput>
  }

  export type TaskTagUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskTagWhereUniqueInput
    data: XOR<TaskTagUpdateWithoutTaskInput, TaskTagUncheckedUpdateWithoutTaskInput>
  }

  export type TaskTagUpdateManyWithWhereWithoutTaskInput = {
    where: TaskTagScalarWhereInput
    data: XOR<TaskTagUpdateManyMutationInput, TaskTagUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskTagScalarWhereInput = {
    AND?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
    OR?: TaskTagScalarWhereInput[]
    NOT?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
    taskId?: UuidFilter<"TaskTag"> | string
    tagId?: UuidFilter<"TaskTag"> | string
  }

  export type TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    update: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    data: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAssigneeUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAssigneeScalarWhereInput
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyWithoutTaskInput>
  }

  export type FileStorageUpsertWithWhereUniqueWithoutTaskInput = {
    where: FileStorageWhereUniqueInput
    update: XOR<FileStorageUpdateWithoutTaskInput, FileStorageUncheckedUpdateWithoutTaskInput>
    create: XOR<FileStorageCreateWithoutTaskInput, FileStorageUncheckedCreateWithoutTaskInput>
  }

  export type FileStorageUpdateWithWhereUniqueWithoutTaskInput = {
    where: FileStorageWhereUniqueInput
    data: XOR<FileStorageUpdateWithoutTaskInput, FileStorageUncheckedUpdateWithoutTaskInput>
  }

  export type FileStorageUpdateManyWithWhereWithoutTaskInput = {
    where: FileStorageScalarWhereInput
    data: XOR<FileStorageUpdateManyMutationInput, FileStorageUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskUpsertWithoutSubTasksInput = {
    update: XOR<TaskUpdateWithoutSubTasksInput, TaskUncheckedUpdateWithoutSubTasksInput>
    create: XOR<TaskCreateWithoutSubTasksInput, TaskUncheckedCreateWithoutSubTasksInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutSubTasksInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutSubTasksInput, TaskUncheckedUpdateWithoutSubTasksInput>
  }

  export type TaskUpdateWithoutSubTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutSubTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutParentTaskInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutParentTaskInput, TaskUncheckedUpdateWithoutParentTaskInput>
    create: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutParentTaskInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutParentTaskInput, TaskUncheckedUpdateWithoutParentTaskInput>
  }

  export type TaskUpdateManyWithWhereWithoutParentTaskInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutParentTaskInput>
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskStatusUpsertWithoutTasksInput = {
    update: XOR<TaskStatusUpdateWithoutTasksInput, TaskStatusUncheckedUpdateWithoutTasksInput>
    create: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
    where?: TaskStatusWhereInput
  }

  export type TaskStatusUpdateToOneWithWhereWithoutTasksInput = {
    where?: TaskStatusWhereInput
    data: XOR<TaskStatusUpdateWithoutTasksInput, TaskStatusUncheckedUpdateWithoutTasksInput>
  }

  export type TaskStatusUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    project?: ProjectUpdateOneRequiredWithoutTaskStatusesNestedInput
  }

  export type TaskStatusUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type TaskCreateWithoutTaskStatusInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    project: ProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutTaskStatusInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskCreateOrConnectWithoutTaskStatusInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput>
  }

  export type TaskCreateManyTaskStatusInputEnvelope = {
    data: TaskCreateManyTaskStatusInput | TaskCreateManyTaskStatusInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutTaskStatusesInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutTaskStatusesInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTaskStatusesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTaskStatusesInput, ProjectUncheckedCreateWithoutTaskStatusesInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutTaskStatusInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutTaskStatusInput, TaskUncheckedUpdateWithoutTaskStatusInput>
    create: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutTaskStatusInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutTaskStatusInput, TaskUncheckedUpdateWithoutTaskStatusInput>
  }

  export type TaskUpdateManyWithWhereWithoutTaskStatusInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTaskStatusInput>
  }

  export type ProjectUpsertWithoutTaskStatusesInput = {
    update: XOR<ProjectUpdateWithoutTaskStatusesInput, ProjectUncheckedUpdateWithoutTaskStatusesInput>
    create: XOR<ProjectCreateWithoutTaskStatusesInput, ProjectUncheckedCreateWithoutTaskStatusesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTaskStatusesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTaskStatusesInput, ProjectUncheckedUpdateWithoutTaskStatusesInput>
  }

  export type ProjectUpdateWithoutTaskStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTaskStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskCreateWithoutTaskAssigneesInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutTaskAssigneesInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskCreateOrConnectWithoutTaskAssigneesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskAssigneesInput, TaskUncheckedCreateWithoutTaskAssigneesInput>
  }

  export type UserCreateWithoutTaskAssigneesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutUserInput
    stats?: StatCreateNestedManyWithoutUserInput
    timers?: TimerCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaskAssigneesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutUserInput
    stats?: StatUncheckedCreateNestedManyWithoutUserInput
    timers?: TimerUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaskAssigneesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskAssigneesInput, UserUncheckedCreateWithoutTaskAssigneesInput>
  }

  export type TaskUpsertWithoutTaskAssigneesInput = {
    update: XOR<TaskUpdateWithoutTaskAssigneesInput, TaskUncheckedUpdateWithoutTaskAssigneesInput>
    create: XOR<TaskCreateWithoutTaskAssigneesInput, TaskUncheckedCreateWithoutTaskAssigneesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTaskAssigneesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTaskAssigneesInput, TaskUncheckedUpdateWithoutTaskAssigneesInput>
  }

  export type TaskUpdateWithoutTaskAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type UserUpsertWithoutTaskAssigneesInput = {
    update: XOR<UserUpdateWithoutTaskAssigneesInput, UserUncheckedUpdateWithoutTaskAssigneesInput>
    create: XOR<UserCreateWithoutTaskAssigneesInput, UserUncheckedCreateWithoutTaskAssigneesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskAssigneesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskAssigneesInput, UserUncheckedUpdateWithoutTaskAssigneesInput>
  }

  export type UserUpdateWithoutTaskAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutUserNestedInput
    stats?: StatUpdateManyWithoutUserNestedInput
    timers?: TimerUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutUserNestedInput
    stats?: StatUncheckedUpdateManyWithoutUserNestedInput
    timers?: TimerUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskCreateWithoutTaskChecklistsInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    comments?: CommentCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutTaskChecklistsInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskCreateOrConnectWithoutTaskChecklistsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskChecklistsInput, TaskUncheckedCreateWithoutTaskChecklistsInput>
  }

  export type TaskUpsertWithoutTaskChecklistsInput = {
    update: XOR<TaskUpdateWithoutTaskChecklistsInput, TaskUncheckedUpdateWithoutTaskChecklistsInput>
    create: XOR<TaskCreateWithoutTaskChecklistsInput, TaskUncheckedCreateWithoutTaskChecklistsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTaskChecklistsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTaskChecklistsInput, TaskUncheckedUpdateWithoutTaskChecklistsInput>
  }

  export type TaskUpdateWithoutTaskChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type ProjectCreateWithoutTaskPointsInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutTaskPointsInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTaskPointsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTaskPointsInput, ProjectUncheckedCreateWithoutTaskPointsInput>
  }

  export type ProjectUpsertWithoutTaskPointsInput = {
    update: XOR<ProjectUpdateWithoutTaskPointsInput, ProjectUncheckedUpdateWithoutTaskPointsInput>
    create: XOR<ProjectCreateWithoutTaskPointsInput, ProjectUncheckedCreateWithoutTaskPointsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTaskPointsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTaskPointsInput, ProjectUncheckedUpdateWithoutTaskPointsInput>
  }

  export type ProjectUpdateWithoutTaskPointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTaskPointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationCreateWithoutTaskAutomationsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    visions?: VisionCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageCreateNestedManyWithoutOrganizationInput
    stats?: StatCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTaskAutomationsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    visions?: VisionUncheckedCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutOrganizationInput
    stats?: StatUncheckedCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTaskAutomationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTaskAutomationsInput, OrganizationUncheckedCreateWithoutTaskAutomationsInput>
  }

  export type ProjectCreateWithoutTaskAutomationsInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutTaskAutomationsInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTaskAutomationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTaskAutomationsInput, ProjectUncheckedCreateWithoutTaskAutomationsInput>
  }

  export type OrganizationUpsertWithoutTaskAutomationsInput = {
    update: XOR<OrganizationUpdateWithoutTaskAutomationsInput, OrganizationUncheckedUpdateWithoutTaskAutomationsInput>
    create: XOR<OrganizationCreateWithoutTaskAutomationsInput, OrganizationUncheckedCreateWithoutTaskAutomationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTaskAutomationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTaskAutomationsInput, OrganizationUncheckedUpdateWithoutTaskAutomationsInput>
  }

  export type OrganizationUpdateWithoutTaskAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUpdateManyWithoutOrganizationNestedInput
    stats?: StatUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTaskAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput
    stats?: StatUncheckedUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectUpsertWithoutTaskAutomationsInput = {
    update: XOR<ProjectUpdateWithoutTaskAutomationsInput, ProjectUncheckedUpdateWithoutTaskAutomationsInput>
    create: XOR<ProjectCreateWithoutTaskAutomationsInput, ProjectUncheckedCreateWithoutTaskAutomationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTaskAutomationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTaskAutomationsInput, ProjectUncheckedUpdateWithoutTaskAutomationsInput>
  }

  export type ProjectUpdateWithoutTaskAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTaskAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutVisionInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutVisionInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutVisionInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutVisionInput, ProjectUncheckedCreateWithoutVisionInput>
  }

  export type OrganizationCreateWithoutVisionsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageCreateNestedManyWithoutOrganizationInput
    stats?: StatCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutVisionsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutOrganizationInput
    stats?: StatUncheckedCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutVisionsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutVisionsInput, OrganizationUncheckedCreateWithoutVisionsInput>
  }

  export type VisionCreateWithoutChildrenInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project?: ProjectCreateNestedOneWithoutVisionInput
    organization?: OrganizationCreateNestedOneWithoutVisionsInput
    parent?: VisionCreateNestedOneWithoutChildrenInput
  }

  export type VisionUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    projectId?: string | null
    organizationId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type VisionCreateOrConnectWithoutChildrenInput = {
    where: VisionWhereUniqueInput
    create: XOR<VisionCreateWithoutChildrenInput, VisionUncheckedCreateWithoutChildrenInput>
  }

  export type VisionCreateWithoutParentInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    project?: ProjectCreateNestedOneWithoutVisionInput
    organization?: OrganizationCreateNestedOneWithoutVisionsInput
    children?: VisionCreateNestedManyWithoutParentInput
  }

  export type VisionUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    projectId?: string | null
    organizationId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    children?: VisionUncheckedCreateNestedManyWithoutParentInput
  }

  export type VisionCreateOrConnectWithoutParentInput = {
    where: VisionWhereUniqueInput
    create: XOR<VisionCreateWithoutParentInput, VisionUncheckedCreateWithoutParentInput>
  }

  export type VisionCreateManyParentInputEnvelope = {
    data: VisionCreateManyParentInput | VisionCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutVisionInput = {
    update: XOR<ProjectUpdateWithoutVisionInput, ProjectUncheckedUpdateWithoutVisionInput>
    create: XOR<ProjectCreateWithoutVisionInput, ProjectUncheckedCreateWithoutVisionInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutVisionInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutVisionInput, ProjectUncheckedUpdateWithoutVisionInput>
  }

  export type ProjectUpdateWithoutVisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutVisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationUpsertWithoutVisionsInput = {
    update: XOR<OrganizationUpdateWithoutVisionsInput, OrganizationUncheckedUpdateWithoutVisionsInput>
    create: XOR<OrganizationCreateWithoutVisionsInput, OrganizationUncheckedCreateWithoutVisionsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutVisionsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutVisionsInput, OrganizationUncheckedUpdateWithoutVisionsInput>
  }

  export type OrganizationUpdateWithoutVisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUpdateManyWithoutOrganizationNestedInput
    stats?: StatUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutVisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput
    stats?: StatUncheckedUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type VisionUpsertWithoutChildrenInput = {
    update: XOR<VisionUpdateWithoutChildrenInput, VisionUncheckedUpdateWithoutChildrenInput>
    create: XOR<VisionCreateWithoutChildrenInput, VisionUncheckedCreateWithoutChildrenInput>
    where?: VisionWhereInput
  }

  export type VisionUpdateToOneWithWhereWithoutChildrenInput = {
    where?: VisionWhereInput
    data: XOR<VisionUpdateWithoutChildrenInput, VisionUncheckedUpdateWithoutChildrenInput>
  }

  export type VisionUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutVisionNestedInput
    organization?: OrganizationUpdateOneWithoutVisionsNestedInput
    parent?: VisionUpdateOneWithoutChildrenNestedInput
  }

  export type VisionUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisionUpsertWithWhereUniqueWithoutParentInput = {
    where: VisionWhereUniqueInput
    update: XOR<VisionUpdateWithoutParentInput, VisionUncheckedUpdateWithoutParentInput>
    create: XOR<VisionCreateWithoutParentInput, VisionUncheckedCreateWithoutParentInput>
  }

  export type VisionUpdateWithWhereUniqueWithoutParentInput = {
    where: VisionWhereUniqueInput
    data: XOR<VisionUpdateWithoutParentInput, VisionUncheckedUpdateWithoutParentInput>
  }

  export type VisionUpdateManyWithWhereWithoutParentInput = {
    where: VisionScalarWhereInput
    data: XOR<VisionUpdateManyMutationInput, VisionUncheckedUpdateManyWithoutParentInput>
  }

  export type ProjectCreateWithoutFieldInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutFieldInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFieldInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFieldInput, ProjectUncheckedCreateWithoutFieldInput>
  }

  export type ProjectUpsertWithoutFieldInput = {
    update: XOR<ProjectUpdateWithoutFieldInput, ProjectUncheckedUpdateWithoutFieldInput>
    create: XOR<ProjectCreateWithoutFieldInput, ProjectUncheckedCreateWithoutFieldInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutFieldInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutFieldInput, ProjectUncheckedUpdateWithoutFieldInput>
  }

  export type ProjectUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutGridInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutGridInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutGridInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutGridInput, ProjectUncheckedCreateWithoutGridInput>
  }

  export type ProjectUpsertWithoutGridInput = {
    update: XOR<ProjectUpdateWithoutGridInput, ProjectUncheckedUpdateWithoutGridInput>
    create: XOR<ProjectCreateWithoutGridInput, ProjectUncheckedCreateWithoutGridInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutGridInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutGridInput, ProjectUncheckedUpdateWithoutGridInput>
  }

  export type ProjectUpdateWithoutGridInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutGridInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskTagCreateWithoutTagInput = {
    task: TaskCreateNestedOneWithoutTaskTagsInput
  }

  export type TaskTagUncheckedCreateWithoutTagInput = {
    taskId: string
  }

  export type TaskTagCreateOrConnectWithoutTagInput = {
    where: TaskTagWhereUniqueInput
    create: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput>
  }

  export type TaskTagCreateManyTagInputEnvelope = {
    data: TaskTagCreateManyTagInput | TaskTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutTagsInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTagsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
  }

  export type TaskTagUpsertWithWhereUniqueWithoutTagInput = {
    where: TaskTagWhereUniqueInput
    update: XOR<TaskTagUpdateWithoutTagInput, TaskTagUncheckedUpdateWithoutTagInput>
    create: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput>
  }

  export type TaskTagUpdateWithWhereUniqueWithoutTagInput = {
    where: TaskTagWhereUniqueInput
    data: XOR<TaskTagUpdateWithoutTagInput, TaskTagUncheckedUpdateWithoutTagInput>
  }

  export type TaskTagUpdateManyWithWhereWithoutTagInput = {
    where: TaskTagScalarWhereInput
    data: XOR<TaskTagUpdateManyMutationInput, TaskTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ProjectUpsertWithoutTagsInput = {
    update: XOR<ProjectUpdateWithoutTagsInput, ProjectUncheckedUpdateWithoutTagsInput>
    create: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTagsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTagsInput, ProjectUncheckedUpdateWithoutTagsInput>
  }

  export type ProjectUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskCreateWithoutTaskTagsInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutTaskTagsInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskCreateOrConnectWithoutTaskTagsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskTagsInput, TaskUncheckedCreateWithoutTaskTagsInput>
  }

  export type TagCreateWithoutTaskTagsInput = {
    id?: string
    name: string
    color: string
    project: ProjectCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutTaskTagsInput = {
    id?: string
    name: string
    color: string
    projectId: string
  }

  export type TagCreateOrConnectWithoutTaskTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTaskTagsInput, TagUncheckedCreateWithoutTaskTagsInput>
  }

  export type TaskUpsertWithoutTaskTagsInput = {
    update: XOR<TaskUpdateWithoutTaskTagsInput, TaskUncheckedUpdateWithoutTaskTagsInput>
    create: XOR<TaskCreateWithoutTaskTagsInput, TaskUncheckedCreateWithoutTaskTagsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTaskTagsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTaskTagsInput, TaskUncheckedUpdateWithoutTaskTagsInput>
  }

  export type TaskUpdateWithoutTaskTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type TagUpsertWithoutTaskTagsInput = {
    update: XOR<TagUpdateWithoutTaskTagsInput, TagUncheckedUpdateWithoutTaskTagsInput>
    create: XOR<TagCreateWithoutTaskTagsInput, TagUncheckedCreateWithoutTaskTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutTaskTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutTaskTagsInput, TagUncheckedUpdateWithoutTaskTagsInput>
  }

  export type TagUpdateWithoutTaskTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutTaskTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateWithoutSchedulersInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutSchedulersInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSchedulersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSchedulersInput, ProjectUncheckedCreateWithoutSchedulersInput>
  }

  export type OrganizationCreateWithoutSchedulersInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    visions?: VisionCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageCreateNestedManyWithoutOrganizationInput
    stats?: StatCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSchedulersInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    visions?: VisionUncheckedCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutOrganizationInput
    stats?: StatUncheckedCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSchedulersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSchedulersInput, OrganizationUncheckedCreateWithoutSchedulersInput>
  }

  export type ProjectUpsertWithoutSchedulersInput = {
    update: XOR<ProjectUpdateWithoutSchedulersInput, ProjectUncheckedUpdateWithoutSchedulersInput>
    create: XOR<ProjectCreateWithoutSchedulersInput, ProjectUncheckedCreateWithoutSchedulersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSchedulersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSchedulersInput, ProjectUncheckedUpdateWithoutSchedulersInput>
  }

  export type ProjectUpdateWithoutSchedulersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSchedulersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationUpsertWithoutSchedulersInput = {
    update: XOR<OrganizationUpdateWithoutSchedulersInput, OrganizationUncheckedUpdateWithoutSchedulersInput>
    create: XOR<OrganizationCreateWithoutSchedulersInput, OrganizationUncheckedCreateWithoutSchedulersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSchedulersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSchedulersInput, OrganizationUncheckedUpdateWithoutSchedulersInput>
  }

  export type OrganizationUpdateWithoutSchedulersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUpdateManyWithoutOrganizationNestedInput
    stats?: StatUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSchedulersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput
    stats?: StatUncheckedUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutFileStoragesInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    visions?: VisionCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerCreateNestedManyWithoutOrganizationInput
    stats?: StatCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutFileStoragesInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    visions?: VisionUncheckedCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutOrganizationInput
    stats?: StatUncheckedCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutFileStoragesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutFileStoragesInput, OrganizationUncheckedCreateWithoutFileStoragesInput>
  }

  export type ProjectCreateWithoutFileStoragesInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutFileStoragesInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFileStoragesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFileStoragesInput, ProjectUncheckedCreateWithoutFileStoragesInput>
  }

  export type TaskCreateWithoutFileStoragesInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutFileStoragesInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskCreateOrConnectWithoutFileStoragesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutFileStoragesInput, TaskUncheckedCreateWithoutFileStoragesInput>
  }

  export type OrganizationUpsertWithoutFileStoragesInput = {
    update: XOR<OrganizationUpdateWithoutFileStoragesInput, OrganizationUncheckedUpdateWithoutFileStoragesInput>
    create: XOR<OrganizationCreateWithoutFileStoragesInput, OrganizationUncheckedCreateWithoutFileStoragesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutFileStoragesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutFileStoragesInput, OrganizationUncheckedUpdateWithoutFileStoragesInput>
  }

  export type OrganizationUpdateWithoutFileStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUpdateManyWithoutOrganizationNestedInput
    stats?: StatUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutFileStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput
    stats?: StatUncheckedUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectUpsertWithoutFileStoragesInput = {
    update: XOR<ProjectUpdateWithoutFileStoragesInput, ProjectUncheckedUpdateWithoutFileStoragesInput>
    create: XOR<ProjectCreateWithoutFileStoragesInput, ProjectUncheckedCreateWithoutFileStoragesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutFileStoragesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutFileStoragesInput, ProjectUncheckedUpdateWithoutFileStoragesInput>
  }

  export type ProjectUpdateWithoutFileStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFileStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithoutFileStoragesInput = {
    update: XOR<TaskUpdateWithoutFileStoragesInput, TaskUncheckedUpdateWithoutFileStoragesInput>
    create: XOR<TaskCreateWithoutFileStoragesInput, TaskUncheckedCreateWithoutFileStoragesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutFileStoragesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutFileStoragesInput, TaskUncheckedUpdateWithoutFileStoragesInput>
  }

  export type TaskUpdateWithoutFileStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutFileStoragesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type UserCreateWithoutStatsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutUserInput
    timers?: TimerCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStatsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutUserInput
    timers?: TimerUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
  }

  export type ProjectCreateWithoutStatsInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutStatsInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutStatsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutStatsInput, ProjectUncheckedCreateWithoutStatsInput>
  }

  export type OrganizationCreateWithoutStatsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    visions?: VisionCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutStatsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    visions?: VisionUncheckedCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutStatsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutStatsInput, OrganizationUncheckedCreateWithoutStatsInput>
  }

  export type UserUpsertWithoutStatsInput = {
    update: XOR<UserUpdateWithoutStatsInput, UserUncheckedUpdateWithoutStatsInput>
    create: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatsInput, UserUncheckedUpdateWithoutStatsInput>
  }

  export type UserUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutUserNestedInput
    timers?: TimerUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutUserNestedInput
    timers?: TimerUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutStatsInput = {
    update: XOR<ProjectUpdateWithoutStatsInput, ProjectUncheckedUpdateWithoutStatsInput>
    create: XOR<ProjectCreateWithoutStatsInput, ProjectUncheckedCreateWithoutStatsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutStatsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutStatsInput, ProjectUncheckedUpdateWithoutStatsInput>
  }

  export type ProjectUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationUpsertWithoutStatsInput = {
    update: XOR<OrganizationUpdateWithoutStatsInput, OrganizationUncheckedUpdateWithoutStatsInput>
    create: XOR<OrganizationCreateWithoutStatsInput, OrganizationUncheckedCreateWithoutStatsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutStatsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutStatsInput, OrganizationUncheckedUpdateWithoutStatsInput>
  }

  export type OrganizationUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type DashboardComponentCreateWithoutDashboardInput = {
    id?: string
    title?: string | null
    type?: $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type DashboardComponentUncheckedCreateWithoutDashboardInput = {
    id?: string
    title?: string | null
    type?: $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type DashboardComponentCreateOrConnectWithoutDashboardInput = {
    where: DashboardComponentWhereUniqueInput
    create: XOR<DashboardComponentCreateWithoutDashboardInput, DashboardComponentUncheckedCreateWithoutDashboardInput>
  }

  export type DashboardComponentCreateManyDashboardInputEnvelope = {
    data: DashboardComponentCreateManyDashboardInput | DashboardComponentCreateManyDashboardInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutDashboardInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutDashboardInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDashboardInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDashboardInput, ProjectUncheckedCreateWithoutDashboardInput>
  }

  export type DashboardComponentUpsertWithWhereUniqueWithoutDashboardInput = {
    where: DashboardComponentWhereUniqueInput
    update: XOR<DashboardComponentUpdateWithoutDashboardInput, DashboardComponentUncheckedUpdateWithoutDashboardInput>
    create: XOR<DashboardComponentCreateWithoutDashboardInput, DashboardComponentUncheckedCreateWithoutDashboardInput>
  }

  export type DashboardComponentUpdateWithWhereUniqueWithoutDashboardInput = {
    where: DashboardComponentWhereUniqueInput
    data: XOR<DashboardComponentUpdateWithoutDashboardInput, DashboardComponentUncheckedUpdateWithoutDashboardInput>
  }

  export type DashboardComponentUpdateManyWithWhereWithoutDashboardInput = {
    where: DashboardComponentScalarWhereInput
    data: XOR<DashboardComponentUpdateManyMutationInput, DashboardComponentUncheckedUpdateManyWithoutDashboardInput>
  }

  export type DashboardComponentScalarWhereInput = {
    AND?: DashboardComponentScalarWhereInput | DashboardComponentScalarWhereInput[]
    OR?: DashboardComponentScalarWhereInput[]
    NOT?: DashboardComponentScalarWhereInput | DashboardComponentScalarWhereInput[]
    id?: UuidFilter<"DashboardComponent"> | string
    dashboardId?: UuidNullableFilter<"DashboardComponent"> | string | null
    title?: StringNullableFilter<"DashboardComponent"> | string | null
    type?: EnumDashboardComponentTypeNullableFilter<"DashboardComponent"> | $Enums.DashboardComponentType | null
    config?: JsonNullableFilter<"DashboardComponent">
    x?: IntNullableFilter<"DashboardComponent"> | number | null
    y?: IntNullableFilter<"DashboardComponent"> | number | null
    width?: IntNullableFilter<"DashboardComponent"> | number | null
    height?: IntNullableFilter<"DashboardComponent"> | number | null
    createdAt?: DateTimeFilter<"DashboardComponent"> | Date | string
    createdBy?: StringNullableFilter<"DashboardComponent"> | string | null
    deletedAt?: DateTimeNullableFilter<"DashboardComponent"> | Date | string | null
    deletedBy?: StringNullableFilter<"DashboardComponent"> | string | null
  }

  export type ProjectUpsertWithoutDashboardInput = {
    update: XOR<ProjectUpdateWithoutDashboardInput, ProjectUncheckedUpdateWithoutDashboardInput>
    create: XOR<ProjectCreateWithoutDashboardInput, ProjectUncheckedCreateWithoutDashboardInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDashboardInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDashboardInput, ProjectUncheckedUpdateWithoutDashboardInput>
  }

  export type ProjectUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DashboardCreateWithoutDashboardComponentsInput = {
    id?: string
    title?: string | null
    isDefault?: boolean | null
    project?: ProjectCreateNestedOneWithoutDashboardInput
  }

  export type DashboardUncheckedCreateWithoutDashboardComponentsInput = {
    id?: string
    title?: string | null
    projectId?: string | null
    isDefault?: boolean | null
  }

  export type DashboardCreateOrConnectWithoutDashboardComponentsInput = {
    where: DashboardWhereUniqueInput
    create: XOR<DashboardCreateWithoutDashboardComponentsInput, DashboardUncheckedCreateWithoutDashboardComponentsInput>
  }

  export type DashboardUpsertWithoutDashboardComponentsInput = {
    update: XOR<DashboardUpdateWithoutDashboardComponentsInput, DashboardUncheckedUpdateWithoutDashboardComponentsInput>
    create: XOR<DashboardCreateWithoutDashboardComponentsInput, DashboardUncheckedCreateWithoutDashboardComponentsInput>
    where?: DashboardWhereInput
  }

  export type DashboardUpdateToOneWithWhereWithoutDashboardComponentsInput = {
    where?: DashboardWhereInput
    data: XOR<DashboardUpdateWithoutDashboardComponentsInput, DashboardUncheckedUpdateWithoutDashboardComponentsInput>
  }

  export type DashboardUpdateWithoutDashboardComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    project?: ProjectUpdateOneWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateWithoutDashboardComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TaskCreateWithoutCommentsInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    timers?: TimerCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    timers?: TimerUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskCreateOrConnectWithoutCommentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
  }

  export type ProjectCreateWithoutCommentsInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewCreateNestedOneWithoutProjectInput
    field?: FieldCreateNestedManyWithoutProjectInput
    vision?: VisionCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    grid?: GridCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageCreateNestedManyWithoutProjectInput
    stats?: StatCreateNestedManyWithoutProjectInput
    dashboard?: DashboardCreateNestedManyWithoutProjectInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    organizationId: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    projectView?: ProjectViewUncheckedCreateNestedOneWithoutProjectInput
    field?: FieldUncheckedCreateNestedManyWithoutProjectInput
    vision?: VisionUncheckedCreateNestedManyWithoutProjectInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    grid?: GridUncheckedCreateNestedManyWithoutProjectInput
    taskStatuses?: TaskStatusUncheckedCreateNestedManyWithoutProjectInput
    taskPoints?: TaskPointUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutProjectInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutProjectInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutProjectInput
    stats?: StatUncheckedCreateNestedManyWithoutProjectInput
    dashboard?: DashboardUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCommentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
  }

  export type TaskUpsertWithoutCommentsInput = {
    update: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type ProjectUpsertWithoutCommentsInput = {
    update: XOR<ProjectUpdateWithoutCommentsInput, ProjectUncheckedUpdateWithoutCommentsInput>
    create: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCommentsInput, ProjectUncheckedUpdateWithoutCommentsInput>
  }

  export type ProjectUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrganizationCreateWithoutApplicationsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    visions?: VisionCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageCreateNestedManyWithoutOrganizationInput
    stats?: StatCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutApplicationsInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    visions?: VisionUncheckedCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutOrganizationInput
    stats?: StatUncheckedCreateNestedManyWithoutOrganizationInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutApplicationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutApplicationsInput, OrganizationUncheckedCreateWithoutApplicationsInput>
  }

  export type OrganizationUpsertWithoutApplicationsInput = {
    update: XOR<OrganizationUpdateWithoutApplicationsInput, OrganizationUncheckedUpdateWithoutApplicationsInput>
    create: XOR<OrganizationCreateWithoutApplicationsInput, OrganizationUncheckedCreateWithoutApplicationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutApplicationsInput, OrganizationUncheckedUpdateWithoutApplicationsInput>
  }

  export type OrganizationUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUpdateManyWithoutOrganizationNestedInput
    stats?: StatUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput
    stats?: StatUncheckedUpdateManyWithoutOrganizationNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TaskCreateWithoutTimersInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageCreateNestedManyWithoutTaskInput
    parentTask?: TaskCreateNestedOneWithoutSubTasksInput
    subTasks?: TaskCreateNestedManyWithoutParentTaskInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutTimersInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    taskChecklists?: TaskChecklistUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    taskTags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutTaskInput
    subTasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
  }

  export type TaskCreateOrConnectWithoutTimersInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTimersInput, TaskUncheckedCreateWithoutTimersInput>
  }

  export type UserCreateWithoutTimersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutUserInput
    stats?: StatCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTimersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutUserInput
    stats?: StatUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTimersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimersInput, UserUncheckedCreateWithoutTimersInput>
  }

  export type TaskUpsertWithoutTimersInput = {
    update: XOR<TaskUpdateWithoutTimersInput, TaskUncheckedUpdateWithoutTimersInput>
    create: XOR<TaskCreateWithoutTimersInput, TaskUncheckedCreateWithoutTimersInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTimersInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTimersInput, TaskUncheckedUpdateWithoutTimersInput>
  }

  export type TaskUpdateWithoutTimersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTimersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type UserUpsertWithoutTimersInput = {
    update: XOR<UserUpdateWithoutTimersInput, UserUncheckedUpdateWithoutTimersInput>
    create: XOR<UserCreateWithoutTimersInput, UserUncheckedCreateWithoutTimersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimersInput, UserUncheckedUpdateWithoutTimersInput>
  }

  export type UserUpdateWithoutTimersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutUserNestedInput
    stats?: StatUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTimersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutUserNestedInput
    stats?: StatUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFavoritesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationCreateNestedManyWithoutUserInput
    stats?: StatCreateNestedManyWithoutUserInput
    timers?: TimerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    status?: $Enums.UserStatus | null
    country?: string | null
    bio?: string | null
    photo?: string | null
    dob?: Date | string | null
    resetToken?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    taskAssignees?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedCreateNestedManyWithoutUserInput
    stats?: StatUncheckedCreateNestedManyWithoutUserInput
    timers?: TimerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type OrganizationCreateWithoutFavoritesInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    visions?: VisionCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageCreateNestedManyWithoutOrganizationInput
    stats?: StatCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutFavoritesInput = {
    id?: string
    name: string
    slug: string
    cover?: string | null
    avatar?: string | null
    maxStorageSize?: number | null
    desc?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    visions?: VisionUncheckedCreateNestedManyWithoutOrganizationInput
    organizationMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    taskAutomations?: TaskAutomationUncheckedCreateNestedManyWithoutOrganizationInput
    schedulers?: SchedulerUncheckedCreateNestedManyWithoutOrganizationInput
    fileStorages?: FileStorageUncheckedCreateNestedManyWithoutOrganizationInput
    stats?: StatUncheckedCreateNestedManyWithoutOrganizationInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutFavoritesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutFavoritesInput, OrganizationUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutUserNestedInput
    stats?: StatUpdateManyWithoutUserNestedInput
    timers?: TimerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutUserNestedInput
    stats?: StatUncheckedUpdateManyWithoutUserNestedInput
    timers?: TimerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutFavoritesInput = {
    update: XOR<OrganizationUpdateWithoutFavoritesInput, OrganizationUncheckedUpdateWithoutFavoritesInput>
    create: XOR<OrganizationCreateWithoutFavoritesInput, OrganizationUncheckedCreateWithoutFavoritesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutFavoritesInput, OrganizationUncheckedUpdateWithoutFavoritesInput>
  }

  export type OrganizationUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUpdateManyWithoutOrganizationNestedInput
    stats?: StatUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    maxStorageSize?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    visions?: VisionUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutOrganizationNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutOrganizationNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutOrganizationNestedInput
    stats?: StatUncheckedUpdateManyWithoutOrganizationNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type MemberCreateManyUserInput = {
    id?: string
    role: $Enums.MemberRole
    projectId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationMemberCreateManyUserInput = {
    id?: string
    organizationId: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskAssigneeCreateManyUserInput = {
    taskId: string
    assignedAt?: Date | string
  }

  export type ProjectSettingNotificationCreateManyUserInput = {
    id?: string
    projectId: string
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type StatCreateManyUserInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    projectId?: string | null
    organizationId?: string | null
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
  }

  export type TimerCreateManyUserInput = {
    id?: string
    taskId: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteCreateManyUserInput = {
    id?: string
    name: string
    icon: string
    link: string
    organizationId: string
    type: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type MemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationMembersNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAssigneeUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTaskAssigneesNestedInput
  }

  export type TaskAssigneeUncheckedUpdateWithoutUserInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutUserInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutProjectSettingNotificationsNestedInput
  }

  export type ProjectSettingNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectSettingNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneWithoutStatsNestedInput
    organization?: OrganizationUpdateOneWithoutStatsNestedInput
  }

  export type StatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTimersNestedInput
  }

  export type TimerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateManyOrganizationInput = {
    id?: string
    name: string
    desc?: string | null
    cover?: string | null
    icon?: string | null
    isArchived?: boolean
    countMemberTask?: boolean
    countProjectTask?: boolean
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type VisionCreateManyOrganizationInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    projectId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type OrganizationMemberCreateManyOrganizationInput = {
    id?: string
    userId: string
    status: $Enums.InvitationStatus
    role: $Enums.OrganizationRole
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskAutomationCreateManyOrganizationInput = {
    id?: string
    projectId: string
    when: JsonNullValueInput | InputJsonValue
    then: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SchedulerCreateManyOrganizationInput = {
    id?: string
    projectId: string
    cronId?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type FileStorageCreateManyOrganizationInput = {
    id?: string
    projectId?: string | null
    taskId?: string | null
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type StatCreateManyOrganizationInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    projectId?: string | null
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
  }

  export type ApplicationCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    clientSecret: string
    scopes?: ApplicationCreatescopesInput | string[]
    createdAt?: Date | string | null
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type FavoriteCreateManyOrganizationInput = {
    id?: string
    name: string
    icon: string
    link: string
    userId: string
    type: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ProjectUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUpdateOneWithoutProjectNestedInput
    field?: FieldUpdateManyWithoutProjectNestedInput
    vision?: VisionUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    grid?: GridUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUpdateManyWithoutProjectNestedInput
    stats?: StatUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    projectView?: ProjectViewUncheckedUpdateOneWithoutProjectNestedInput
    field?: FieldUncheckedUpdateManyWithoutProjectNestedInput
    vision?: VisionUncheckedUpdateManyWithoutProjectNestedInput
    projectSettingNotifications?: ProjectSettingNotificationUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    grid?: GridUncheckedUpdateManyWithoutProjectNestedInput
    taskStatuses?: TaskStatusUncheckedUpdateManyWithoutProjectNestedInput
    taskPoints?: TaskPointUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    taskAutomations?: TaskAutomationUncheckedUpdateManyWithoutProjectNestedInput
    schedulers?: SchedulerUncheckedUpdateManyWithoutProjectNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutProjectNestedInput
    stats?: StatUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
    dashboard?: DashboardUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    countMemberTask?: BoolFieldUpdateOperationsInput | boolean
    countProjectTask?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisionUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutVisionNestedInput
    parent?: VisionUpdateOneWithoutChildrenNestedInput
    children?: VisionUpdateManyWithoutParentNestedInput
  }

  export type VisionUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    children?: VisionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type VisionUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationMemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutOrganizationMembersNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAutomationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutTaskAutomationsNestedInput
  }

  export type TaskAutomationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAutomationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchedulerUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutSchedulersNestedInput
  }

  export type SchedulerUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchedulerUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileStorageUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutFileStoragesNestedInput
    task?: TaskUpdateOneWithoutFileStoragesNestedInput
  }

  export type FileStorageUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileStorageUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StatUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutStatsNestedInput
    project?: ProjectUpdateOneWithoutStatsNestedInput
  }

  export type StatUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StatUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApplicationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    scopes?: ApplicationUpdatescopesInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    scopes?: ApplicationUpdatescopesInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    scopes?: ApplicationUpdatescopesInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FavoriteUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FavoriteUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldCreateManyProjectInput = {
    id?: string
    name: string
    type: $Enums.FieldType
    icon?: string | null
    hidden?: boolean
    width: number
    order: number
    desc?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VisionCreateManyProjectInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    organizationId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ProjectSettingNotificationCreateManyProjectInput = {
    id?: string
    userId: string
    taskChanges?: boolean
    remind?: boolean
    overdue?: boolean
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type MemberCreateManyProjectInput = {
    id?: string
    role: $Enums.MemberRole
    userId: string
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type GridCreateManyProjectInput = {
    id?: string
    title: string
    cover?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskStatusCreateManyProjectInput = {
    id?: string
    name: string
    color: string
    order: number
    type?: $Enums.StatusType
  }

  export type TaskPointCreateManyProjectInput = {
    id?: string
    point: number
    icon?: string | null
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TagCreateManyProjectInput = {
    id?: string
    name: string
    color: string
  }

  export type TaskAutomationCreateManyProjectInput = {
    id?: string
    organizationId: string
    when: JsonNullValueInput | InputJsonValue
    then: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SchedulerCreateManyProjectInput = {
    id?: string
    organizationId: string
    cronId?: string | null
    trigger: JsonNullValueInput | InputJsonValue
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type FileStorageCreateManyProjectInput = {
    id?: string
    organizationId?: string | null
    taskId?: string | null
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type StatCreateManyProjectInput = {
    id?: string
    type: $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    organizationId?: string | null
    year: number
    month: number
    date: number
    updatedAt?: Date | string | null
  }

  export type CommentCreateManyProjectInput = {
    id?: string
    taskId: string
    content: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type DashboardCreateManyProjectInput = {
    id?: string
    title?: string | null
    isDefault?: boolean | null
  }

  export type FieldUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    width?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FieldUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    width?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FieldUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    width?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VisionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutVisionsNestedInput
    parent?: VisionUpdateOneWithoutChildrenNestedInput
    children?: VisionUpdateManyWithoutParentNestedInput
  }

  export type VisionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    children?: VisionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type VisionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectSettingNotificationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProjectSettingNotificationsNestedInput
  }

  export type ProjectSettingNotificationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectSettingNotificationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskChanges?: BoolFieldUpdateOperationsInput | boolean
    remind?: BoolFieldUpdateOperationsInput | boolean
    overdue?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GridUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GridUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GridUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskStatusUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    tasks?: TaskUpdateManyWithoutTaskStatusNestedInput
  }

  export type TaskStatusUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    tasks?: TaskUncheckedUpdateManyWithoutTaskStatusNestedInput
  }

  export type TaskStatusUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
  }

  export type TaskPointUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskPointUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskPointUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    taskTags?: TaskTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    taskTags?: TaskTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAutomationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneRequiredWithoutTaskAutomationsNestedInput
  }

  export type TaskAutomationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskAutomationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    when?: JsonNullValueInput | InputJsonValue
    then?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchedulerUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneRequiredWithoutSchedulersNestedInput
  }

  export type SchedulerUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchedulerUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    cronId?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: JsonNullValueInput | InputJsonValue
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileStorageUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutFileStoragesNestedInput
    task?: TaskUpdateOneWithoutFileStoragesNestedInput
  }

  export type FileStorageUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileStorageUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StatUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutStatsNestedInput
    organization?: OrganizationUpdateOneWithoutStatsNestedInput
  }

  export type StatUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StatUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStatTypeFieldUpdateOperationsInput | $Enums.StatType
    data?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dashboardComponents?: DashboardComponentUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dashboardComponents?: DashboardComponentUncheckedUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TaskChecklistCreateManyTaskInput = {
    id?: string
    title: string
    order: number
    done?: boolean | null
    doneAt?: Date | string | null
  }

  export type CommentCreateManyTaskInput = {
    id?: string
    projectId: string
    content: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
  }

  export type TimerCreateManyTaskInput = {
    id?: string
    userId: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskTagCreateManyTaskInput = {
    tagId: string
  }

  export type TaskAssigneeCreateManyTaskInput = {
    userId: string
    assignedAt?: Date | string
  }

  export type FileStorageCreateManyTaskInput = {
    id?: string
    organizationId?: string | null
    projectId?: string | null
    name: string
    keyName: string
    type: $Enums.FileType
    url?: string | null
    size?: number | null
    mimeType?: string | null
    parentId?: string | null
    owner?: string | null
    ownerType?: $Enums.FileOwnerType | null
    isDeleted?: boolean | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TaskCreateManyParentTaskInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    taskStatusId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskChecklistUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    done?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskChecklistUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    done?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskChecklistUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    done?: NullableBoolFieldUpdateOperationsInput | boolean | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimerUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTimersNestedInput
  }

  export type TimerUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimerUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTagUpdateWithoutTaskInput = {
    tag?: TagUpdateOneRequiredWithoutTaskTagsNestedInput
  }

  export type TaskTagUncheckedUpdateWithoutTaskInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskTagUncheckedUpdateManyWithoutTaskInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssigneeUpdateWithoutTaskInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskAssigneesNestedInput
  }

  export type TaskAssigneeUncheckedUpdateWithoutTaskInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileStorageUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: OrganizationUpdateOneWithoutFileStoragesNestedInput
    project?: ProjectUpdateOneWithoutFileStoragesNestedInput
  }

  export type FileStorageUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileStorageUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    keyName?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    url?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerType?: NullableEnumFileOwnerTypeFieldUpdateOperationsInput | $Enums.FileOwnerType | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutParentTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutParentTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutParentTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    taskStatusId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyTaskStatusInput = {
    id?: string
    title: string
    desc?: string | null
    dueDate?: Date | string | null
    order: number
    type?: $Enums.TaskType | null
    checklistDone?: number | null
    checklistTodos?: number | null
    cover?: string | null
    plannedStartDate?: Date | string | null
    plannedDueDate?: Date | string | null
    startDate?: Date | string | null
    projectId: string
    priority?: $Enums.TaskPriority | null
    parentTaskId?: string | null
    progress?: number | null
    done?: boolean
    taskPoint?: number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type TaskUpdateWithoutTaskStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timers?: TimerUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUpdateManyWithoutTaskNestedInput
    parentTask?: TaskUpdateOneWithoutSubTasksNestedInput
    subTasks?: TaskUpdateManyWithoutParentTaskNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    taskChecklists?: TaskChecklistUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timers?: TimerUncheckedUpdateManyWithoutTaskNestedInput
    taskTags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    taskAssignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    fileStorages?: FileStorageUncheckedUpdateManyWithoutTaskNestedInput
    subTasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutTaskStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType | null
    checklistDone?: NullableIntFieldUpdateOperationsInput | number | null
    checklistTodos?: NullableIntFieldUpdateOperationsInput | number | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    plannedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    priority?: NullableEnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority | null
    parentTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
    taskPoint?: NullableIntFieldUpdateOperationsInput | number | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisionCreateManyParentInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    progress?: number | null
    projectId?: string | null
    organizationId?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type VisionUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutVisionNestedInput
    organization?: OrganizationUpdateOneWithoutVisionsNestedInput
    children?: VisionUpdateManyWithoutParentNestedInput
  }

  export type VisionUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    children?: VisionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type VisionUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskTagCreateManyTagInput = {
    taskId: string
  }

  export type TaskTagUpdateWithoutTagInput = {
    task?: TaskUpdateOneRequiredWithoutTaskTagsNestedInput
  }

  export type TaskTagUncheckedUpdateWithoutTagInput = {
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskTagUncheckedUpdateManyWithoutTagInput = {
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardComponentCreateManyDashboardInput = {
    id?: string
    title?: string | null
    type?: $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    createdBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type DashboardComponentUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDashboardComponentTypeFieldUpdateOperationsInput | $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardComponentUncheckedUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDashboardComponentTypeFieldUpdateOperationsInput | $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DashboardComponentUncheckedUpdateManyWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumDashboardComponentTypeFieldUpdateOperationsInput | $Enums.DashboardComponentType | null
    config?: NullableJsonNullValueInput | InputJsonValue
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}